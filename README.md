Игра по мотивам занятий на Futurio.ru
=====================================

Демо игры:  
https://khusamov.github.io/solid-futurio-ru-game/

Презентация курса:  
https://futurio.ru/architectures_and_design_patterns

Исходный репозиторий:  
https://github.com/khusamov/solid-futurio-ru-lessons


Возможно генератор Адаптера лучше сделать как генератор кода с AST:  
https://ts-ast-viewer.com/

Домашнее задание для игры:  
https://docs.google.com/document/d/1SSsz9gVGthgEFbdx3eZ4kWGBbKS_tdiEo9yVEVhBGHA/edit

О векторах в играх:  
https://habr.com/ru/post/131931/  
https://habr.com/ru/post/430146/  

Box2D  
https://www.npmjs.com/package/@box2d/core  
https://github.com/flyover/box2d.ts

Top Games made with Box2D tagged 2D  
https://itch.io/games/made-with-box2d/tag-2d

Приказы (сообщения) и команды
-----------------------------

Система команд довольно проста и понятна.

Команда это просто объект с методом execute(). Параметры команды создаются при помощи конструктора или замыканий.

Очередь команд это объект с интерфейсом IQueue. В программе создается таймер, который постоянно проверяет очередь
на наличие команд и их исполняет. Этот процесс бесконечный. Ну разве что его может прервать на время функция 
Пауза (обычно в играх есть).

Приказы или сообщения это простые объекты (без ссылок, то есть эти объекты поддаются простой сериализации и десериализации
со стопроцентным восстановлением, так как предназначены для передачи, например, по сети).

На основе любого приказа строится команда. Это как пример конечно, возможно наверное изменение этого правила и на основе приказа
строить что-то иное. Но это сильно упрощает архитектуру приложения.

Есть очередь приказов. И таймер (или специальные команда из очереди команд), который постоянно извлекает приказы, 
конвертирует их в команды, команды отправляет в очередь команд.

И вот с этой точки зрения адаптеры для приказов собственно говоря не нужны.
Вопрос - это действительно так?

Для команд на их входы подаются адаптеры, в не универсальные объекты. Это нужно, чтобы команды не зависили от 
универсальных объектов, которые могут быть весьма разными в реализации. А вот обработке приказов в общем-то не требуется
такой механизм защиты.

Игра на основе команд и универсальных объектов
----------------------------------------------

Чтобы создать игровой объект нужно
- создать универсальный объект
- при помощи адаптеров инициализировать его
- разместить в массиве игровых объектов
- создать команды для данного объекта и разместить их в очереди команд

На ООП это не похоже. Все разрозненное какое-то и не зависимое друг от друга.

Чтобы создать новое поведение игрового объекта нужно
- создать интерфейс на игровой объект
- создать адаптер для этого интерфейса
- создать команду или команды, которые на вход получают эти адаптеры

В итоге есть абстрактные игровые объекты и есть некие поведения в виде интерфейсов и команд.
Это похоже на систему в Unity, но в чем конкретно разница не ясно (точнее в чем достоинства 
и недостатки той или иной системы). В Unity поведение определяют компоненты, которые как 
плагины прикрепляются к игровому объекту. У каждого игрового объекта есть два метода: update() и render().
Они же есть у каждого компонента. Эти методы рекурсивно вызываются на каждом игровом цикле.

В системе на основе команд update() реализован при помощи таймера, который обрабатывает очередь команд.
А render() это отдельный таймер, который периодически читает массив универсальных объектов. 
Это кстати плохо, так как он может начать читать в тот момент, когда массив еще не обновлен полностью 
и на экране будет отображена некорректная игровая ситуация (что-то успело обновиться, а что-то еще не успело).
Это все из-за того, что процессы update() и render() не синхронизированы. Мягко говоря даже сложно определить
а где начало и конец update(). Мало того, команды в очереди команд могут в любой момент появится и исчезнуть.

В итоге для системы на основе команд нужно еще придумать способ синхронизации процессов update() и render().
Без этого в реальной игре скорее всего появятся проблемы при отрисовке игровой ситуации. 

Как синхронизировать update() и render()?
-----------------------------------------

Вполне возможно можно будет создать команду, которая 
- будет выполняться длительно
- и будет вызывать requestAnimationFrame() 

Если такая команда будет находится в очереди, то она и будет разделителем процесса update().