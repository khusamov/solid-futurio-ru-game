
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@types/react/index'), require('@types/node/events')) :
	typeof define === 'function' && define.amd ? define(['@types/react/index', '@types/node/events'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["LΦ_1"], global["LΦ_2"]));
})(this, (function (LΦ_1, LΦ_2) { 'use strict';

	function _interopNamespace(e) {
		if (e && e.__esModule) return e;
		var n = Object.create(null);
		if (e) {
			Object.keys(e).forEach(function (k) {
				if (k !== 'default') {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		}
		n["default"] = e;
		return Object.freeze(n);
	}

	var LΦ_1__namespace = /*#__PURE__*/_interopNamespace(LΦ_1);
	var LΦ_2__namespace = /*#__PURE__*/_interopNamespace(LΦ_2);

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getAugmentedNamespace(n) {
		if (n.__esModule) return n;
		var a = Object.defineProperty({}, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	var jsxRuntime = {exports: {}};

	var reactJsxRuntime_production_min = {};

	var react$1 = {exports: {}};

	var react_production_min = {};

	/**
	 * @license React
	 * react.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var l$1=Symbol.for("react.element"),n$1=Symbol.for("react.portal"),p$2=Symbol.for("react.fragment"),q$2=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z$1=Symbol.iterator;function A$1(a){if(null===a||"object"!==typeof a)return null;a=z$1&&a[z$1]||a["@@iterator"];return "function"===typeof a?a:null}
	var B={isMounted:function(){return !1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D$1={};function E$1(a,b,e){this.props=a;this.context=b;this.refs=D$1;this.updater=e||B;}E$1.prototype.isReactComponent={};
	E$1.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState");};E$1.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate");};function F$1(){}F$1.prototype=E$1.prototype;function G$1(a,b,e){this.props=a;this.context=b;this.refs=D$1;this.updater=e||B;}var H$1=G$1.prototype=new F$1;
	H$1.constructor=G$1;C(H$1,E$1.prototype);H$1.isPureReactComponent=!0;var I$1=Array.isArray,J$1=Object.prototype.hasOwnProperty,K$1={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};
	function M$1(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)J$1.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f;}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return {$$typeof:l$1,type:a,key:k,ref:h,props:c,_owner:K$1.current}}
	function N$1(a,b){return {$$typeof:l$1,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return "object"===typeof a&&null!==a&&a.$$typeof===l$1}function escape(a){var b={"=":"=0",":":"=2"};return "$"+a.replace(/[=:]/g,function(a){return b[a]})}var P$1=/\/+/g;function Q$1(a,b){return "object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}
	function R$7(a,b,e,d,c){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case l$1:case n$1:h=!0;}}if(h)return h=a,c=c(h),a=""===d?"."+Q$1(h,0):d,I$1(c)?(e="",null!=a&&(e=a.replace(P$1,"$&/")+"/"),R$7(c,b,e,"",function(a){return a})):null!=c&&(O(c)&&(c=N$1(c,e+(!c.key||h&&h.key===c.key?"":(""+c.key).replace(P$1,"$&/")+"/")+a)),b.push(c)),1;h=0;d=""===d?".":d+":";if(I$1(a))for(var g=0;g<a.length;g++){k=
	a[g];var f=d+Q$1(k,g);h+=R$7(k,b,e,f,c);}else if(f=A$1(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q$1(k,g++),h+=R$7(k,b,e,f,c);else if("object"===k)throw b=String(a),Error("Objects are not valid as a React child (found: "+("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}
	function S$1(a,b,e){if(null==a)return a;var d=[],c=0;R$7(a,d,"","",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b;},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b;});-1===a._status&&(a._status=0,a._result=b);}if(1===a._status)return a._result.default;throw a._result;}
	var U$1={current:null},V$1={transition:null},W$1={ReactCurrentDispatcher:U$1,ReactCurrentBatchConfig:V$1,ReactCurrentOwner:K$1};react_production_min.Children={map:S$1,forEach:function(a,b,e){S$1(a,function(){b.apply(this,arguments);},e);},count:function(a){var b=0;S$1(a,function(){b++;});return b},toArray:function(a){return S$1(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};react_production_min.Component=E$1;react_production_min.Fragment=p$2;
	react_production_min.Profiler=r;react_production_min.PureComponent=G$1;react_production_min.StrictMode=q$2;react_production_min.Suspense=w;react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W$1;
	react_production_min.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K$1.current);void 0!==b.key&&(c=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J$1.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f]);}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);
	for(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g;}return {$$typeof:l$1,type:a.type,key:c,ref:k,props:d,_owner:h}};react_production_min.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};react_production_min.createElement=M$1;react_production_min.createFactory=function(a){var b=M$1.bind(null,a);b.type=a;return b};react_production_min.createRef=function(){return {current:null}};
	react_production_min.forwardRef=function(a){return {$$typeof:v,render:a}};react_production_min.isValidElement=O;react_production_min.lazy=function(a){return {$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};react_production_min.memo=function(a,b){return {$$typeof:x,type:a,compare:void 0===b?null:b}};react_production_min.startTransition=function(a){var b=V$1.transition;V$1.transition={};try{a();}finally{V$1.transition=b;}};react_production_min.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.");};
	react_production_min.useCallback=function(a,b){return U$1.current.useCallback(a,b)};react_production_min.useContext=function(a){return U$1.current.useContext(a)};react_production_min.useDebugValue=function(){};react_production_min.useDeferredValue=function(a){return U$1.current.useDeferredValue(a)};react_production_min.useEffect=function(a,b){return U$1.current.useEffect(a,b)};react_production_min.useId=function(){return U$1.current.useId()};react_production_min.useImperativeHandle=function(a,b,e){return U$1.current.useImperativeHandle(a,b,e)};
	react_production_min.useInsertionEffect=function(a,b){return U$1.current.useInsertionEffect(a,b)};react_production_min.useLayoutEffect=function(a,b){return U$1.current.useLayoutEffect(a,b)};react_production_min.useMemo=function(a,b){return U$1.current.useMemo(a,b)};react_production_min.useReducer=function(a,b,e){return U$1.current.useReducer(a,b,e)};react_production_min.useRef=function(a){return U$1.current.useRef(a)};react_production_min.useState=function(a){return U$1.current.useState(a)};react_production_min.useSyncExternalStore=function(a,b,e){return U$1.current.useSyncExternalStore(a,b,e)};
	react_production_min.useTransition=function(){return U$1.current.useTransition()};react_production_min.version="18.1.0";

	{
	  react$1.exports = react_production_min;
	}

	/**
	 * @license React
	 * react-jsx-runtime.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var f=react$1.exports,k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p$1={key:!0,ref:!0,__self:!0,__source:!0};
	function q$1(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=""+g);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p$1.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return {$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}reactJsxRuntime_production_min.Fragment=l;reactJsxRuntime_production_min.jsx=q$1;reactJsxRuntime_production_min.jsxs=q$1;

	{
	  jsxRuntime.exports = reactJsxRuntime_production_min;
	}

	/*! *****************************************************************************
	Copyright (C) Microsoft. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */

	var Reflect$1;
	(function (Reflect) {
	    // Metadata Proposal
	    // https://rbuckton.github.io/reflect-metadata/
	    (function (factory) {
	        var root = typeof commonjsGlobal === "object" ? commonjsGlobal :
	            typeof self === "object" ? self :
	                typeof this === "object" ? this :
	                    Function("return this;")();
	        var exporter = makeExporter(Reflect);
	        if (typeof root.Reflect === "undefined") {
	            root.Reflect = Reflect;
	        }
	        else {
	            exporter = makeExporter(root.Reflect, exporter);
	        }
	        factory(exporter);
	        function makeExporter(target, previous) {
	            return function (key, value) {
	                if (typeof target[key] !== "function") {
	                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
	                }
	                if (previous)
	                    previous(key, value);
	            };
	        }
	    })(function (exporter) {
	        var hasOwn = Object.prototype.hasOwnProperty;
	        // feature test for Symbol support
	        var supportsSymbol = typeof Symbol === "function";
	        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
	        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
	        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
	        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
	        var downLevel = !supportsCreate && !supportsProto;
	        var HashMap = {
	            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
	            create: supportsCreate
	                ? function () { return MakeDictionary(Object.create(null)); }
	                : supportsProto
	                    ? function () { return MakeDictionary({ __proto__: null }); }
	                    : function () { return MakeDictionary({}); },
	            has: downLevel
	                ? function (map, key) { return hasOwn.call(map, key); }
	                : function (map, key) { return key in map; },
	            get: downLevel
	                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
	                : function (map, key) { return map[key]; },
	        };
	        // Load global or shim versions of Map, Set, and WeakMap
	        var functionPrototype = Object.getPrototypeOf(Function);
	        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
	        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
	        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
	        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
	        // [[Metadata]] internal slot
	        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
	        var Metadata = new _WeakMap();
	        /**
	         * Applies a set of decorators to a property of a target object.
	         * @param decorators An array of decorators.
	         * @param target The target object.
	         * @param propertyKey (Optional) The property key to decorate.
	         * @param attributes (Optional) The property descriptor for the target key.
	         * @remarks Decorators are applied in reverse order.
	         * @example
	         *
	         *     class Example {
	         *         // property declarations are not part of ES6, though they are valid in TypeScript:
	         *         // static staticProperty;
	         *         // property;
	         *
	         *         constructor(p) { }
	         *         static staticMethod(p) { }
	         *         method(p) { }
	         *     }
	         *
	         *     // constructor
	         *     Example = Reflect.decorate(decoratorsArray, Example);
	         *
	         *     // property (on constructor)
	         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
	         *
	         *     // property (on prototype)
	         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
	         *
	         *     // method (on constructor)
	         *     Object.defineProperty(Example, "staticMethod",
	         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
	         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
	         *
	         *     // method (on prototype)
	         *     Object.defineProperty(Example.prototype, "method",
	         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
	         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
	         *
	         */
	        function decorate(decorators, target, propertyKey, attributes) {
	            if (!IsUndefined(propertyKey)) {
	                if (!IsArray(decorators))
	                    throw new TypeError();
	                if (!IsObject(target))
	                    throw new TypeError();
	                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
	                    throw new TypeError();
	                if (IsNull(attributes))
	                    attributes = undefined;
	                propertyKey = ToPropertyKey(propertyKey);
	                return DecorateProperty(decorators, target, propertyKey, attributes);
	            }
	            else {
	                if (!IsArray(decorators))
	                    throw new TypeError();
	                if (!IsConstructor(target))
	                    throw new TypeError();
	                return DecorateConstructor(decorators, target);
	            }
	        }
	        exporter("decorate", decorate);
	        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
	        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
	        /**
	         * A default metadata decorator factory that can be used on a class, class member, or parameter.
	         * @param metadataKey The key for the metadata entry.
	         * @param metadataValue The value for the metadata entry.
	         * @returns A decorator function.
	         * @remarks
	         * If `metadataKey` is already defined for the target and target key, the
	         * metadataValue for that key will be overwritten.
	         * @example
	         *
	         *     // constructor
	         *     @Reflect.metadata(key, value)
	         *     class Example {
	         *     }
	         *
	         *     // property (on constructor, TypeScript only)
	         *     class Example {
	         *         @Reflect.metadata(key, value)
	         *         static staticProperty;
	         *     }
	         *
	         *     // property (on prototype, TypeScript only)
	         *     class Example {
	         *         @Reflect.metadata(key, value)
	         *         property;
	         *     }
	         *
	         *     // method (on constructor)
	         *     class Example {
	         *         @Reflect.metadata(key, value)
	         *         static staticMethod() { }
	         *     }
	         *
	         *     // method (on prototype)
	         *     class Example {
	         *         @Reflect.metadata(key, value)
	         *         method() { }
	         *     }
	         *
	         */
	        function metadata(metadataKey, metadataValue) {
	            function decorator(target, propertyKey) {
	                if (!IsObject(target))
	                    throw new TypeError();
	                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
	                    throw new TypeError();
	                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
	            }
	            return decorator;
	        }
	        exporter("metadata", metadata);
	        /**
	         * Define a unique metadata entry on the target.
	         * @param metadataKey A key used to store and retrieve metadata.
	         * @param metadataValue A value that contains attached metadata.
	         * @param target The target object on which to define metadata.
	         * @param propertyKey (Optional) The property key for the target.
	         * @example
	         *
	         *     class Example {
	         *         // property declarations are not part of ES6, though they are valid in TypeScript:
	         *         // static staticProperty;
	         *         // property;
	         *
	         *         constructor(p) { }
	         *         static staticMethod(p) { }
	         *         method(p) { }
	         *     }
	         *
	         *     // constructor
	         *     Reflect.defineMetadata("custom:annotation", options, Example);
	         *
	         *     // property (on constructor)
	         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
	         *
	         *     // property (on prototype)
	         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
	         *
	         *     // method (on constructor)
	         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
	         *
	         *     // method (on prototype)
	         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
	         *
	         *     // decorator factory as metadata-producing annotation.
	         *     function MyAnnotation(options): Decorator {
	         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
	         *     }
	         *
	         */
	        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
	            if (!IsObject(target))
	                throw new TypeError();
	            if (!IsUndefined(propertyKey))
	                propertyKey = ToPropertyKey(propertyKey);
	            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
	        }
	        exporter("defineMetadata", defineMetadata);
	        /**
	         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
	         * @param metadataKey A key used to store and retrieve metadata.
	         * @param target The target object on which the metadata is defined.
	         * @param propertyKey (Optional) The property key for the target.
	         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
	         * @example
	         *
	         *     class Example {
	         *         // property declarations are not part of ES6, though they are valid in TypeScript:
	         *         // static staticProperty;
	         *         // property;
	         *
	         *         constructor(p) { }
	         *         static staticMethod(p) { }
	         *         method(p) { }
	         *     }
	         *
	         *     // constructor
	         *     result = Reflect.hasMetadata("custom:annotation", Example);
	         *
	         *     // property (on constructor)
	         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
	         *
	         *     // property (on prototype)
	         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
	         *
	         *     // method (on constructor)
	         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
	         *
	         *     // method (on prototype)
	         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
	         *
	         */
	        function hasMetadata(metadataKey, target, propertyKey) {
	            if (!IsObject(target))
	                throw new TypeError();
	            if (!IsUndefined(propertyKey))
	                propertyKey = ToPropertyKey(propertyKey);
	            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
	        }
	        exporter("hasMetadata", hasMetadata);
	        /**
	         * Gets a value indicating whether the target object has the provided metadata key defined.
	         * @param metadataKey A key used to store and retrieve metadata.
	         * @param target The target object on which the metadata is defined.
	         * @param propertyKey (Optional) The property key for the target.
	         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
	         * @example
	         *
	         *     class Example {
	         *         // property declarations are not part of ES6, though they are valid in TypeScript:
	         *         // static staticProperty;
	         *         // property;
	         *
	         *         constructor(p) { }
	         *         static staticMethod(p) { }
	         *         method(p) { }
	         *     }
	         *
	         *     // constructor
	         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
	         *
	         *     // property (on constructor)
	         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
	         *
	         *     // property (on prototype)
	         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
	         *
	         *     // method (on constructor)
	         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
	         *
	         *     // method (on prototype)
	         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
	         *
	         */
	        function hasOwnMetadata(metadataKey, target, propertyKey) {
	            if (!IsObject(target))
	                throw new TypeError();
	            if (!IsUndefined(propertyKey))
	                propertyKey = ToPropertyKey(propertyKey);
	            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
	        }
	        exporter("hasOwnMetadata", hasOwnMetadata);
	        /**
	         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
	         * @param metadataKey A key used to store and retrieve metadata.
	         * @param target The target object on which the metadata is defined.
	         * @param propertyKey (Optional) The property key for the target.
	         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
	         * @example
	         *
	         *     class Example {
	         *         // property declarations are not part of ES6, though they are valid in TypeScript:
	         *         // static staticProperty;
	         *         // property;
	         *
	         *         constructor(p) { }
	         *         static staticMethod(p) { }
	         *         method(p) { }
	         *     }
	         *
	         *     // constructor
	         *     result = Reflect.getMetadata("custom:annotation", Example);
	         *
	         *     // property (on constructor)
	         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
	         *
	         *     // property (on prototype)
	         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
	         *
	         *     // method (on constructor)
	         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
	         *
	         *     // method (on prototype)
	         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
	         *
	         */
	        function getMetadata(metadataKey, target, propertyKey) {
	            if (!IsObject(target))
	                throw new TypeError();
	            if (!IsUndefined(propertyKey))
	                propertyKey = ToPropertyKey(propertyKey);
	            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
	        }
	        exporter("getMetadata", getMetadata);
	        /**
	         * Gets the metadata value for the provided metadata key on the target object.
	         * @param metadataKey A key used to store and retrieve metadata.
	         * @param target The target object on which the metadata is defined.
	         * @param propertyKey (Optional) The property key for the target.
	         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
	         * @example
	         *
	         *     class Example {
	         *         // property declarations are not part of ES6, though they are valid in TypeScript:
	         *         // static staticProperty;
	         *         // property;
	         *
	         *         constructor(p) { }
	         *         static staticMethod(p) { }
	         *         method(p) { }
	         *     }
	         *
	         *     // constructor
	         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
	         *
	         *     // property (on constructor)
	         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
	         *
	         *     // property (on prototype)
	         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
	         *
	         *     // method (on constructor)
	         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
	         *
	         *     // method (on prototype)
	         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
	         *
	         */
	        function getOwnMetadata(metadataKey, target, propertyKey) {
	            if (!IsObject(target))
	                throw new TypeError();
	            if (!IsUndefined(propertyKey))
	                propertyKey = ToPropertyKey(propertyKey);
	            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
	        }
	        exporter("getOwnMetadata", getOwnMetadata);
	        /**
	         * Gets the metadata keys defined on the target object or its prototype chain.
	         * @param target The target object on which the metadata is defined.
	         * @param propertyKey (Optional) The property key for the target.
	         * @returns An array of unique metadata keys.
	         * @example
	         *
	         *     class Example {
	         *         // property declarations are not part of ES6, though they are valid in TypeScript:
	         *         // static staticProperty;
	         *         // property;
	         *
	         *         constructor(p) { }
	         *         static staticMethod(p) { }
	         *         method(p) { }
	         *     }
	         *
	         *     // constructor
	         *     result = Reflect.getMetadataKeys(Example);
	         *
	         *     // property (on constructor)
	         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
	         *
	         *     // property (on prototype)
	         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
	         *
	         *     // method (on constructor)
	         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
	         *
	         *     // method (on prototype)
	         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
	         *
	         */
	        function getMetadataKeys(target, propertyKey) {
	            if (!IsObject(target))
	                throw new TypeError();
	            if (!IsUndefined(propertyKey))
	                propertyKey = ToPropertyKey(propertyKey);
	            return OrdinaryMetadataKeys(target, propertyKey);
	        }
	        exporter("getMetadataKeys", getMetadataKeys);
	        /**
	         * Gets the unique metadata keys defined on the target object.
	         * @param target The target object on which the metadata is defined.
	         * @param propertyKey (Optional) The property key for the target.
	         * @returns An array of unique metadata keys.
	         * @example
	         *
	         *     class Example {
	         *         // property declarations are not part of ES6, though they are valid in TypeScript:
	         *         // static staticProperty;
	         *         // property;
	         *
	         *         constructor(p) { }
	         *         static staticMethod(p) { }
	         *         method(p) { }
	         *     }
	         *
	         *     // constructor
	         *     result = Reflect.getOwnMetadataKeys(Example);
	         *
	         *     // property (on constructor)
	         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
	         *
	         *     // property (on prototype)
	         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
	         *
	         *     // method (on constructor)
	         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
	         *
	         *     // method (on prototype)
	         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
	         *
	         */
	        function getOwnMetadataKeys(target, propertyKey) {
	            if (!IsObject(target))
	                throw new TypeError();
	            if (!IsUndefined(propertyKey))
	                propertyKey = ToPropertyKey(propertyKey);
	            return OrdinaryOwnMetadataKeys(target, propertyKey);
	        }
	        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
	        /**
	         * Deletes the metadata entry from the target object with the provided key.
	         * @param metadataKey A key used to store and retrieve metadata.
	         * @param target The target object on which the metadata is defined.
	         * @param propertyKey (Optional) The property key for the target.
	         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
	         * @example
	         *
	         *     class Example {
	         *         // property declarations are not part of ES6, though they are valid in TypeScript:
	         *         // static staticProperty;
	         *         // property;
	         *
	         *         constructor(p) { }
	         *         static staticMethod(p) { }
	         *         method(p) { }
	         *     }
	         *
	         *     // constructor
	         *     result = Reflect.deleteMetadata("custom:annotation", Example);
	         *
	         *     // property (on constructor)
	         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
	         *
	         *     // property (on prototype)
	         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
	         *
	         *     // method (on constructor)
	         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
	         *
	         *     // method (on prototype)
	         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
	         *
	         */
	        function deleteMetadata(metadataKey, target, propertyKey) {
	            if (!IsObject(target))
	                throw new TypeError();
	            if (!IsUndefined(propertyKey))
	                propertyKey = ToPropertyKey(propertyKey);
	            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
	            if (IsUndefined(metadataMap))
	                return false;
	            if (!metadataMap.delete(metadataKey))
	                return false;
	            if (metadataMap.size > 0)
	                return true;
	            var targetMetadata = Metadata.get(target);
	            targetMetadata.delete(propertyKey);
	            if (targetMetadata.size > 0)
	                return true;
	            Metadata.delete(target);
	            return true;
	        }
	        exporter("deleteMetadata", deleteMetadata);
	        function DecorateConstructor(decorators, target) {
	            for (var i = decorators.length - 1; i >= 0; --i) {
	                var decorator = decorators[i];
	                var decorated = decorator(target);
	                if (!IsUndefined(decorated) && !IsNull(decorated)) {
	                    if (!IsConstructor(decorated))
	                        throw new TypeError();
	                    target = decorated;
	                }
	            }
	            return target;
	        }
	        function DecorateProperty(decorators, target, propertyKey, descriptor) {
	            for (var i = decorators.length - 1; i >= 0; --i) {
	                var decorator = decorators[i];
	                var decorated = decorator(target, propertyKey, descriptor);
	                if (!IsUndefined(decorated) && !IsNull(decorated)) {
	                    if (!IsObject(decorated))
	                        throw new TypeError();
	                    descriptor = decorated;
	                }
	            }
	            return descriptor;
	        }
	        function GetOrCreateMetadataMap(O, P, Create) {
	            var targetMetadata = Metadata.get(O);
	            if (IsUndefined(targetMetadata)) {
	                if (!Create)
	                    return undefined;
	                targetMetadata = new _Map();
	                Metadata.set(O, targetMetadata);
	            }
	            var metadataMap = targetMetadata.get(P);
	            if (IsUndefined(metadataMap)) {
	                if (!Create)
	                    return undefined;
	                metadataMap = new _Map();
	                targetMetadata.set(P, metadataMap);
	            }
	            return metadataMap;
	        }
	        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
	        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
	        function OrdinaryHasMetadata(MetadataKey, O, P) {
	            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
	            if (hasOwn)
	                return true;
	            var parent = OrdinaryGetPrototypeOf(O);
	            if (!IsNull(parent))
	                return OrdinaryHasMetadata(MetadataKey, parent, P);
	            return false;
	        }
	        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
	        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
	        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
	            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
	            if (IsUndefined(metadataMap))
	                return false;
	            return ToBoolean(metadataMap.has(MetadataKey));
	        }
	        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
	        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
	        function OrdinaryGetMetadata(MetadataKey, O, P) {
	            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
	            if (hasOwn)
	                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
	            var parent = OrdinaryGetPrototypeOf(O);
	            if (!IsNull(parent))
	                return OrdinaryGetMetadata(MetadataKey, parent, P);
	            return undefined;
	        }
	        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
	        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
	        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
	            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
	            if (IsUndefined(metadataMap))
	                return undefined;
	            return metadataMap.get(MetadataKey);
	        }
	        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
	        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
	        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
	            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
	            metadataMap.set(MetadataKey, MetadataValue);
	        }
	        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
	        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
	        function OrdinaryMetadataKeys(O, P) {
	            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
	            var parent = OrdinaryGetPrototypeOf(O);
	            if (parent === null)
	                return ownKeys;
	            var parentKeys = OrdinaryMetadataKeys(parent, P);
	            if (parentKeys.length <= 0)
	                return ownKeys;
	            if (ownKeys.length <= 0)
	                return parentKeys;
	            var set = new _Set();
	            var keys = [];
	            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
	                var key = ownKeys_1[_i];
	                var hasKey = set.has(key);
	                if (!hasKey) {
	                    set.add(key);
	                    keys.push(key);
	                }
	            }
	            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
	                var key = parentKeys_1[_a];
	                var hasKey = set.has(key);
	                if (!hasKey) {
	                    set.add(key);
	                    keys.push(key);
	                }
	            }
	            return keys;
	        }
	        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
	        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
	        function OrdinaryOwnMetadataKeys(O, P) {
	            var keys = [];
	            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
	            if (IsUndefined(metadataMap))
	                return keys;
	            var keysObj = metadataMap.keys();
	            var iterator = GetIterator(keysObj);
	            var k = 0;
	            while (true) {
	                var next = IteratorStep(iterator);
	                if (!next) {
	                    keys.length = k;
	                    return keys;
	                }
	                var nextValue = IteratorValue(next);
	                try {
	                    keys[k] = nextValue;
	                }
	                catch (e) {
	                    try {
	                        IteratorClose(iterator);
	                    }
	                    finally {
	                        throw e;
	                    }
	                }
	                k++;
	            }
	        }
	        // 6 ECMAScript Data Typ0es and Values
	        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
	        function Type(x) {
	            if (x === null)
	                return 1 /* Null */;
	            switch (typeof x) {
	                case "undefined": return 0 /* Undefined */;
	                case "boolean": return 2 /* Boolean */;
	                case "string": return 3 /* String */;
	                case "symbol": return 4 /* Symbol */;
	                case "number": return 5 /* Number */;
	                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
	                default: return 6 /* Object */;
	            }
	        }
	        // 6.1.1 The Undefined Type
	        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
	        function IsUndefined(x) {
	            return x === undefined;
	        }
	        // 6.1.2 The Null Type
	        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
	        function IsNull(x) {
	            return x === null;
	        }
	        // 6.1.5 The Symbol Type
	        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
	        function IsSymbol(x) {
	            return typeof x === "symbol";
	        }
	        // 6.1.7 The Object Type
	        // https://tc39.github.io/ecma262/#sec-object-type
	        function IsObject(x) {
	            return typeof x === "object" ? x !== null : typeof x === "function";
	        }
	        // 7.1 Type Conversion
	        // https://tc39.github.io/ecma262/#sec-type-conversion
	        // 7.1.1 ToPrimitive(input [, PreferredType])
	        // https://tc39.github.io/ecma262/#sec-toprimitive
	        function ToPrimitive(input, PreferredType) {
	            switch (Type(input)) {
	                case 0 /* Undefined */: return input;
	                case 1 /* Null */: return input;
	                case 2 /* Boolean */: return input;
	                case 3 /* String */: return input;
	                case 4 /* Symbol */: return input;
	                case 5 /* Number */: return input;
	            }
	            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
	            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
	            if (exoticToPrim !== undefined) {
	                var result = exoticToPrim.call(input, hint);
	                if (IsObject(result))
	                    throw new TypeError();
	                return result;
	            }
	            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
	        }
	        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
	        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
	        function OrdinaryToPrimitive(O, hint) {
	            if (hint === "string") {
	                var toString_1 = O.toString;
	                if (IsCallable(toString_1)) {
	                    var result = toString_1.call(O);
	                    if (!IsObject(result))
	                        return result;
	                }
	                var valueOf = O.valueOf;
	                if (IsCallable(valueOf)) {
	                    var result = valueOf.call(O);
	                    if (!IsObject(result))
	                        return result;
	                }
	            }
	            else {
	                var valueOf = O.valueOf;
	                if (IsCallable(valueOf)) {
	                    var result = valueOf.call(O);
	                    if (!IsObject(result))
	                        return result;
	                }
	                var toString_2 = O.toString;
	                if (IsCallable(toString_2)) {
	                    var result = toString_2.call(O);
	                    if (!IsObject(result))
	                        return result;
	                }
	            }
	            throw new TypeError();
	        }
	        // 7.1.2 ToBoolean(argument)
	        // https://tc39.github.io/ecma262/2016/#sec-toboolean
	        function ToBoolean(argument) {
	            return !!argument;
	        }
	        // 7.1.12 ToString(argument)
	        // https://tc39.github.io/ecma262/#sec-tostring
	        function ToString(argument) {
	            return "" + argument;
	        }
	        // 7.1.14 ToPropertyKey(argument)
	        // https://tc39.github.io/ecma262/#sec-topropertykey
	        function ToPropertyKey(argument) {
	            var key = ToPrimitive(argument, 3 /* String */);
	            if (IsSymbol(key))
	                return key;
	            return ToString(key);
	        }
	        // 7.2 Testing and Comparison Operations
	        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
	        // 7.2.2 IsArray(argument)
	        // https://tc39.github.io/ecma262/#sec-isarray
	        function IsArray(argument) {
	            return Array.isArray
	                ? Array.isArray(argument)
	                : argument instanceof Object
	                    ? argument instanceof Array
	                    : Object.prototype.toString.call(argument) === "[object Array]";
	        }
	        // 7.2.3 IsCallable(argument)
	        // https://tc39.github.io/ecma262/#sec-iscallable
	        function IsCallable(argument) {
	            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
	            return typeof argument === "function";
	        }
	        // 7.2.4 IsConstructor(argument)
	        // https://tc39.github.io/ecma262/#sec-isconstructor
	        function IsConstructor(argument) {
	            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
	            return typeof argument === "function";
	        }
	        // 7.2.7 IsPropertyKey(argument)
	        // https://tc39.github.io/ecma262/#sec-ispropertykey
	        function IsPropertyKey(argument) {
	            switch (Type(argument)) {
	                case 3 /* String */: return true;
	                case 4 /* Symbol */: return true;
	                default: return false;
	            }
	        }
	        // 7.3 Operations on Objects
	        // https://tc39.github.io/ecma262/#sec-operations-on-objects
	        // 7.3.9 GetMethod(V, P)
	        // https://tc39.github.io/ecma262/#sec-getmethod
	        function GetMethod(V, P) {
	            var func = V[P];
	            if (func === undefined || func === null)
	                return undefined;
	            if (!IsCallable(func))
	                throw new TypeError();
	            return func;
	        }
	        // 7.4 Operations on Iterator Objects
	        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
	        function GetIterator(obj) {
	            var method = GetMethod(obj, iteratorSymbol);
	            if (!IsCallable(method))
	                throw new TypeError(); // from Call
	            var iterator = method.call(obj);
	            if (!IsObject(iterator))
	                throw new TypeError();
	            return iterator;
	        }
	        // 7.4.4 IteratorValue(iterResult)
	        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
	        function IteratorValue(iterResult) {
	            return iterResult.value;
	        }
	        // 7.4.5 IteratorStep(iterator)
	        // https://tc39.github.io/ecma262/#sec-iteratorstep
	        function IteratorStep(iterator) {
	            var result = iterator.next();
	            return result.done ? false : result;
	        }
	        // 7.4.6 IteratorClose(iterator, completion)
	        // https://tc39.github.io/ecma262/#sec-iteratorclose
	        function IteratorClose(iterator) {
	            var f = iterator["return"];
	            if (f)
	                f.call(iterator);
	        }
	        // 9.1 Ordinary Object Internal Methods and Internal Slots
	        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
	        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
	        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
	        function OrdinaryGetPrototypeOf(O) {
	            var proto = Object.getPrototypeOf(O);
	            if (typeof O !== "function" || O === functionPrototype)
	                return proto;
	            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
	            // Try to determine the superclass constructor. Compatible implementations
	            // must either set __proto__ on a subclass constructor to the superclass constructor,
	            // or ensure each class has a valid `constructor` property on its prototype that
	            // points back to the constructor.
	            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
	            // This is the case when in ES6 or when using __proto__ in a compatible browser.
	            if (proto !== functionPrototype)
	                return proto;
	            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
	            var prototype = O.prototype;
	            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
	            if (prototypeProto == null || prototypeProto === Object.prototype)
	                return proto;
	            // If the constructor was not a function, then we cannot determine the heritage.
	            var constructor = prototypeProto.constructor;
	            if (typeof constructor !== "function")
	                return proto;
	            // If we have some kind of self-reference, then we cannot determine the heritage.
	            if (constructor === O)
	                return proto;
	            // we have a pretty good guess at the heritage.
	            return constructor;
	        }
	        // naive Map shim
	        function CreateMapPolyfill() {
	            var cacheSentinel = {};
	            var arraySentinel = [];
	            var MapIterator = /** @class */ (function () {
	                function MapIterator(keys, values, selector) {
	                    this._index = 0;
	                    this._keys = keys;
	                    this._values = values;
	                    this._selector = selector;
	                }
	                MapIterator.prototype["@@iterator"] = function () { return this; };
	                MapIterator.prototype[iteratorSymbol] = function () { return this; };
	                MapIterator.prototype.next = function () {
	                    var index = this._index;
	                    if (index >= 0 && index < this._keys.length) {
	                        var result = this._selector(this._keys[index], this._values[index]);
	                        if (index + 1 >= this._keys.length) {
	                            this._index = -1;
	                            this._keys = arraySentinel;
	                            this._values = arraySentinel;
	                        }
	                        else {
	                            this._index++;
	                        }
	                        return { value: result, done: false };
	                    }
	                    return { value: undefined, done: true };
	                };
	                MapIterator.prototype.throw = function (error) {
	                    if (this._index >= 0) {
	                        this._index = -1;
	                        this._keys = arraySentinel;
	                        this._values = arraySentinel;
	                    }
	                    throw error;
	                };
	                MapIterator.prototype.return = function (value) {
	                    if (this._index >= 0) {
	                        this._index = -1;
	                        this._keys = arraySentinel;
	                        this._values = arraySentinel;
	                    }
	                    return { value: value, done: true };
	                };
	                return MapIterator;
	            }());
	            return /** @class */ (function () {
	                function Map() {
	                    this._keys = [];
	                    this._values = [];
	                    this._cacheKey = cacheSentinel;
	                    this._cacheIndex = -2;
	                }
	                Object.defineProperty(Map.prototype, "size", {
	                    get: function () { return this._keys.length; },
	                    enumerable: true,
	                    configurable: true
	                });
	                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
	                Map.prototype.get = function (key) {
	                    var index = this._find(key, /*insert*/ false);
	                    return index >= 0 ? this._values[index] : undefined;
	                };
	                Map.prototype.set = function (key, value) {
	                    var index = this._find(key, /*insert*/ true);
	                    this._values[index] = value;
	                    return this;
	                };
	                Map.prototype.delete = function (key) {
	                    var index = this._find(key, /*insert*/ false);
	                    if (index >= 0) {
	                        var size = this._keys.length;
	                        for (var i = index + 1; i < size; i++) {
	                            this._keys[i - 1] = this._keys[i];
	                            this._values[i - 1] = this._values[i];
	                        }
	                        this._keys.length--;
	                        this._values.length--;
	                        if (key === this._cacheKey) {
	                            this._cacheKey = cacheSentinel;
	                            this._cacheIndex = -2;
	                        }
	                        return true;
	                    }
	                    return false;
	                };
	                Map.prototype.clear = function () {
	                    this._keys.length = 0;
	                    this._values.length = 0;
	                    this._cacheKey = cacheSentinel;
	                    this._cacheIndex = -2;
	                };
	                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
	                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
	                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
	                Map.prototype["@@iterator"] = function () { return this.entries(); };
	                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
	                Map.prototype._find = function (key, insert) {
	                    if (this._cacheKey !== key) {
	                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
	                    }
	                    if (this._cacheIndex < 0 && insert) {
	                        this._cacheIndex = this._keys.length;
	                        this._keys.push(key);
	                        this._values.push(undefined);
	                    }
	                    return this._cacheIndex;
	                };
	                return Map;
	            }());
	            function getKey(key, _) {
	                return key;
	            }
	            function getValue(_, value) {
	                return value;
	            }
	            function getEntry(key, value) {
	                return [key, value];
	            }
	        }
	        // naive Set shim
	        function CreateSetPolyfill() {
	            return /** @class */ (function () {
	                function Set() {
	                    this._map = new _Map();
	                }
	                Object.defineProperty(Set.prototype, "size", {
	                    get: function () { return this._map.size; },
	                    enumerable: true,
	                    configurable: true
	                });
	                Set.prototype.has = function (value) { return this._map.has(value); };
	                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
	                Set.prototype.delete = function (value) { return this._map.delete(value); };
	                Set.prototype.clear = function () { this._map.clear(); };
	                Set.prototype.keys = function () { return this._map.keys(); };
	                Set.prototype.values = function () { return this._map.values(); };
	                Set.prototype.entries = function () { return this._map.entries(); };
	                Set.prototype["@@iterator"] = function () { return this.keys(); };
	                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
	                return Set;
	            }());
	        }
	        // naive WeakMap shim
	        function CreateWeakMapPolyfill() {
	            var UUID_SIZE = 16;
	            var keys = HashMap.create();
	            var rootKey = CreateUniqueKey();
	            return /** @class */ (function () {
	                function WeakMap() {
	                    this._key = CreateUniqueKey();
	                }
	                WeakMap.prototype.has = function (target) {
	                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
	                    return table !== undefined ? HashMap.has(table, this._key) : false;
	                };
	                WeakMap.prototype.get = function (target) {
	                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
	                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
	                };
	                WeakMap.prototype.set = function (target, value) {
	                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
	                    table[this._key] = value;
	                    return this;
	                };
	                WeakMap.prototype.delete = function (target) {
	                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
	                    return table !== undefined ? delete table[this._key] : false;
	                };
	                WeakMap.prototype.clear = function () {
	                    // NOTE: not a real clear, just makes the previous data unreachable
	                    this._key = CreateUniqueKey();
	                };
	                return WeakMap;
	            }());
	            function CreateUniqueKey() {
	                var key;
	                do
	                    key = "@@WeakMap@@" + CreateUUID();
	                while (HashMap.has(keys, key));
	                keys[key] = true;
	                return key;
	            }
	            function GetOrCreateWeakMapTable(target, create) {
	                if (!hasOwn.call(target, rootKey)) {
	                    if (!create)
	                        return undefined;
	                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
	                }
	                return target[rootKey];
	            }
	            function FillRandomBytes(buffer, size) {
	                for (var i = 0; i < size; ++i)
	                    buffer[i] = Math.random() * 0xff | 0;
	                return buffer;
	            }
	            function GenRandomBytes(size) {
	                if (typeof Uint8Array === "function") {
	                    if (typeof crypto !== "undefined")
	                        return crypto.getRandomValues(new Uint8Array(size));
	                    if (typeof msCrypto !== "undefined")
	                        return msCrypto.getRandomValues(new Uint8Array(size));
	                    return FillRandomBytes(new Uint8Array(size), size);
	                }
	                return FillRandomBytes(new Array(size), size);
	            }
	            function CreateUUID() {
	                var data = GenRandomBytes(UUID_SIZE);
	                // mark as random - RFC 4122 § 4.4
	                data[6] = data[6] & 0x4f | 0x40;
	                data[8] = data[8] & 0xbf | 0x80;
	                var result = "";
	                for (var offset = 0; offset < UUID_SIZE; ++offset) {
	                    var byte = data[offset];
	                    if (offset === 4 || offset === 6 || offset === 8)
	                        result += "-";
	                    if (byte < 16)
	                        result += "0";
	                    result += byte.toString(16).toLowerCase();
	                }
	                return result;
	            }
	        }
	        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
	        function MakeDictionary(obj) {
	            obj.__ = undefined;
	            delete obj.__;
	            return obj;
	        }
	    });
	})(Reflect$1 || (Reflect$1 = {}));

	var reactDom = {exports: {}};

	var reactDom_production_min = {};

	var scheduler = {exports: {}};

	var scheduler_production_min = {};

	/**
	 * @license React
	 * scheduler.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	(function (exports) {
	function f(a,b){var c=a.length;a.push(b);a:for(;0<c;){var d=c-1>>>1,e=a[d];if(0<g(e,b))a[d]=b,a[c]=e,c=d;else break a}}function h(a){return 0===a.length?null:a[0]}function k(a){if(0===a.length)return null;var b=a[0],c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length,w=e>>>1;d<w;){var m=2*(d+1)-1,C=a[m],n=m+1,x=a[n];if(0>g(C,c))n<e&&0>g(x,C)?(a[d]=x,a[n]=c,d=n):(a[d]=C,a[m]=c,d=m);else if(n<e&&0>g(x,c))a[d]=x,a[n]=c,d=n;else break a}}return b}
	function g(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}if("object"===typeof performance&&"function"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()};}else {var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q};}var r=[],t=[],u=1,v=null,y=3,z=!1,A=!1,B=!1,D="function"===typeof setTimeout?setTimeout:null,E="function"===typeof clearTimeout?clearTimeout:null,F="undefined"!==typeof setImmediate?setImmediate:null;
	"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function G(a){for(var b=h(t);null!==b;){if(null===b.callback)k(t);else if(b.startTime<=a)k(t),b.sortIndex=b.expirationTime,f(r,b);else break;b=h(t);}}function H(a){B=!1;G(a);if(!A)if(null!==h(r))A=!0,I(J);else {var b=h(t);null!==b&&K(H,b.startTime-a);}}
	function J(a,b){A=!1;B&&(B=!1,E(L),L=-1);z=!0;var c=y;try{G(b);for(v=h(r);null!==v&&(!(v.expirationTime>b)||a&&!M());){var d=v.callback;if("function"===typeof d){v.callback=null;y=v.priorityLevel;var e=d(v.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?v.callback=e:v===h(r)&&k(r);G(b);}else k(r);v=h(r);}if(null!==v)var w=!0;else {var m=h(t);null!==m&&K(H,m.startTime-b);w=!1;}return w}finally{v=null,y=c,z=!1;}}var N=!1,O=null,L=-1,P=5,Q=-1;
	function M(){return exports.unstable_now()-Q<P?!1:!0}function R(){if(null!==O){var a=exports.unstable_now();Q=a;var b=!0;try{b=O(!0,a);}finally{b?S():(N=!1,O=null);}}else N=!1;}var S;if("function"===typeof F)S=function(){F(R);};else if("undefined"!==typeof MessageChannel){var T=new MessageChannel,U=T.port2;T.port1.onmessage=R;S=function(){U.postMessage(null);};}else S=function(){D(R,0);};function I(a){O=a;N||(N=!0,S());}function K(a,b){L=D(function(){a(exports.unstable_now());},b);}
	exports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null;};exports.unstable_continueExecution=function(){A||z||(A=!0,I(J));};
	exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):P=0<a?Math.floor(1E3/a):5;};exports.unstable_getCurrentPriorityLevel=function(){return y};exports.unstable_getFirstCallbackNode=function(){return h(r)};exports.unstable_next=function(a){switch(y){case 1:case 2:case 3:var b=3;break;default:b=y;}var c=y;y=b;try{return a()}finally{y=c;}};exports.unstable_pauseExecution=function(){};
	exports.unstable_requestPaint=function(){};exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3;}var c=y;y=a;try{return b()}finally{y=c;}};
	exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3;}e=c+e;a={id:u++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,f(t,a),null===h(r)&&a===h(t)&&(B?(E(L),L=-1):B=!0,K(H,c-d))):(a.sortIndex=e,f(r,a),A||z||(A=!0,I(J)));return a};
	exports.unstable_shouldYield=M;exports.unstable_wrapCallback=function(a){var b=y;return function(){var c=y;y=b;try{return a.apply(this,arguments)}finally{y=c;}}};
	}(scheduler_production_min));

	{
	  scheduler.exports = scheduler_production_min;
	}

	/**
	 * @license React
	 * react-dom.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var aa=react$1.exports,ba=scheduler.exports;function p(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return "Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var ca=new Set,da={};function ea(a,b){fa(a,b);fa(a+"Capture",b);}
	function fa(a,b){da[a]=b;for(a=0;a<b.length;a++)ca.add(b[a]);}
	var ha=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),ia=Object.prototype.hasOwnProperty,ja=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,ka=
	{},la={};function ma(a){if(ia.call(la,a))return !0;if(ia.call(ka,a))return !1;if(ja.test(a))return la[a]=!0;ka[a]=!0;return !1}function na(a,b,c,d){if(null!==c&&0===c.type)return !1;switch(typeof b){case "function":case "symbol":return !0;case "boolean":if(d)return !1;if(null!==c)return !c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return "data-"!==a&&"aria-"!==a;default:return !1}}
	function oa(a,b,c,d){if(null===b||"undefined"===typeof b||na(a,b,c,d))return !0;if(d)return !1;if(null!==c)switch(c.type){case 3:return !b;case 4:return !1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return !1}function q(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g;}var z={};
	"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){z[a]=new q(a,0,!1,a,null,!1,!1);});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];z[b]=new q(b,1,!1,a[1],null,!1,!1);});["contentEditable","draggable","spellCheck","value"].forEach(function(a){z[a]=new q(a,2,!1,a.toLowerCase(),null,!1,!1);});
	["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){z[a]=new q(a,2,!1,a,null,!1,!1);});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){z[a]=new q(a,3,!1,a.toLowerCase(),null,!1,!1);});
	["checked","multiple","muted","selected"].forEach(function(a){z[a]=new q(a,3,!0,a,null,!1,!1);});["capture","download"].forEach(function(a){z[a]=new q(a,4,!1,a,null,!1,!1);});["cols","rows","size","span"].forEach(function(a){z[a]=new q(a,6,!1,a,null,!1,!1);});["rowSpan","start"].forEach(function(a){z[a]=new q(a,5,!1,a.toLowerCase(),null,!1,!1);});var pa=/[\-:]([a-z])/g;function qa(a){return a[1].toUpperCase()}
	"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(pa,
	qa);z[b]=new q(b,1,!1,a,null,!1,!1);});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(pa,qa);z[b]=new q(b,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1);});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(pa,qa);z[b]=new q(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1);});["tabIndex","crossOrigin"].forEach(function(a){z[a]=new q(a,1,!1,a.toLowerCase(),null,!1,!1);});
	z.xlinkHref=new q("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){z[a]=new q(a,1,!1,a.toLowerCase(),null,!0,!0);});
	function ra(a,b,c,d){var e=z.hasOwnProperty(b)?z[b]:null;if(null!==e?0!==e.type:d||!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1])oa(b,c,e,d)&&(c=null),d||null===e?ma(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c)));}
	var sa=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,ta=Symbol.for("react.element"),ua=Symbol.for("react.portal"),va=Symbol.for("react.fragment"),wa=Symbol.for("react.strict_mode"),xa=Symbol.for("react.profiler"),ya=Symbol.for("react.provider"),Aa=Symbol.for("react.context"),Ba=Symbol.for("react.forward_ref"),Ca=Symbol.for("react.suspense"),Da=Symbol.for("react.suspense_list"),Ea=Symbol.for("react.memo"),Fa=Symbol.for("react.lazy");var Ga=Symbol.for("react.offscreen");var Ha=Symbol.iterator;function Ia(a){if(null===a||"object"!==typeof a)return null;a=Ha&&a[Ha]||a["@@iterator"];return "function"===typeof a?a:null}var A=Object.assign,Ja;function Ka(a){if(void 0===Ja)try{throw Error();}catch(c){var b=c.stack.trim().match(/\n( *(at )?)/);Ja=b&&b[1]||"";}return "\n"+Ja+a}var La=!1;
	function Ma(a,b){if(!a||La)return "";La=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[]);}catch(l){var d=l;}Reflect.construct(a,[],b);}else {try{b.call();}catch(l){d=l;}a.call(b.prototype);}else {try{throw Error();}catch(l){d=l;}a();}}catch(l){if(l&&d&&"string"===typeof l.stack){for(var e=l.stack.split("\n"),
	f=d.stack.split("\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k="\n"+e[g].replace(" at new "," at ");a.displayName&&k.includes("<anonymous>")&&(k=k.replace("<anonymous>",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{La=!1,Error.prepareStackTrace=c;}return (a=a?a.displayName||a.name:"")?Ka(a):""}
	function Na(a){switch(a.tag){case 5:return Ka(a.type);case 16:return Ka("Lazy");case 13:return Ka("Suspense");case 19:return Ka("SuspenseList");case 0:case 2:case 15:return a=Ma(a.type,!1),a;case 11:return a=Ma(a.type.render,!1),a;case 1:return a=Ma(a.type,!0),a;default:return ""}}
	function Oa(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case va:return "Fragment";case ua:return "Portal";case xa:return "Profiler";case wa:return "StrictMode";case Ca:return "Suspense";case Da:return "SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Aa:return (a.displayName||"Context")+".Consumer";case ya:return (a._context.displayName||"Context")+".Provider";case Ba:var b=a.render;a=a.displayName;a||(a=b.displayName||
	b.name||"",a=""!==a?"ForwardRef("+a+")":"ForwardRef");return a;case Ea:return b=a.displayName||null,null!==b?b:Oa(a.type)||"Memo";case Fa:b=a._payload;a=a._init;try{return Oa(a(b))}catch(c){}}return null}
	function Pa(a){var b=a.type;switch(a.tag){case 24:return "Cache";case 9:return (b.displayName||"Context")+".Consumer";case 10:return (b._context.displayName||"Context")+".Provider";case 18:return "DehydratedFragment";case 11:return a=b.render,a=a.displayName||a.name||"",b.displayName||(""!==a?"ForwardRef("+a+")":"ForwardRef");case 7:return "Fragment";case 5:return b;case 4:return "Portal";case 3:return "Root";case 6:return "Text";case 16:return Oa(b);case 8:return b===wa?"StrictMode":"Mode";case 22:return "Offscreen";
	case 12:return "Profiler";case 21:return "Scope";case 13:return "Suspense";case 19:return "SuspenseList";case 25:return "TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof b)return b.displayName||b.name||null;if("string"===typeof b)return b}return null}function Qa(a){switch(typeof a){case "boolean":case "number":case "string":case "undefined":return a;case "object":return a;default:return ""}}
	function Ra(a){var b=a.type;return (a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
	function Sa(a){var b=Ra(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a);}});Object.defineProperty(a,b,{enumerable:c.enumerable});return {getValue:function(){return d},setValue:function(a){d=""+a;},stopTracking:function(){a._valueTracker=
	null;delete a[b];}}}}function Ta(a){a._valueTracker||(a._valueTracker=Sa(a));}function Ua(a){if(!a)return !1;var b=a._valueTracker;if(!b)return !0;var c=b.getValue();var d="";a&&(d=Ra(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Va(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}
	function Wa(a,b){var c=b.checked;return A({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Xa(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Qa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value};}function Ya(a,b){b=b.checked;null!=b&&ra(a,"checked",b,!1);}
	function Za(a,b){Ya(a,b);var c=Qa(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c;}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?$a(a,b.type,c):b.hasOwnProperty("defaultValue")&&$a(a,b.type,Qa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked);}
	function ab(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b;}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c);}
	function $a(a,b,c){if("number"!==b||Va(a.ownerDocument)!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c);}var bb=Array.isArray;
	function cb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0);}else {c=""+Qa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e]);}null!==b&&(b.selected=!0);}}
	function db(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(p(91));return A({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function eb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(p(92));if(bb(c)){if(1<c.length)throw Error(p(93));c=c[0];}b=c;}null==b&&(b="");c=b;}a._wrapperState={initialValue:Qa(c)};}
	function fb(a,b){var c=Qa(b.value),d=Qa(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d);}function gb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b);}function hb(a){switch(a){case "svg":return "http://www.w3.org/2000/svg";case "math":return "http://www.w3.org/1998/Math/MathML";default:return "http://www.w3.org/1999/xhtml"}}
	function ib(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?hb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
	var jb,kb=function(a){return "undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)});}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else {jb=jb||document.createElement("div");jb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=jb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild);}});
	function lb(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b;}
	var mb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,
	zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},nb=["Webkit","ms","Moz","O"];Object.keys(mb).forEach(function(a){nb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);mb[b]=mb[a];});});function ob(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||mb.hasOwnProperty(a)&&mb[a]?(""+b).trim():b+"px"}
	function pb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=ob(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e;}}var qb=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
	function rb(a,b){if(b){if(qb[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(p(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(p(60));if("object"!==typeof b.dangerouslySetInnerHTML||!("__html"in b.dangerouslySetInnerHTML))throw Error(p(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(p(62));}}
	function sb(a,b){if(-1===a.indexOf("-"))return "string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return !1;default:return !0}}var tb=null;function ub(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var vb=null,wb=null,xb=null;
	function yb(a){if(a=zb(a)){if("function"!==typeof vb)throw Error(p(280));var b=a.stateNode;b&&(b=Ab(b),vb(a.stateNode,a.type,b));}}function Bb(a){wb?xb?xb.push(a):xb=[a]:wb=a;}function Cb(){if(wb){var a=wb,b=xb;xb=wb=null;yb(a);if(b)for(a=0;a<b.length;a++)yb(b[a]);}}function Db(a,b){return a(b)}function Eb(){}var Fb=!1;function Gb(a,b,c){if(Fb)return a(b,c);Fb=!0;try{return Db(a,b,c)}finally{if(Fb=!1,null!==wb||null!==xb)Eb(),Cb();}}
	function Hb(a,b){var c=a.stateNode;if(null===c)return null;var d=Ab(c);if(null===d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1;}if(a)return null;if(c&&"function"!==
	typeof c)throw Error(p(231,b,typeof c));return c}var Ib=!1;if(ha)try{var Jb={};Object.defineProperty(Jb,"passive",{get:function(){Ib=!0;}});window.addEventListener("test",Jb,Jb);window.removeEventListener("test",Jb,Jb);}catch(a){Ib=!1;}function Kb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l);}catch(m){this.onError(m);}}var Lb=!1,Mb=null,Nb=!1,Ob=null,Pb={onError:function(a){Lb=!0;Mb=a;}};function Qb(a,b,c,d,e,f,g,h,k){Lb=!1;Mb=null;Kb.apply(Pb,arguments);}
	function Rb(a,b,c,d,e,f,g,h,k){Qb.apply(this,arguments);if(Lb){if(Lb){var l=Mb;Lb=!1;Mb=null;}else throw Error(p(198));Nb||(Nb=!0,Ob=l);}}function Sb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else {a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Tb(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Ub(a){if(Sb(a)!==a)throw Error(p(188));}
	function Vb(a){var b=a.alternate;if(!b){b=Sb(a);if(null===b)throw Error(p(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Ub(e),a;if(f===d)return Ub(e),b;f=f.sibling;}throw Error(p(188));}if(c.return!==d.return)c=e,d=f;else {for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling;}if(!g){for(h=f.child;h;){if(h===
	c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling;}if(!g)throw Error(p(189));}}if(c.alternate!==d)throw Error(p(190));}if(3!==c.tag)throw Error(p(188));return c.stateNode.current===c?a:b}function Wb(a){a=Vb(a);return null!==a?Xb(a):null}function Xb(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=Xb(a);if(null!==b)return b;a=a.sibling;}return null}
	var Yb=ba.unstable_scheduleCallback,Zb=ba.unstable_cancelCallback,$b=ba.unstable_shouldYield,ac=ba.unstable_requestPaint,D=ba.unstable_now,bc=ba.unstable_getCurrentPriorityLevel,cc=ba.unstable_ImmediatePriority,dc=ba.unstable_UserBlockingPriority,ec=ba.unstable_NormalPriority,fc=ba.unstable_LowPriority,gc=ba.unstable_IdlePriority,hc=null,ic=null;function jc(a){if(ic&&"function"===typeof ic.onCommitFiberRoot)try{ic.onCommitFiberRoot(hc,a,void 0,128===(a.current.flags&128));}catch(b){}}
	var lc=Math.clz32?Math.clz32:kc,mc=Math.log,nc=Math.LN2;function kc(a){a>>>=0;return 0===a?32:31-(mc(a)/nc|0)|0}var oc=64,pc=4194304;
	function qc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;
	default:return a}}function rc(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=qc(h):(f&=g,0!==f&&(d=qc(f)));}else g=c&~e,0!==g?d=qc(g):0!==f&&(d=qc(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-lc(b),e=1<<c,d|=a[c],b&=~e;return d}
	function sc(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return -1;case 134217728:case 268435456:case 536870912:case 1073741824:return -1;default:return -1}}
	function tc(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-lc(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=sc(h,b);}else k<=b&&(a.expiredLanes|=h);f&=~h;}}function uc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function vc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}function wc(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-lc(b);a[b]=c;}
	function xc(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-lc(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f;}}function yc(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-lc(c),e=1<<d;e&b|a[d]&b&&(a[d]|=b);c&=~e;}}var E=0;function zc(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}
	var Ac,Bc,Cc,Dc,Ec,Fc=!1,Gc=[],Hc=null,Ic=null,Jc=null,Kc=new Map,Lc=new Map,Mc=[],Nc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
	function Oc(a,b){switch(a){case "focusin":case "focusout":Hc=null;break;case "dragenter":case "dragleave":Ic=null;break;case "mouseover":case "mouseout":Jc=null;break;case "pointerover":case "pointerout":Kc.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Lc.delete(b.pointerId);}}
	function Pc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a={blockedOn:b,domEventName:c,eventSystemFlags:d,nativeEvent:f,targetContainers:[e]},null!==b&&(b=zb(b),null!==b&&Bc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}
	function Qc(a,b,c,d,e){switch(b){case "focusin":return Hc=Pc(Hc,a,b,c,d,e),!0;case "dragenter":return Ic=Pc(Ic,a,b,c,d,e),!0;case "mouseover":return Jc=Pc(Jc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Kc.set(f,Pc(Kc.get(f)||null,a,b,c,d,e));return !0;case "gotpointercapture":return f=e.pointerId,Lc.set(f,Pc(Lc.get(f)||null,a,b,c,d,e)),!0}return !1}
	function Rc(a){var b=Sc(a.target);if(null!==b){var c=Sb(b);if(null!==c)if(b=c.tag,13===b){if(b=Tb(c),null!==b){a.blockedOn=b;Ec(a.priority,function(){Cc(c);});return}}else if(3===b&&c.stateNode.current.memoizedState.isDehydrated){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null;}
	function Tc(a){if(null!==a.blockedOn)return !1;for(var b=a.targetContainers;0<b.length;){var c=Uc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null===c){c=a.nativeEvent;var d=new c.constructor(c.type,c);tb=d;c.target.dispatchEvent(d);tb=null;}else return b=zb(c),null!==b&&Bc(b),a.blockedOn=c,!1;b.shift();}return !0}function Vc(a,b,c){Tc(a)&&c.delete(b);}function Wc(){Fc=!1;null!==Hc&&Tc(Hc)&&(Hc=null);null!==Ic&&Tc(Ic)&&(Ic=null);null!==Jc&&Tc(Jc)&&(Jc=null);Kc.forEach(Vc);Lc.forEach(Vc);}
	function Xc(a,b){a.blockedOn===b&&(a.blockedOn=null,Fc||(Fc=!0,ba.unstable_scheduleCallback(ba.unstable_NormalPriority,Wc)));}
	function Yc(a){function b(b){return Xc(b,a)}if(0<Gc.length){Xc(Gc[0],a);for(var c=1;c<Gc.length;c++){var d=Gc[c];d.blockedOn===a&&(d.blockedOn=null);}}null!==Hc&&Xc(Hc,a);null!==Ic&&Xc(Ic,a);null!==Jc&&Xc(Jc,a);Kc.forEach(b);Lc.forEach(b);for(c=0;c<Mc.length;c++)d=Mc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Mc.length&&(c=Mc[0],null===c.blockedOn);)Rc(c),null===c.blockedOn&&Mc.shift();}var Zc=sa.ReactCurrentBatchConfig;
	function $c(a,b,c,d){var e=E,f=Zc.transition;Zc.transition=null;try{E=1,ad(a,b,c,d);}finally{E=e,Zc.transition=f;}}function bd(a,b,c,d){var e=E,f=Zc.transition;Zc.transition=null;try{E=4,ad(a,b,c,d);}finally{E=e,Zc.transition=f;}}
	function ad(a,b,c,d){var e=Uc(a,b,c,d);if(null===e)cd(a,b,d,dd,c),Oc(a,d);else if(Qc(e,a,b,c,d))d.stopPropagation();else if(Oc(a,d),b&4&&-1<Nc.indexOf(a)){for(;null!==e;){var f=zb(e);null!==f&&Ac(f);f=Uc(a,b,c,d);null===f&&cd(a,b,d,dd,c);if(f===e)break;e=f;}null!==e&&d.stopPropagation();}else cd(a,b,d,null,c);}var dd=null;
	function Uc(a,b,c,d){dd=null;a=ub(d);a=Sc(a);if(null!==a)if(b=Sb(a),null===b)a=null;else if(c=b.tag,13===c){a=Tb(b);if(null!==a)return a;a=null;}else if(3===c){if(b.stateNode.current.memoizedState.isDehydrated)return 3===b.tag?b.stateNode.containerInfo:null;a=null;}else b!==a&&(a=null);dd=a;return null}
	function ed(a){switch(a){case "cancel":case "click":case "close":case "contextmenu":case "copy":case "cut":case "auxclick":case "dblclick":case "dragend":case "dragstart":case "drop":case "focusin":case "focusout":case "input":case "invalid":case "keydown":case "keypress":case "keyup":case "mousedown":case "mouseup":case "paste":case "pause":case "play":case "pointercancel":case "pointerdown":case "pointerup":case "ratechange":case "reset":case "resize":case "seeked":case "submit":case "touchcancel":case "touchend":case "touchstart":case "volumechange":case "change":case "selectionchange":case "textInput":case "compositionstart":case "compositionend":case "compositionupdate":case "beforeblur":case "afterblur":case "beforeinput":case "blur":case "fullscreenchange":case "focus":case "hashchange":case "popstate":case "select":case "selectstart":return 1;case "drag":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "mousemove":case "mouseout":case "mouseover":case "pointermove":case "pointerout":case "pointerover":case "scroll":case "toggle":case "touchmove":case "wheel":case "mouseenter":case "mouseleave":case "pointerenter":case "pointerleave":return 4;
	case "message":switch(bc()){case cc:return 1;case dc:return 4;case ec:case fc:return 16;case gc:return 536870912;default:return 16}default:return 16}}var fd=null,gd=null,hd=null;function id(){if(hd)return hd;var a,b=gd,c=b.length,d,e="value"in fd?fd.value:fd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return hd=e.slice(a,1<d?1-d:void 0)}
	function jd(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function kd(){return !0}function ld(){return !1}
	function md(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?kd:ld;this.isPropagationStopped=ld;return this}A(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&
	(a.returnValue=!1),this.isDefaultPrevented=kd);},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=kd);},persist:function(){},isPersistent:kd});return b}
	var nd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},od=md(nd),pd=A({},nd,{view:0,detail:0}),qd=md(pd),rd,sd,td,vd=A({},pd,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:ud,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if("movementX"in
	a)return a.movementX;a!==td&&(td&&"mousemove"===a.type?(rd=a.screenX-td.screenX,sd=a.screenY-td.screenY):sd=rd=0,td=a);return rd},movementY:function(a){return "movementY"in a?a.movementY:sd}}),wd=md(vd),xd=A({},vd,{dataTransfer:0}),yd=md(xd),zd=A({},pd,{relatedTarget:0}),Ad=md(zd),Bd=A({},nd,{animationName:0,elapsedTime:0,pseudoElement:0}),Cd=md(Bd),Dd=A({},nd,{clipboardData:function(a){return "clipboardData"in a?a.clipboardData:window.clipboardData}}),Ed=md(Dd),Fd=A({},nd,{data:0}),Gd=md(Fd),Hd={Esc:"Escape",
	Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Id={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",
	119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Jd={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Kd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Jd[a])?!!b[a]:!1}function ud(){return Kd}
	var Ld=A({},pd,{key:function(a){if(a.key){var b=Hd[a.key]||a.key;if("Unidentified"!==b)return b}return "keypress"===a.type?(a=jd(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Id[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:ud,charCode:function(a){return "keypress"===a.type?jd(a):0},keyCode:function(a){return "keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return "keypress"===
	a.type?jd(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Md=md(Ld),Nd=A({},vd,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Od=md(Nd),Pd=A({},pd,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:ud}),Qd=md(Pd),Rd=A({},nd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Sd=md(Rd),Td=A({},vd,{deltaX:function(a){return "deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},
	deltaY:function(a){return "deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Ud=md(Td),Vd=[9,13,27,32],Wd=ha&&"CompositionEvent"in window,Xd=null;ha&&"documentMode"in document&&(Xd=document.documentMode);var Yd=ha&&"TextEvent"in window&&!Xd,Zd=ha&&(!Wd||Xd&&8<Xd&&11>=Xd),$d=String.fromCharCode(32),ae=!1;
	function be(a,b){switch(a){case "keyup":return -1!==Vd.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "focusout":return !0;default:return !1}}function ce(a){a=a.detail;return "object"===typeof a&&"data"in a?a.data:null}var de=!1;function ee(a,b){switch(a){case "compositionend":return ce(b);case "keypress":if(32!==b.which)return null;ae=!0;return $d;case "textInput":return a=b.data,a===$d&&ae?null:a;default:return null}}
	function fe(a,b){if(de)return "compositionend"===a||!Wd&&be(a,b)?(a=id(),hd=gd=fd=null,de=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return Zd&&"ko"!==b.locale?null:b.data;default:return null}}
	var ge={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function he(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return "input"===b?!!ge[a.type]:"textarea"===b?!0:!1}function ie(a,b,c,d){Bb(d);b=je(b,"onChange");0<b.length&&(c=new od("onChange","change",null,c,d),a.push({event:c,listeners:b}));}var ke=null,le=null;function me(a){ne(a,0);}function oe(a){var b=pe(a);if(Ua(b))return a}
	function qe(a,b){if("change"===a)return b}var re=!1;if(ha){var se;if(ha){var te="oninput"in document;if(!te){var ue=document.createElement("div");ue.setAttribute("oninput","return;");te="function"===typeof ue.oninput;}se=te;}else se=!1;re=se&&(!document.documentMode||9<document.documentMode);}function ve(){ke&&(ke.detachEvent("onpropertychange",we),le=ke=null);}function we(a){if("value"===a.propertyName&&oe(le)){var b=[];ie(b,le,a,ub(a));Gb(me,b);}}
	function xe(a,b,c){"focusin"===a?(ve(),ke=b,le=c,ke.attachEvent("onpropertychange",we)):"focusout"===a&&ve();}function ye(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return oe(le)}function ze(a,b){if("click"===a)return oe(b)}function Ae(a,b){if("input"===a||"change"===a)return oe(b)}function Be(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var Ce="function"===typeof Object.is?Object.is:Be;
	function De(a,b){if(Ce(a,b))return !0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return !1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return !1;for(d=0;d<c.length;d++){var e=c[d];if(!ia.call(b,e)||!Ce(a[e],b[e]))return !1}return !0}function Ee(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
	function Fe(a,b){var c=Ee(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return {node:c,offset:b-a};a=d;}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode;}c=void 0;}c=Ee(c);}}function Ge(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Ge(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}
	function He(){for(var a=window,b=Va();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href;}catch(d){c=!1;}if(c)a=b.contentWindow;else break;b=Va(a.document);}return b}function Ie(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}
	function Je(a){var b=He(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Ge(c.ownerDocument.documentElement,c)){if(null!==d&&Ie(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Fe(c,f);var g=Fe(c,
	d);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)));}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});"function"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top;}}
	var Ke=ha&&"documentMode"in document&&11>=document.documentMode,Le=null,Me=null,Ne=null,Oe=!1;
	function Pe(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Oe||null==Le||Le!==Va(d)||(d=Le,"selectionStart"in d&&Ie(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Ne&&De(Ne,d)||(Ne=d,d=je(Me,"onSelect"),0<d.length&&(b=new od("onSelect","select",null,b,c),a.push({event:b,listeners:d}),b.target=Le)));}
	function Qe(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Re={animationend:Qe("Animation","AnimationEnd"),animationiteration:Qe("Animation","AnimationIteration"),animationstart:Qe("Animation","AnimationStart"),transitionend:Qe("Transition","TransitionEnd")},Se={},Te={};
	ha&&(Te=document.createElement("div").style,"AnimationEvent"in window||(delete Re.animationend.animation,delete Re.animationiteration.animation,delete Re.animationstart.animation),"TransitionEvent"in window||delete Re.transitionend.transition);function Ue(a){if(Se[a])return Se[a];if(!Re[a])return a;var b=Re[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Te)return Se[a]=b[c];return a}var Ve=Ue("animationend"),We=Ue("animationiteration"),Xe=Ue("animationstart"),Ye=Ue("transitionend"),Ze=new Map,$e="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
	function af(a,b){Ze.set(a,b);ea(b,[a]);}for(var bf=0;bf<$e.length;bf++){var cf=$e[bf],df=cf.toLowerCase(),ef=cf[0].toUpperCase()+cf.slice(1);af(df,"on"+ef);}af(Ve,"onAnimationEnd");af(We,"onAnimationIteration");af(Xe,"onAnimationStart");af("dblclick","onDoubleClick");af("focusin","onFocus");af("focusout","onBlur");af(Ye,"onTransitionEnd");fa("onMouseEnter",["mouseout","mouseover"]);fa("onMouseLeave",["mouseout","mouseover"]);fa("onPointerEnter",["pointerout","pointerover"]);
	fa("onPointerLeave",["pointerout","pointerover"]);ea("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));ea("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));ea("onBeforeInput",["compositionend","keypress","textInput","paste"]);ea("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));ea("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));
	ea("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var ff="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),gf=new Set("cancel close invalid load scroll toggle".split(" ").concat(ff));
	function hf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=c;Rb(d,b,void 0,a);a.currentTarget=null;}
	function ne(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;hf(e,h,l);f=k;}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;hf(e,h,l);f=k;}}}if(Nb)throw a=Ob,Nb=!1,Ob=null,a;}
	function F(a,b){var c=b[jf];void 0===c&&(c=b[jf]=new Set);var d=a+"__bubble";c.has(d)||(kf(b,a,2,!1),c.add(d));}function lf(a,b,c){var d=0;b&&(d|=4);kf(c,a,d,b);}var mf="_reactListening"+Math.random().toString(36).slice(2);function nf(a){if(!a[mf]){a[mf]=!0;ca.forEach(function(b){"selectionchange"!==b&&(gf.has(b)||lf(b,!1,a),lf(b,!0,a));});var b=9===a.nodeType?a:a.ownerDocument;null===b||b[mf]||(b[mf]=!0,lf("selectionchange",!1,b));}}
	function kf(a,b,c,d){switch(ed(b)){case 1:var e=$c;break;case 4:e=bd;break;default:e=ad;}c=e.bind(null,b,c,a);e=void 0;!Ib||"touchstart"!==b&&"touchmove"!==b&&"wheel"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1);}
	function cd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return;}for(;null!==h;){g=Sc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode;}}d=d.return;}Gb(function(){var d=f,e=ub(c),g=[];
	a:{var h=Ze.get(a);if(void 0!==h){var k=od,n=a;switch(a){case "keypress":if(0===jd(c))break a;case "keydown":case "keyup":k=Md;break;case "focusin":n="focus";k=Ad;break;case "focusout":n="blur";k=Ad;break;case "beforeblur":case "afterblur":k=Ad;break;case "click":if(2===c.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":k=wd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":k=
	yd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":k=Qd;break;case Ve:case We:case Xe:k=Cd;break;case Ye:k=Sd;break;case "scroll":k=qd;break;case "wheel":k=Ud;break;case "copy":case "cut":case "paste":k=Ed;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":k=Od;}var v=0!==(b&4),C=!v&&"scroll"===a,t=v?null!==h?h+"Capture":null:h;v=[];for(var r=d,x;null!==
	r;){x=r;var B=x.stateNode;5===x.tag&&null!==B&&(x=B,null!==t&&(B=Hb(r,t),null!=B&&v.push(of(r,B,x))));if(C)break;r=r.return;}0<v.length&&(h=new k(h,n,null,c,e),g.push({event:h,listeners:v}));}}if(0===(b&7)){a:{h="mouseover"===a||"pointerover"===a;k="mouseout"===a||"pointerout"===a;if(h&&c!==tb&&(n=c.relatedTarget||c.fromElement)&&(Sc(n)||n[pf]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(n=c.relatedTarget||c.toElement,k=d,n=n?Sc(n):null,null!==
	n&&(C=Sb(n),n!==C||5!==n.tag&&6!==n.tag))n=null;}else k=null,n=d;if(k!==n){v=wd;B="onMouseLeave";t="onMouseEnter";r="mouse";if("pointerout"===a||"pointerover"===a)v=Od,B="onPointerLeave",t="onPointerEnter",r="pointer";C=null==k?h:pe(k);x=null==n?h:pe(n);h=new v(B,r+"leave",k,c,e);h.target=C;h.relatedTarget=x;B=null;Sc(e)===d&&(v=new v(t,r+"enter",n,c,e),v.target=x,v.relatedTarget=C,B=v);C=B;if(k&&n)b:{v=k;t=n;r=0;for(x=v;x;x=qf(x))r++;x=0;for(B=t;B;B=qf(B))x++;for(;0<r-x;)v=qf(v),r--;for(;0<x-r;)t=
	qf(t),x--;for(;r--;){if(v===t||null!==t&&v===t.alternate)break b;v=qf(v);t=qf(t);}v=null;}else v=null;null!==k&&rf(g,h,k,v,!1);null!==n&&null!==C&&rf(g,C,n,v,!0);}}}a:{h=d?pe(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if("select"===k||"input"===k&&"file"===h.type)var O=qe;else if(he(h))if(re)O=Ae;else {O=ye;var T=xe;}else (k=h.nodeName)&&"input"===k.toLowerCase()&&("checkbox"===h.type||"radio"===h.type)&&(O=ze);if(O&&(O=O(a,d))){ie(g,O,c,e);break a}T&&T(a,h,d);"focusout"===a&&(T=h._wrapperState)&&
	T.controlled&&"number"===h.type&&$a(h,"number",h.value);}T=d?pe(d):window;switch(a){case "focusin":if(he(T)||"true"===T.contentEditable)Le=T,Me=d,Ne=null;break;case "focusout":Ne=Me=Le=null;break;case "mousedown":Oe=!0;break;case "contextmenu":case "mouseup":case "dragend":Oe=!1;Pe(g,c,e);break;case "selectionchange":if(Ke)break;case "keydown":case "keyup":Pe(g,c,e);}var za;if(Wd)b:{switch(a){case "compositionstart":var L="onCompositionStart";break b;case "compositionend":L="onCompositionEnd";break b;
	case "compositionupdate":L="onCompositionUpdate";break b}L=void 0;}else de?be(a,c)&&(L="onCompositionEnd"):"keydown"===a&&229===c.keyCode&&(L="onCompositionStart");L&&(Zd&&"ko"!==c.locale&&(de||"onCompositionStart"!==L?"onCompositionEnd"===L&&de&&(za=id()):(fd=e,gd="value"in fd?fd.value:fd.textContent,de=!0)),T=je(d,L),0<T.length&&(L=new Gd(L,a,null,c,e),g.push({event:L,listeners:T}),za?L.data=za:(za=ce(c),null!==za&&(L.data=za))));if(za=Yd?ee(a,c):fe(a,c))d=je(d,"onBeforeInput"),0<d.length&&(e=new Gd("onBeforeInput",
	"beforeinput",null,c,e),g.push({event:e,listeners:d}),e.data=za);}ne(g,b);});}function of(a,b,c){return {instance:a,listener:b,currentTarget:c}}function je(a,b){for(var c=b+"Capture",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Hb(a,c),null!=f&&d.unshift(of(a,f,e)),f=Hb(a,b),null!=f&&d.push(of(a,f,e)));a=a.return;}return d}function qf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}
	function rf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Hb(c,f),null!=k&&g.unshift(of(c,k,h))):e||(k=Hb(c,f),null!=k&&g.push(of(c,k,h))));c=c.return;}0!==g.length&&a.push({event:b,listeners:g});}var sf=/\r\n?/g,tf=/\u0000|\uFFFD/g;function uf(a){return ("string"===typeof a?a:""+a).replace(sf,"\n").replace(tf,"")}function vf(a,b,c){b=uf(b);if(uf(a)!==b&&c)throw Error(p(425));}function wf(){}
	var xf=null;function yf(a,b){return "textarea"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}
	var zf="function"===typeof setTimeout?setTimeout:void 0,Af="function"===typeof clearTimeout?clearTimeout:void 0,Bf="function"===typeof Promise?Promise:void 0,Df="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof Bf?function(a){return Bf.resolve(null).then(a).catch(Cf)}:zf;function Cf(a){setTimeout(function(){throw a;});}
	function Ef(a,b){var c=b,d=0;do{var e=c.nextSibling;a.removeChild(c);if(e&&8===e.nodeType)if(c=e.data,"/$"===c){if(0===d){a.removeChild(e);Yc(b);return}d--;}else "$"!==c&&"$?"!==c&&"$!"!==c||d++;c=e;}while(c);Yc(b);}function Ff(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break;if(8===b){b=a.data;if("$"===b||"$!"===b||"$?"===b)break;if("/$"===b)return null}}return a}
	function Gf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if("$"===c||"$!"===c||"$?"===c){if(0===b)return a;b--;}else "/$"===c&&b++;}a=a.previousSibling;}return null}var Hf=Math.random().toString(36).slice(2),If="__reactFiber$"+Hf,Jf="__reactProps$"+Hf,pf="__reactContainer$"+Hf,jf="__reactEvents$"+Hf,Kf="__reactListeners$"+Hf,Lf="__reactHandles$"+Hf;
	function Sc(a){var b=a[If];if(b)return b;for(var c=a.parentNode;c;){if(b=c[pf]||c[If]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Gf(a);null!==a;){if(c=a[If])return c;a=Gf(a);}return b}a=c;c=a.parentNode;}return null}function zb(a){a=a[If]||a[pf];return !a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function pe(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(p(33));}function Ab(a){return a[Jf]||null}var Mf=[],Nf=-1;function Of(a){return {current:a}}
	function G(a){0>Nf||(a.current=Mf[Nf],Mf[Nf]=null,Nf--);}function H(a,b){Nf++;Mf[Nf]=a.current;a.current=b;}var Pf={},I=Of(Pf),Qf=Of(!1),Rf=Pf;function Sf(a,b){var c=a.type.contextTypes;if(!c)return Pf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}
	function Tf(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Uf(){G(Qf);G(I);}function Vf(a,b,c){if(I.current!==Pf)throw Error(p(168));H(I,b);H(Qf,c);}function Wf(a,b,c){var d=a.stateNode;b=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(p(108,Pa(a)||"Unknown",e));return A({},c,d)}
	function Xf(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Pf;Rf=I.current;H(I,a);H(Qf,Qf.current);return !0}function Yf(a,b,c){var d=a.stateNode;if(!d)throw Error(p(169));c?(a=Wf(a,b,Rf),d.__reactInternalMemoizedMergedChildContext=a,G(Qf),G(I),H(I,a)):G(Qf);H(Qf,c);}var Zf=null,$f=!1,ag=!1;function bg(a){null===Zf?Zf=[a]:Zf.push(a);}function cg(a){$f=!0;bg(a);}
	function dg(){if(!ag&&null!==Zf){ag=!0;var a=0,b=E;try{var c=Zf;for(E=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}Zf=null;$f=!1;}catch(e){throw null!==Zf&&(Zf=Zf.slice(a+1)),Yb(cc,dg),e;}finally{E=b,ag=!1;}}return null}var eg=sa.ReactCurrentBatchConfig;function fg(a,b){if(a&&a.defaultProps){b=A({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}var gg=Of(null),hg=null,ig=null,jg=null;function kg(){jg=ig=hg=null;}
	function lg(a){var b=gg.current;G(gg);a._currentValue=b;}function mg(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return;}}function ng(a,b){hg=a;jg=ig=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(og=!0),a.firstContext=null);}
	function pg(a){var b=a._currentValue;if(jg!==a)if(a={context:a,memoizedValue:b,next:null},null===ig){if(null===hg)throw Error(p(308));ig=a;hg.dependencies={lanes:0,firstContext:a};}else ig=ig.next=a;return b}var qg=null,rg=!1;function sg(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null};}
	function tg(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects});}function ug(a,b){return {eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}
	function vg(a,b){var c=a.updateQueue;null!==c&&(c=c.shared,null!==J&&0!==(a.mode&1)&&0===(K&2)?(a=c.interleaved,null===a?(b.next=b,null===qg?qg=[c]:qg.push(c)):(b.next=a.next,a.next=b),c.interleaved=b):(a=c.pending,null===a?b.next=b:(b.next=a.next,a.next=b),c.pending=b));}function wg(a,b,c){b=b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;yc(a,c);}}
	function xg(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next;}while(null!==c);null===f?e=f=b:f=f.next=b;}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=
	b;c.lastBaseUpdate=b;}
	function yg(a,b,c,d){var e=a.updateQueue;rg=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var m=a.alternate;null!==m&&(m=m.updateQueue,h=m.lastBaseUpdate,h!==g&&(null===h?m.firstBaseUpdate=l:h.next=l,m.lastBaseUpdate=k));}if(null!==f){var w=e.baseState;g=0;m=l=k=null;h=f;do{var u=h.lane,y=h.eventTime;if((d&u)===u){null!==m&&(m=m.next={eventTime:y,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,
	next:null});a:{var n=a,v=h;u=b;y=c;switch(v.tag){case 1:n=v.payload;if("function"===typeof n){w=n.call(y,w,u);break a}w=n;break a;case 3:n.flags=n.flags&-65537|128;case 0:n=v.payload;u="function"===typeof n?n.call(y,w,u):n;if(null===u||void 0===u)break a;w=A({},w,u);break a;case 2:rg=!0;}}null!==h.callback&&0!==h.lane&&(a.flags|=64,u=e.effects,null===u?e.effects=[h]:u.push(h));}else y={eventTime:y,lane:u,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===m?(l=m=y,k=w):m=m.next=y,g|=u;
	h=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else u=h,h=u.next,u.next=null,e.lastBaseUpdate=u,e.shared.pending=null;}while(1);null===m&&(k=w);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=m;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);zg|=g;a.lanes=g;a.memoizedState=w;}}
	function Ag(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(p(191,e));e.call(d);}}}var Bg=(new aa.Component).refs;function Cg(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:A({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c);}
	var Fg={isMounted:function(a){return (a=a._reactInternals)?Sb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=M(),e=Dg(a),f=ug(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);vg(a,f);b=Eg(a,e,d);null!==b&&wg(b,a,e);},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=M(),e=Dg(a),f=ug(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);vg(a,f);b=Eg(a,e,d);null!==b&&wg(b,a,e);},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=M(),d=Dg(a),e=ug(c,
	d);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);vg(a,e);b=Eg(a,d,c);null!==b&&wg(b,a,d);}};function Gg(a,b,c,d,e,f,g){a=a.stateNode;return "function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!De(c,d)||!De(e,f):!0}
	function Hg(a,b,c){var d=!1,e=Pf;var f=b.contextType;"object"===typeof f&&null!==f?f=pg(f):(e=Tf(b)?Rf:I.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Sf(a,e):Pf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Fg;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
	function Ig(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Fg.enqueueReplaceState(b,b.state,null);}
	function Jg(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Bg;sg(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=pg(f):(f=Tf(b)?Rf:I.current,e.context=Sf(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Cg(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,
	"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Fg.enqueueReplaceState(e,e.state,null),yg(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4194308);}var Kg=[],Lg=0,Mg=null,Ng=0,Og=[],Pg=0,Qg=null,Rg=1,Sg="";function Tg(a,b){Kg[Lg++]=Ng;Kg[Lg++]=Mg;Mg=a;Ng=b;}
	function Ug(a,b,c){Og[Pg++]=Rg;Og[Pg++]=Sg;Og[Pg++]=Qg;Qg=a;var d=Rg;a=Sg;var e=32-lc(d)-1;d&=~(1<<e);c+=1;var f=32-lc(b)+e;if(30<f){var g=e-e%5;f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;Rg=1<<32-lc(b)+e|c<<e|d;Sg=f+a;}else Rg=1<<f|c<<e|d,Sg=a;}function Vg(a){null!==a.return&&(Tg(a,1),Ug(a,1,0));}function Wg(a){for(;a===Mg;)Mg=Kg[--Lg],Kg[Lg]=null,Ng=Kg[--Lg],Kg[Lg]=null;for(;a===Qg;)Qg=Og[--Pg],Og[Pg]=null,Sg=Og[--Pg],Og[Pg]=null,Rg=Og[--Pg],Og[Pg]=null;}var Xg=null,Yg=null,N=!1,Zg=null;
	function $g(a,b){var c=ah(5,null,null,0);c.elementType="DELETED";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c);}
	function bh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,Xg=a,Yg=Ff(b.firstChild),!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,Xg=a,Yg=null,!0):!1;case 13:return b=8!==b.nodeType?null:b,null!==b?(c=null!==Qg?{id:Rg,overflow:Sg}:null,a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824},c=ah(18,null,null,0),c.stateNode=b,c.return=a,a.child=c,Xg=a,Yg=
	null,!0):!1;default:return !1}}function ch(a){return 0!==(a.mode&1)&&0===(a.flags&128)}function dh(a){if(N){var b=Yg;if(b){var c=b;if(!bh(a,b)){if(ch(a))throw Error(p(418));b=Ff(c.nextSibling);var d=Xg;b&&bh(a,b)?$g(d,c):(a.flags=a.flags&-4097|2,N=!1,Xg=a);}}else {if(ch(a))throw Error(p(418));a.flags=a.flags&-4097|2;N=!1;Xg=a;}}}function eh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;Xg=a;}
	function fh(a){if(a!==Xg)return !1;if(!N)return eh(a),N=!0,!1;var b;(b=3!==a.tag)&&!(b=5!==a.tag)&&(b=a.type,b="head"!==b&&"body"!==b&&!yf(a.type,a.memoizedProps));if(b&&(b=Yg)){if(ch(a)){for(a=Yg;a;)a=Ff(a.nextSibling);throw Error(p(418));}for(;b;)$g(a,b),b=Ff(b.nextSibling);}eh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(p(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if("/$"===c){if(0===b){Yg=Ff(a.nextSibling);break a}b--;}else "$"!==c&&
	"$!"!==c&&"$?"!==c||b++;}a=a.nextSibling;}Yg=null;}}else Yg=Xg?Ff(a.stateNode.nextSibling):null;return !0}function gh(){Yg=Xg=null;N=!1;}function hh(a){null===Zg?Zg=[a]:Zg.push(a);}
	function ih(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(p(309));var d=c.stateNode;}if(!d)throw Error(p(147,a));var e=d,f=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;b===Bg&&(b=e.refs={});null===a?delete b[f]:b[f]=a;};b._stringRef=f;return b}if("string"!==typeof a)throw Error(p(284));if(!c._owner)throw Error(p(290,a));}return a}
	function jh(a,b){a=Object.prototype.toString.call(b);throw Error(p(31,"[object Object]"===a?"object with keys {"+Object.keys(b).join(", ")+"}":a));}function kh(a){var b=a._init;return b(a._payload)}
	function lh(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c);}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=mh(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&
	null===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=nh(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===va)return m(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||"object"===typeof f&&null!==f&&f.$$typeof===Fa&&kh(f)===b.type))return d=e(b,c.props),d.ref=ih(a,b,c),d.return=a,d;d=oh(c.type,c.key,c.props,null,a.mode,d);d.ref=ih(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||
	b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=ph(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=qh(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function w(a,b,c){if("string"===typeof b&&""!==b||"number"===typeof b)return b=nh(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case ta:return c=oh(b.type,b.key,b.props,null,a.mode,c),
	c.ref=ih(a,null,b),c.return=a,c;case ua:return b=ph(b,a.mode,c),b.return=a,b;case Fa:var d=b._init;return w(a,d(b._payload),c)}if(bb(b)||Ia(b))return b=qh(b,a.mode,c,null),b.return=a,b;jh(a,b);}return null}function u(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c&&""!==c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case ta:return c.key===e?k(a,b,c,d):null;case ua:return c.key===e?l(a,b,c,d):null;case Fa:return e=c._init,u(a,
	b,e(c._payload),d)}if(bb(c)||Ia(c))return null!==e?null:m(a,b,c,d,null);jh(a,c);}return null}function y(a,b,c,d,e){if("string"===typeof d&&""!==d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case ta:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e);case ua:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e);case Fa:var f=d._init;return y(a,b,c,f(d._payload),e)}if(bb(d)||Ia(d))return a=a.get(c)||null,m(b,a,d,e,null);jh(b,d);}return null}
	function n(e,g,h,k){for(var l=null,n=null,m=g,r=g=0,x=null;null!==m&&r<h.length;r++){m.index>r?(x=m,m=null):x=m.sibling;var t=u(e,m,h[r],k);if(null===t){null===m&&(m=x);break}a&&m&&null===t.alternate&&b(e,m);g=f(t,g,r);null===n?l=t:n.sibling=t;n=t;m=x;}if(r===h.length)return c(e,m),N&&Tg(e,r),l;if(null===m){for(;r<h.length;r++)m=w(e,h[r],k),null!==m&&(g=f(m,g,r),null===n?l=m:n.sibling=m,n=m);N&&Tg(e,r);return l}for(m=d(e,m);r<h.length;r++)x=y(m,e,r,h[r],k),null!==x&&(a&&null!==x.alternate&&m.delete(null===
	x.key?r:x.key),g=f(x,g,r),null===n?l=x:n.sibling=x,n=x);a&&m.forEach(function(a){return b(e,a)});N&&Tg(e,r);return l}function v(e,g,h,k){var l=Ia(h);if("function"!==typeof l)throw Error(p(150));h=l.call(h);if(null==h)throw Error(p(151));for(var m=l=null,n=g,r=g=0,x=null,t=h.next();null!==n&&!t.done;r++,t=h.next()){n.index>r?(x=n,n=null):x=n.sibling;var v=u(e,n,t.value,k);if(null===v){null===n&&(n=x);break}a&&n&&null===v.alternate&&b(e,n);g=f(v,g,r);null===m?l=v:m.sibling=v;m=v;n=x;}if(t.done)return c(e,
	n),N&&Tg(e,r),l;if(null===n){for(;!t.done;r++,t=h.next())t=w(e,t.value,k),null!==t&&(g=f(t,g,r),null===m?l=t:m.sibling=t,m=t);N&&Tg(e,r);return l}for(n=d(e,n);!t.done;r++,t=h.next())t=y(n,e,r,t.value,k),null!==t&&(a&&null!==t.alternate&&n.delete(null===t.key?r:t.key),g=f(t,g,r),null===m?l=t:m.sibling=t,m=t);a&&n.forEach(function(a){return b(e,a)});N&&Tg(e,r);return l}function C(a,d,f,h){"object"===typeof f&&null!==f&&f.type===va&&null===f.key&&(f=f.props.children);if("object"===typeof f&&null!==f){switch(f.$$typeof){case ta:a:{for(var k=
	f.key,l=d;null!==l;){if(l.key===k){k=f.type;if(k===va){if(7===l.tag){c(a,l.sibling);d=e(l,f.props.children);d.return=a;a=d;break a}}else if(l.elementType===k||"object"===typeof k&&null!==k&&k.$$typeof===Fa&&kh(k)===l.type){c(a,l.sibling);d=e(l,f.props);d.ref=ih(a,l,f);d.return=a;a=d;break a}c(a,l);break}else b(a,l);l=l.sibling;}f.type===va?(d=qh(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=oh(f.type,f.key,f.props,null,a.mode,h),h.ref=ih(a,d,f),h.return=a,a=h);}return g(a);case ua:a:{for(l=f.key;null!==
	d;){if(d.key===l)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else {c(a,d);break}else b(a,d);d=d.sibling;}d=ph(f,a.mode,h);d.return=a;a=d;}return g(a);case Fa:return l=f._init,C(a,d,l(f._payload),h)}if(bb(f))return n(a,d,f,h);if(Ia(f))return v(a,d,f,h);jh(a,f);}return "string"===typeof f&&""!==f||"number"===typeof f?(f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):
	(c(a,d),d=nh(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return C}var rh=lh(!0),sh=lh(!1),th={},uh=Of(th),vh=Of(th),wh=Of(th);function xh(a){if(a===th)throw Error(p(174));return a}function yh(a,b){H(wh,b);H(vh,a);H(uh,th);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:ib(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=ib(b,a);}G(uh);H(uh,b);}function zh(){G(uh);G(vh);G(wh);}
	function Ah(a){xh(wh.current);var b=xh(uh.current);var c=ib(b,a.type);b!==c&&(H(vh,a),H(uh,c));}function Bh(a){vh.current===a&&(G(uh),G(vh));}var P=Of(0);
	function Ch(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||"$?"===c.data||"$!"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return;}b.sibling.return=b.return;b=b.sibling;}return null}var Dh=[];
	function Eh(){for(var a=0;a<Dh.length;a++)Dh[a]._workInProgressVersionPrimary=null;Dh.length=0;}var Fh=sa.ReactCurrentDispatcher,Gh=sa.ReactCurrentBatchConfig,Hh=0,Q=null,R$6=null,S=null,Ih=!1,Jh=!1,Kh=0,Lh=0;function U(){throw Error(p(321));}function Mh(a,b){if(null===b)return !1;for(var c=0;c<b.length&&c<a.length;c++)if(!Ce(a[c],b[c]))return !1;return !0}
	function Nh(a,b,c,d,e,f){Hh=f;Q=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;Fh.current=null===a||null===a.memoizedState?Oh:Ph;a=c(d,e);if(Jh){f=0;do{Jh=!1;Kh=0;if(25<=f)throw Error(p(301));f+=1;S=R$6=null;b.updateQueue=null;Fh.current=Qh;a=c(d,e);}while(Jh)}Fh.current=Rh;b=null!==R$6&&null!==R$6.next;Hh=0;S=R$6=Q=null;Ih=!1;if(b)throw Error(p(300));return a}function Sh(){var a=0!==Kh;Kh=0;return a}
	function Th(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===S?Q.memoizedState=S=a:S=S.next=a;return S}function Uh(){if(null===R$6){var a=Q.alternate;a=null!==a?a.memoizedState:null;}else a=R$6.next;var b=null===S?Q.memoizedState:S.next;if(null!==b)S=b,R$6=a;else {if(null===a)throw Error(p(310));R$6=a;a={memoizedState:R$6.memoizedState,baseState:R$6.baseState,baseQueue:R$6.baseQueue,queue:R$6.queue,next:null};null===S?Q.memoizedState=S=a:S=S.next=a;}return S}
	function Vh(a,b){return "function"===typeof b?b(a):b}
	function Wh(a){var b=Uh(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=R$6,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g;}d.baseQueue=e=f;c.pending=null;}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,l=f;do{var m=l.lane;if((Hh&m)===m)null!==k&&(k=k.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d=l.hasEagerState?l.eagerState:a(d,l.action);else {var w={lane:m,action:l.action,hasEagerState:l.hasEagerState,
	eagerState:l.eagerState,next:null};null===k?(h=k=w,g=d):k=k.next=w;Q.lanes|=m;zg|=m;}l=l.next;}while(null!==l&&l!==f);null===k?g=d:k.next=h;Ce(d,b.memoizedState)||(og=!0);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d;}a=c.interleaved;if(null!==a){e=a;do f=e.lane,Q.lanes|=f,zg|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return [b.memoizedState,c.dispatch]}
	function Xh(a){var b=Uh(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Ce(f,b.memoizedState)||(og=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f;}return [f,d]}function Yh(){}
	function Zh(a,b){var c=Q,d=Uh(),e=b(),f=!Ce(d.memoizedState,e);f&&(d.memoizedState=e,og=!0);d=d.queue;$h(ai.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==S&&S.memoizedState.tag&1){c.flags|=2048;bi(9,ci.bind(null,c,d,e,b),void 0,null);if(null===J)throw Error(p(349));0!==(Hh&30)||di(c,b,e);}return e}function di(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=Q.updateQueue;null===b?(b={lastEffect:null,stores:null},Q.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a));}
	function ci(a,b,c,d){b.value=c;b.getSnapshot=d;ei(b)&&Eg(a,1,-1);}function ai(a,b,c){return c(function(){ei(b)&&Eg(a,1,-1);})}function ei(a){var b=a.getSnapshot;a=a.value;try{var c=b();return !Ce(a,c)}catch(d){return !0}}function fi(a){var b=Th();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vh,lastRenderedState:a};b.queue=a;a=a.dispatch=gi.bind(null,Q,a);return [b.memoizedState,a]}
	function bi(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=Q.updateQueue;null===b?(b={lastEffect:null,stores:null},Q.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function hi(){return Uh().memoizedState}function ii(a,b,c,d){var e=Th();Q.flags|=a;e.memoizedState=bi(1|b,c,void 0,void 0===d?null:d);}
	function ji(a,b,c,d){var e=Uh();d=void 0===d?null:d;var f=void 0;if(null!==R$6){var g=R$6.memoizedState;f=g.destroy;if(null!==d&&Mh(d,g.deps)){e.memoizedState=bi(b,c,f,d);return}}Q.flags|=a;e.memoizedState=bi(1|b,c,f,d);}function ki(a,b){return ii(8390656,8,a,b)}function $h(a,b){return ji(2048,8,a,b)}function li(a,b){return ji(4,2,a,b)}function mi(a,b){return ji(4,4,a,b)}
	function ni(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null);};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null;}}function oi(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ji(4,4,ni.bind(null,b,a),c)}function pi(){}function qi(a,b){var c=Uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Mh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}
	function ri(a,b){var c=Uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Mh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function si(a,b){var c=E;E=0!==c&&4>c?c:4;a(!0);var d=Gh.transition;Gh.transition={};try{a(!1),b();}finally{E=c,Gh.transition=d;}}function ti(){return Uh().memoizedState}function ui(a,b,c){var d=Dg(a);c={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};vi(a)?wi(b,c):(xi(a,b,c),c=M(),a=Eg(a,d,c),null!==a&&yi(a,b,d));}
	function gi(a,b,c){var d=Dg(a),e={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(vi(a))wi(b,e);else {xi(a,b,e);var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(Ce(h,g))return}catch(k){}finally{}c=M();a=Eg(a,d,c);null!==a&&yi(a,b,d);}}function vi(a){var b=a.alternate;return a===Q||null!==b&&b===Q}
	function wi(a,b){Jh=Ih=!0;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b;}function xi(a,b,c){null!==J&&0!==(a.mode&1)&&0===(K&2)?(a=b.interleaved,null===a?(c.next=c,null===qg?qg=[b]:qg.push(b)):(c.next=a.next,a.next=c),b.interleaved=c):(a=b.pending,null===a?c.next=c:(c.next=a.next,a.next=c),b.pending=c);}function yi(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;yc(a,c);}}
	var Rh={readContext:pg,useCallback:U,useContext:U,useEffect:U,useImperativeHandle:U,useInsertionEffect:U,useLayoutEffect:U,useMemo:U,useReducer:U,useRef:U,useState:U,useDebugValue:U,useDeferredValue:U,useTransition:U,useMutableSource:U,useSyncExternalStore:U,useId:U,unstable_isNewReconciler:!1},Oh={readContext:pg,useCallback:function(a,b){Th().memoizedState=[a,void 0===b?null:b];return a},useContext:pg,useEffect:ki,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ii(4194308,
	4,ni.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ii(4194308,4,a,b)},useInsertionEffect:function(a,b){return ii(4,2,a,b)},useMemo:function(a,b){var c=Th();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=Th();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=ui.bind(null,Q,a);return [d.memoizedState,a]},useRef:function(a){var b=
	Th();a={current:a};return b.memoizedState=a},useState:fi,useDebugValue:pi,useDeferredValue:function(a){var b=fi(a),c=b[0],d=b[1];ki(function(){var b=Gh.transition;Gh.transition={};try{d(a);}finally{Gh.transition=b;}},[a]);return c},useTransition:function(){var a=fi(!1),b=a[0];a=si.bind(null,a[1]);Th().memoizedState=a;return [b,a]},useMutableSource:function(){},useSyncExternalStore:function(a,b,c){var d=Q,e=Th();if(N){if(void 0===c)throw Error(p(407));c=c();}else {c=b();if(null===J)throw Error(p(349));
	0!==(Hh&30)||di(d,b,c);}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;ki(ai.bind(null,d,f,a),[a]);d.flags|=2048;bi(9,ci.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=Th(),b=J.identifierPrefix;if(N){var c=Sg;var d=Rg;c=(d&~(1<<32-lc(d)-1)).toString(32)+c;b=":"+b+"R"+c;c=Kh++;0<c&&(b+="H"+c.toString(32));b+=":";}else c=Lh++,b=":"+b+"r"+c.toString(32)+":";return a.memoizedState=b},unstable_isNewReconciler:!1},Ph={readContext:pg,useCallback:qi,useContext:pg,useEffect:$h,useImperativeHandle:oi,
	useInsertionEffect:li,useLayoutEffect:mi,useMemo:ri,useReducer:Wh,useRef:hi,useState:function(){return Wh(Vh)},useDebugValue:pi,useDeferredValue:function(a){var b=Wh(Vh),c=b[0],d=b[1];$h(function(){var b=Gh.transition;Gh.transition={};try{d(a);}finally{Gh.transition=b;}},[a]);return c},useTransition:function(){var a=Wh(Vh)[0],b=Uh().memoizedState;return [a,b]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:ti,unstable_isNewReconciler:!1},Qh={readContext:pg,useCallback:qi,useContext:pg,useEffect:$h,
	useImperativeHandle:oi,useInsertionEffect:li,useLayoutEffect:mi,useMemo:ri,useReducer:Xh,useRef:hi,useState:function(){return Xh(Vh)},useDebugValue:pi,useDeferredValue:function(a){var b=Xh(Vh),c=b[0],d=b[1];$h(function(){var b=Gh.transition;Gh.transition={};try{d(a);}finally{Gh.transition=b;}},[a]);return c},useTransition:function(){var a=Xh(Vh)[0],b=Uh().memoizedState;return [a,b]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:ti,unstable_isNewReconciler:!1};
	function zi(a,b){try{var c="",d=b;do c+=Na(d),d=d.return;while(d);var e=c;}catch(f){e="\nError generating stack: "+f.message+"\n"+f.stack;}return {value:a,source:b,stack:e}}function Ai(a,b){try{console.error(b.value);}catch(c){setTimeout(function(){throw c;});}}var Bi="function"===typeof WeakMap?WeakMap:Map;function Ci(a,b,c){c=ug(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Di||(Di=!0,Ei=d);Ai(a,b);};return c}
	function Fi(a,b,c){c=ug(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){return d(e)};c.callback=function(){Ai(a,b);};}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){Ai(a,b);"function"!==typeof d&&(null===Gi?Gi=new Set([this]):Gi.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""});});return c}
	function Hi(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new Bi;var e=new Set;d.set(b,e);}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=Ii.bind(null,a,b,c),b.then(a,a));}function Ji(a){do{var b;if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?!0:!1:!0;if(b)return a;a=a.return;}while(null!==a);return null}
	function Ki(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=ug(-1,1),b.tag=2,vg(c,b))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}var Li,Mi,Ni,Oi;
	Li=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return;}c.sibling.return=c.return;c=c.sibling;}};Mi=function(){};
	Ni=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;xh(uh.current);var f=null;switch(c){case "input":e=Wa(a,e);d=Wa(a,d);f=[];break;case "select":e=A({},e,{value:void 0});d=A({},d,{value:void 0});f=[];break;case "textarea":e=db(a,e);d=db(a,d);f=[];break;default:"function"!==typeof e.onClick&&"function"===typeof d.onClick&&(a.onclick=wf);}rb(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if("style"===l){var h=e[l];for(g in h)h.hasOwnProperty(g)&&
	(c||(c={}),c[g]="");}else "dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(da.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if("style"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]="");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||(c={}),c[g]=k[g]);}else c||(f||(f=[]),f.push(l,
	c)),c=k;else "dangerouslySetInnerHTML"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):"children"===l?"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(l,""+k):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&(da.hasOwnProperty(l)?(null!=k&&"onScroll"===l&&F("scroll",a),f||h===k||(f=[])):(f=f||[]).push(l,k));}c&&(f=f||[]).push("style",c);var l=f;if(b.updateQueue=l)b.flags|=4;}};Oi=function(a,b,c,d){c!==d&&(b.flags|=4);};
	function Pi(a,b){if(!N)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null;}}
	function V(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}
	function Qi(a,b,c){var d=b.pendingProps;Wg(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return V(b),null;case 1:return Tf(b.type)&&Uf(),V(b),null;case 3:d=b.stateNode;zh();G(Qf);G(I);Eh();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)fh(b)?b.flags|=4:null===a||a.memoizedState.isDehydrated&&0===(b.flags&256)||(b.flags|=1024,null!==Zg&&(Ri(Zg),Zg=null));Mi(a,b);V(b);return null;case 5:Bh(b);var e=xh(wh.current);
	c=b.type;if(null!==a&&null!=b.stateNode)Ni(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else {if(!d){if(null===b.stateNode)throw Error(p(166));V(b);return null}a=xh(uh.current);if(fh(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[If]=b;d[Jf]=f;a=0!==(b.mode&1);switch(c){case "dialog":F("cancel",d);F("close",d);break;case "iframe":case "object":case "embed":F("load",d);break;case "video":case "audio":for(e=0;e<ff.length;e++)F(ff[e],d);break;case "source":F("error",d);break;case "img":case "image":case "link":F("error",
	d);F("load",d);break;case "details":F("toggle",d);break;case "input":Xa(d,f);F("invalid",d);break;case "select":d._wrapperState={wasMultiple:!!f.multiple};F("invalid",d);break;case "textarea":eb(d,f),F("invalid",d);}rb(c,f);e=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(vf(d.textContent,h,a),e=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(vf(d.textContent,h,a),e=["children",""+h]):da.hasOwnProperty(g)&&null!=h&&"onScroll"===
	g&&F("scroll",d);}switch(c){case "input":Ta(d);ab(d,f,!0);break;case "textarea":Ta(d);gb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=wf);}d=e;b.updateQueue=d;null!==d&&(b.flags|=4);}else {g=9===e.nodeType?e:e.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=hb(c));"http://www.w3.org/1999/xhtml"===a?"script"===c?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(c,{is:d.is}):
	(a=g.createElement(c),"select"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[If]=b;a[Jf]=d;Li(a,b,!1,!1);b.stateNode=a;a:{g=sb(c,d);switch(c){case "dialog":F("cancel",a);F("close",a);e=d;break;case "iframe":case "object":case "embed":F("load",a);e=d;break;case "video":case "audio":for(e=0;e<ff.length;e++)F(ff[e],a);e=d;break;case "source":F("error",a);e=d;break;case "img":case "image":case "link":F("error",a);F("load",a);e=d;break;case "details":F("toggle",
	a);e=d;break;case "input":Xa(a,d);e=Wa(a,d);F("invalid",a);break;case "option":e=d;break;case "select":a._wrapperState={wasMultiple:!!d.multiple};e=A({},d,{value:void 0});F("invalid",a);break;case "textarea":eb(a,d);e=db(a,d);F("invalid",a);break;default:e=d;}rb(c,e);h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];"style"===f?pb(a,k):"dangerouslySetInnerHTML"===f?(k=k?k.__html:void 0,null!=k&&kb(a,k)):"children"===f?"string"===typeof k?("textarea"!==c||""!==k)&&lb(a,k):"number"===typeof k&&lb(a,
	""+k):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(da.hasOwnProperty(f)?null!=k&&"onScroll"===f&&F("scroll",a):null!=k&&ra(a,f,k,g));}switch(c){case "input":Ta(a);ab(a,d,!1);break;case "textarea":Ta(a);gb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+Qa(d.value));break;case "select":a.multiple=!!d.multiple;f=d.value;null!=f?cb(a,!!d.multiple,f,!1):null!=d.defaultValue&&cb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof e.onClick&&
	(a.onclick=wf);}switch(c){case "button":case "input":case "select":case "textarea":d=!!d.autoFocus;break a;case "img":d=!0;break a;default:d=!1;}}d&&(b.flags|=4);}null!==b.ref&&(b.flags|=512,b.flags|=2097152);}V(b);return null;case 6:if(a&&null!=b.stateNode)Oi(a,b,a.memoizedProps,d);else {if("string"!==typeof d&&null===b.stateNode)throw Error(p(166));c=xh(wh.current);xh(uh.current);if(fh(b)){d=b.stateNode;c=b.memoizedProps;d[If]=b;if(f=d.nodeValue!==c)if(a=Xg,null!==a)switch(g=0!==(a.mode&1),a.tag){case 3:vf(d.nodeValue,
	c,g);break;case 5:!0!==a.memoizedProps[void 0]&&vf(d.nodeValue,c,g);}f&&(b.flags|=4);}else d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[If]=b,b.stateNode=d;}V(b);return null;case 13:G(P);d=b.memoizedState;if(N&&null!==Yg&&0!==(b.mode&1)&&0===(b.flags&128)){for(d=Yg;d;)d=Ff(d.nextSibling);gh();b.flags|=98560;return b}if(null!==d&&null!==d.dehydrated){d=fh(b);if(null===a){if(!d)throw Error(p(318));d=b.memoizedState;d=null!==d?d.dehydrated:null;if(!d)throw Error(p(317));d[If]=b;}else gh(),0===
	(b.flags&128)&&(b.memoizedState=null),b.flags|=4;V(b);return null}null!==Zg&&(Ri(Zg),Zg=null);if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;c=!1;null===a?fh(b):c=null!==a.memoizedState;d&&!c&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(P.current&1)?0===W&&(W=3):Si()));null!==b.updateQueue&&(b.flags|=4);V(b);return null;case 4:return zh(),Mi(a,b),null===a&&nf(b.stateNode.containerInfo),V(b),null;case 10:return lg(b.type._context),V(b),null;case 17:return Tf(b.type)&&Uf(),V(b),null;case 19:G(P);
	f=b.memoizedState;if(null===f)return V(b),null;d=0!==(b.flags&128);g=f.rendering;if(null===g)if(d)Pi(f,!1);else {if(0!==W||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){g=Ch(a);if(null!==g){b.flags|=128;Pi(f,!1);d=g.updateQueue;null!==d&&(b.updateQueue=d,b.flags|=4);b.subtreeFlags=0;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=14680066,g=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,
	f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;H(P,P.current&1|2);return b.child}a=a.sibling;}null!==f.tail&&D()>Ti&&(b.flags|=128,d=!0,Pi(f,!1),b.lanes=4194304);}else {if(!d)if(a=Ch(g),null!==a){if(b.flags|=128,d=!0,c=a.updateQueue,
	null!==c&&(b.updateQueue=c,b.flags|=4),Pi(f,!0),null===f.tail&&"hidden"===f.tailMode&&!g.alternate&&!N)return V(b),null}else 2*D()-f.renderingStartTime>Ti&&1073741824!==c&&(b.flags|=128,d=!0,Pi(f,!1),b.lanes=4194304);f.isBackwards?(g.sibling=b.child,b.child=g):(c=f.last,null!==c?c.sibling=g:b.child=g,f.last=g);}if(null!==f.tail)return b=f.tail,f.rendering=b,f.tail=b.sibling,f.renderingStartTime=D(),b.sibling=null,c=P.current,H(P,d?c&1|2:c&1),b;V(b);return null;case 22:case 23:return Ui(),d=null!==
	b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==(Vi&1073741824)&&(V(b),b.subtreeFlags&6&&(b.flags|=8192)):V(b),null;case 24:return null;case 25:return null}throw Error(p(156,b.tag));}var Wi=sa.ReactCurrentOwner,og=!1;function Xi(a,b,c,d){b.child=null===a?sh(b,null,c,d):rh(b,a.child,c,d);}
	function Yi(a,b,c,d,e){c=c.render;var f=b.ref;ng(b,e);d=Nh(a,b,c,d,f,e);c=Sh();if(null!==a&&!og)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Zi(a,b,e);N&&c&&Vg(b);b.flags|=1;Xi(a,b,d,e);return b.child}
	function $i(a,b,c,d,e){if(null===a){var f=c.type;if("function"===typeof f&&!aj(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,bj(a,b,f,d,e);a=oh(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:De;if(c(g,d)&&a.ref===b.ref)return Zi(a,b,e)}b.flags|=1;a=mh(f,d);a.ref=b.ref;a.return=b;return b.child=a}
	function bj(a,b,c,d,e){if(null!==a&&De(a.memoizedProps,d)&&a.ref===b.ref)if(og=!1,0!==(a.lanes&e))0!==(a.flags&131072)&&(og=!0);else return b.lanes=a.lanes,Zi(a,b,e);return cj(a,b,c,d,e)}
	function dj(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null},H(ej,Vi),Vi|=c;else if(0!==(c&1073741824))b.memoizedState={baseLanes:0,cachePool:null},d=null!==f?f.baseLanes:c,H(ej,Vi),Vi|=d;else return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null},b.updateQueue=null,H(ej,Vi),Vi|=a,null;else null!==f?(d=f.baseLanes|c,b.memoizedState=null):
	d=c,H(ej,Vi),Vi|=d;Xi(a,b,e,c);return b.child}function fj(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152;}function cj(a,b,c,d,e){var f=Tf(c)?Rf:I.current;f=Sf(b,f);ng(b,e);c=Nh(a,b,c,d,f,e);d=Sh();if(null!==a&&!og)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Zi(a,b,e);N&&d&&Vg(b);b.flags|=1;Xi(a,b,c,e);return b.child}
	function gj(a,b,c,d,e){if(Tf(c)){var f=!0;Xf(b);}else f=!1;ng(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),Hg(b,c,d),Jg(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=pg(l):(l=Tf(c)?Rf:I.current,l=Sf(b,l));var m=c.getDerivedStateFromProps,w="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;w||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&
	"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Ig(b,g,d,l);rg=!1;var u=b.memoizedState;g.state=u;yg(b,d,g,e);k=b.memoizedState;h!==d||u!==k||Qf.current||rg?("function"===typeof m&&(Cg(b,c,m,d),k=b.memoizedState),(h=rg||Gg(b,c,h,d,u,k,l))?(w||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===
	typeof g.componentDidMount&&(b.flags|=4194308)):("function"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4194308),d=!1);}else {g=b.stateNode;tg(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:fg(b.type,h);g.props=l;w=b.pendingProps;u=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=pg(k):(k=Tf(c)?Rf:I.current,k=Sf(b,k));var y=c.getDerivedStateFromProps;(m="function"===
	typeof y||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==w||u!==k)&&Ig(b,g,d,k);rg=!1;u=b.memoizedState;g.state=u;yg(b,d,g,e);var n=b.memoizedState;h!==w||u!==n||Qf.current||rg?("function"===typeof y&&(Cg(b,c,y,d),n=b.memoizedState),(l=rg||Gg(b,c,l,d,u,n,k)||!1)?(m||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&
	g.componentWillUpdate(d,n,k),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,n,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&u===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&u===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=n),g.props=d,g.state=n,g.context=
	k,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&u===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&u===a.memoizedState||(b.flags|=1024),d=!1);}return hj(a,b,c,d,f,e)}
	function hj(a,b,c,d,e,f){fj(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&Yf(b,c,!1),Zi(a,b,f);d=b.stateNode;Wi.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=rh(b,a.child,null,f),b.child=rh(b,null,h,f)):Xi(a,b,h,f);b.memoizedState=d.state;e&&Yf(b,c,!0);return b.child}function ij(a){var b=a.stateNode;b.pendingContext?Vf(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Vf(a,b.context,!1);yh(a,b.containerInfo);}
	function jj(a,b,c,d,e){gh();hh(e);b.flags|=256;Xi(a,b,c,d);return b.child}var kj={dehydrated:null,treeContext:null,retryLane:0};function lj(a){return {baseLanes:a,cachePool:null}}
	function mj(a,b,c){var d=b.pendingProps,e=P.current,f=!1,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?!1:0!==(e&2));if(h)f=!0,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;H(P,e&1);if(null===a){dh(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:"$!"===a.data?b.lanes=8:b.lanes=1073741824,null;e=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,e={mode:"hidden",children:e},0===(d&1)&&null!==f?(f.childLanes=0,f.pendingProps=
	e):f=nj(e,d,0,null),a=qh(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=lj(c),b.memoizedState=kj,a):oj(b,e)}e=a.memoizedState;if(null!==e){h=e.dehydrated;if(null!==h){if(g){if(b.flags&256)return b.flags&=-257,pj(a,b,c,Error(p(422)));if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=nj({mode:"visible",children:d.children},e,0,null);f=qh(f,e,c,null);f.flags|=2;d.return=b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&rh(b,a.child,
	null,c);b.child.memoizedState=lj(c);b.memoizedState=kj;return f}if(0===(b.mode&1))b=pj(a,b,c,null);else if("$!"===h.data)b=pj(a,b,c,Error(p(419)));else if(d=0!==(c&a.childLanes),og||d){d=J;if(null!==d){switch(c&-c){case 4:f=2;break;case 16:f=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:f=32;break;case 536870912:f=
	268435456;break;default:f=0;}d=0!==(f&(d.suspendedLanes|c))?0:f;0!==d&&d!==e.retryLane&&(e.retryLane=d,Eg(a,d,-1));}Si();b=pj(a,b,c,Error(p(421)));}else "$?"===h.data?(b.flags|=128,b.child=a.child,b=qj.bind(null,a),h._reactRetry=b,b=null):(c=e.treeContext,Yg=Ff(h.nextSibling),Xg=b,N=!0,Zg=null,null!==c&&(Og[Pg++]=Rg,Og[Pg++]=Sg,Og[Pg++]=Qg,Rg=c.id,Sg=c.overflow,Qg=b),b=oj(b,b.pendingProps.children),b.flags|=4096);return b}if(f)return d=rj(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,
	f.memoizedState=null===e?lj(c):{baseLanes:e.baseLanes|c,cachePool:null},f.childLanes=a.childLanes&~c,b.memoizedState=kj,d;c=sj(a,b,d.children,c);b.memoizedState=null;return c}if(f)return d=rj(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,f.memoizedState=null===e?lj(c):{baseLanes:e.baseLanes|c,cachePool:null},f.childLanes=a.childLanes&~c,b.memoizedState=kj,d;c=sj(a,b,d.children,c);b.memoizedState=null;return c}
	function oj(a,b){b=nj({mode:"visible",children:b},a.mode,0,null);b.return=a;return a.child=b}function sj(a,b,c,d){var e=a.child;a=e.sibling;c=mh(e,{mode:"visible",children:c});0===(b.mode&1)&&(c.lanes=d);c.return=b;c.sibling=null;null!==a&&(d=b.deletions,null===d?(b.deletions=[a],b.flags|=16):d.push(a));return b.child=c}
	function rj(a,b,c,d,e){var f=b.mode;a=a.child;var g=a.sibling,h={mode:"hidden",children:c};0===(f&1)&&b.child!==a?(c=b.child,c.childLanes=0,c.pendingProps=h,b.deletions=null):(c=mh(a,h),c.subtreeFlags=a.subtreeFlags&14680064);null!==g?d=mh(g,d):(d=qh(d,f,e,null),d.flags|=2);d.return=b;c.return=b;c.sibling=d;b.child=c;return d}function pj(a,b,c,d){null!==d&&hh(d);rh(b,a.child,null,c);a=oj(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}
	function tj(a,b,c){a.lanes|=b;var d=a.alternate;null!==d&&(d.lanes|=b);mg(a.return,b,c);}function uj(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e);}
	function vj(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Xi(a,b,d.children,c);d=P.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else {if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&tj(a,c,b);else if(19===a.tag)tj(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return;}a.sibling.return=a.return;a=a.sibling;}d&=1;}H(P,d);if(0===(b.mode&1))b.memoizedState=
	null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Ch(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);uj(b,!1,e,c,f);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Ch(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a;}uj(b,!0,c,null,f);break;case "together":uj(b,!1,null,null,void 0);break;default:b.memoizedState=null;}return b.child}
	function Zi(a,b,c){null!==a&&(b.dependencies=a.dependencies);zg|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(p(153));if(null!==b.child){a=b.child;c=mh(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=mh(a,a.pendingProps),c.return=b;c.sibling=null;}return b.child}
	function wj(a,b,c){switch(b.tag){case 3:ij(b);gh();break;case 5:Ah(b);break;case 1:Tf(b.type)&&Xf(b);break;case 4:yh(b,b.stateNode.containerInfo);break;case 10:var d=b.type._context,e=b.memoizedProps.value;H(gg,d._currentValue);d._currentValue=e;break;case 13:d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return H(P,P.current&1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return mj(a,b,c);H(P,P.current&1);a=Zi(a,b,c);return null!==a?a.sibling:null}H(P,P.current&1);break;case 19:d=0!==(c&
	b.childLanes);if(0!==(a.flags&128)){if(d)return vj(a,b,c);b.flags|=128;}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);H(P,P.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,dj(a,b,c)}return Zi(a,b,c)}
	function xj(a,b){Wg(b);switch(b.tag){case 1:return Tf(b.type)&&Uf(),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return zh(),G(Qf),G(I),Eh(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return Bh(b),null;case 13:G(P);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(p(340));gh();}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return G(P),null;case 4:return zh(),null;case 10:return lg(b.type._context),null;case 22:case 23:return Ui(),
	null;case 24:return null;default:return null}}var yj=!1,zj=!1,Aj="function"===typeof WeakSet?WeakSet:Set,X=null;function Bj(a,b){var c=a.ref;if(null!==c)if("function"===typeof c)try{c(null);}catch(d){Cj(a,b,d);}else c.current=null;}function Dj(a,b,c){try{c();}catch(d){Cj(a,b,d);}}var Ej=!1;
	function Fj(a,b){a=He();if(Ie(a)){if("selectionStart"in a)var c={start:a.selectionStart,end:a.selectionEnd};else a:{c=(c=a.ownerDocument)&&c.defaultView||window;var d=c.getSelection&&c.getSelection();if(d&&0!==d.rangeCount){c=d.anchorNode;var e=d.anchorOffset,f=d.focusNode;d=d.focusOffset;try{c.nodeType,f.nodeType;}catch(O){c=null;break a}var g=0,h=-1,k=-1,l=0,m=0,w=a,u=null;b:for(;;){for(var y;;){w!==c||0!==e&&3!==w.nodeType||(h=g+e);w!==f||0!==d&&3!==w.nodeType||(k=g+d);3===w.nodeType&&(g+=w.nodeValue.length);
	if(null===(y=w.firstChild))break;u=w;w=y;}for(;;){if(w===a)break b;u===c&&++l===e&&(h=g);u===f&&++m===d&&(k=g);if(null!==(y=w.nextSibling))break;w=u;u=w.parentNode;}w=y;}c=-1===h||-1===k?null:{start:h,end:k};}else c=null;}c=c||{start:0,end:0};}else c=null;xf={focusedElem:a,selectionRange:c};for(X=b;null!==X;)if(b=X,a=b.child,0!==(b.subtreeFlags&1028)&&null!==a)a.return=b,X=a;else for(;null!==X;){b=X;try{var n=b.alternate;if(0!==(b.flags&1024))switch(b.tag){case 0:case 11:case 15:break;case 1:if(null!==
	n){var v=n.memoizedProps,C=n.memoizedState,t=b.stateNode,r=t.getSnapshotBeforeUpdate(b.elementType===b.type?v:fg(b.type,v),C);t.__reactInternalSnapshotBeforeUpdate=r;}break;case 3:var x=b.stateNode.containerInfo;if(1===x.nodeType)x.textContent="";else if(9===x.nodeType){var B=x.body;null!=B&&(B.textContent="");}break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163));}}catch(O){Cj(b,b.return,O);}a=b.sibling;if(null!==a){a.return=b.return;X=a;break}X=b.return;}n=Ej;Ej=!1;return n}
	function Gj(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&Dj(b,c,f);}e=e.next;}while(e!==d)}}function Hj(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d();}c=c.next;}while(c!==b)}}function Ij(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=c;break;default:a=c;}"function"===typeof b?b(a):b.current=a;}}
	function Jj(a,b,c){if(ic&&"function"===typeof ic.onCommitFiberUnmount)try{ic.onCommitFiberUnmount(hc,b);}catch(g){}switch(b.tag){case 0:case 11:case 14:case 15:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a=a.next;do{var e=d,f=e.destroy;e=e.tag;void 0!==f&&(0!==(e&2)?Dj(b,c,f):0!==(e&4)&&Dj(b,c,f));d=d.next;}while(d!==a)}break;case 1:Bj(b,c);a=b.stateNode;if("function"===typeof a.componentWillUnmount)try{a.props=b.memoizedProps,a.state=b.memoizedState,a.componentWillUnmount();}catch(g){Cj(b,
	c,g);}break;case 5:Bj(b,c);break;case 4:Kj(a,b,c);}}function Lj(a){var b=a.alternate;null!==b&&(a.alternate=null,Lj(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&(delete b[If],delete b[Jf],delete b[jf],delete b[Kf],delete b[Lf]));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null;}function Mj(a){return 5===a.tag||3===a.tag||4===a.tag}
	function Nj(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Mj(a.return))return null;a=a.return;}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child;}if(!(a.flags&2))return a.stateNode}}
	function Oj(a){a:{for(var b=a.return;null!==b;){if(Mj(b))break a;b=b.return;}throw Error(p(160));}var c=b;switch(c.tag){case 5:b=c.stateNode;c.flags&32&&(lb(b,""),c.flags&=-33);c=Nj(a);Pj(a,c,b);break;case 3:case 4:b=c.stateNode.containerInfo;c=Nj(a);Qj(a,c,b);break;default:throw Error(p(161));}}
	function Qj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=wf));else if(4!==d&&(a=a.child,null!==a))for(Qj(a,b,c),a=a.sibling;null!==a;)Qj(a,b,c),a=a.sibling;}
	function Pj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pj(a,b,c),a=a.sibling;null!==a;)Pj(a,b,c),a=a.sibling;}
	function Kj(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(p(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return;}e=!0;}if(5===d.tag||6===d.tag){a:for(var h=a,k=d,l=c,m=k;;)if(Jj(h,m,l),null!==m.child&&4!==m.tag)m.child.return=m,m=m.child;else {if(m===k)break a;for(;null===m.sibling;){if(null===m.return||m.return===k)break a;m=m.return;}m.sibling.return=m.return;m=m.sibling;}g?(h=
	f,k=d.stateNode,8===h.nodeType?h.parentNode.removeChild(k):h.removeChild(k)):f.removeChild(d.stateNode);}else if(18===d.tag)g?(h=f,k=d.stateNode,8===h.nodeType?Ef(h.parentNode,k):1===h.nodeType&&Ef(h,k),Yc(h)):Ef(f,d.stateNode);else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Jj(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&
	(e=!1);}d.sibling.return=d.return;d=d.sibling;}}
	function Rj(a,b){switch(b.tag){case 0:case 11:case 14:case 15:Gj(3,b,b.return);Hj(3,b);Gj(5,b,b.return);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){"input"===a&&"radio"===d.type&&null!=d.name&&Ya(c,d);sb(a,e);b=sb(a,d);for(e=0;e<f.length;e+=2){var g=f[e],h=f[e+1];"style"===g?pb(c,h):"dangerouslySetInnerHTML"===g?kb(c,h):"children"===g?lb(c,h):ra(c,g,h,b);}switch(a){case "input":Za(c,
	d);break;case "textarea":fb(c,d);break;case "select":a=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,f=d.value,null!=f?cb(c,!!d.multiple,f,!1):a!==!!d.multiple&&(null!=d.defaultValue?cb(c,!!d.multiple,d.defaultValue,!0):cb(c,!!d.multiple,d.multiple?[]:"",!1));}c[Jf]=d;}}return;case 6:if(null===b.stateNode)throw Error(p(162));b.stateNode.nodeValue=b.memoizedProps;return;case 3:null!==a&&a.memoizedState.isDehydrated&&Yc(b.stateNode.containerInfo);return;case 12:return;case 13:Sj(b);
	return;case 19:Sj(b);return;case 17:return}throw Error(p(163));}function Sj(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Aj);b.forEach(function(b){var d=Tj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d));});}}
	function Uj(a,b){for(X=b;null!==X;){b=X;var c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=c[d];try{Kj(a,e,b);var f=e.alternate;null!==f&&(f.return=null);e.return=null;}catch(L){Cj(e,b,L);}}c=b.child;if(0!==(b.subtreeFlags&12854)&&null!==c)c.return=b,X=c;else for(;null!==X;){b=X;try{var g=b.flags;g&32&&lb(b.stateNode,"");if(g&512){var h=b.alternate;if(null!==h){var k=h.ref;null!==k&&("function"===typeof k?k(null):k.current=null);}}if(g&8192)switch(b.tag){case 13:if(null!==b.memoizedState){var l=
	b.alternate;if(null===l||null===l.memoizedState)Vj=D();}break;case 22:var m=null!==b.memoizedState,w=b.alternate,u=null!==w&&null!==w.memoizedState;c=b;a:{d=c;e=m;for(var y=null,n=d;;){if(5===n.tag){if(null===y){y=n;var v=n.stateNode;if(e){var C=v.style;"function"===typeof C.setProperty?C.setProperty("display","none","important"):C.display="none";}else {var t=n.stateNode,r=n.memoizedProps.style,x=void 0!==r&&null!==r&&r.hasOwnProperty("display")?r.display:null;t.style.display=ob("display",x);}}}else if(6===
	n.tag)null===y&&(n.stateNode.nodeValue=e?"":n.memoizedProps);else if((22!==n.tag&&23!==n.tag||null===n.memoizedState||n===d)&&null!==n.child){n.child.return=n;n=n.child;continue}if(n===d)break;for(;null===n.sibling;){if(null===n.return||n.return===d)break a;y===n&&(y=null);n=n.return;}y===n&&(y=null);n.sibling.return=n.return;n=n.sibling;}}if(m&&!u&&0!==(c.mode&1)){X=c;for(var B=c.child;null!==B;){for(c=X=B;null!==X;){d=X;var O=d.child;switch(d.tag){case 0:case 11:case 14:case 15:Gj(4,d,d.return);break;
	case 1:Bj(d,d.return);var T=d.stateNode;if("function"===typeof T.componentWillUnmount){var za=d.return;try{T.props=d.memoizedProps,T.state=d.memoizedState,T.componentWillUnmount();}catch(L){Cj(d,za,L);}}break;case 5:Bj(d,d.return);break;case 22:if(null!==d.memoizedState){Wj(c);continue}}null!==O?(O.return=d,X=O):Wj(c);}B=B.sibling;}}}switch(g&4102){case 2:Oj(b);b.flags&=-3;break;case 6:Oj(b);b.flags&=-3;Rj(b.alternate,b);break;case 4096:b.flags&=-4097;break;case 4100:b.flags&=-4097;Rj(b.alternate,b);
	break;case 4:Rj(b.alternate,b);}}catch(L){Cj(b,b.return,L);}c=b.sibling;if(null!==c){c.return=b.return;X=c;break}X=b.return;}}}function Xj(a,b,c){X=a;Yj(a);}
	function Yj(a,b,c){for(var d=0!==(a.mode&1);null!==X;){var e=X,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||yj;if(!g){var h=e.alternate,k=null!==h&&null!==h.memoizedState||zj;h=yj;var l=zj;yj=g;if((zj=k)&&!l)for(X=e;null!==X;)g=X,k=g.child,22===g.tag&&null!==g.memoizedState?Zj(e):null!==k?(k.return=g,X=k):Zj(e);for(;null!==f;)X=f,Yj(f),f=f.sibling;X=e;yj=h;zj=l;}ak(a);}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,X=f):ak(a);}}
	function ak(a){for(;null!==X;){var b=X;if(0!==(b.flags&8772)){var c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:zj||Hj(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!zj)if(null===c)d.componentDidMount();else {var e=b.elementType===b.type?c.memoizedProps:fg(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate);}var f=b.updateQueue;null!==f&&Ag(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=
	b.child.stateNode;break;case 1:c=b.child.stateNode;}Ag(b,g,c);}break;case 5:var h=b.stateNode;if(null===c&&b.flags&4){c=h;var k=b.memoizedProps;switch(b.type){case "button":case "input":case "select":case "textarea":k.autoFocus&&c.focus();break;case "img":k.src&&(c.src=k.src);}}break;case 6:break;case 4:break;case 12:break;case 13:if(null===b.memoizedState){var l=b.alternate;if(null!==l){var m=l.memoizedState;if(null!==m){var w=m.dehydrated;null!==w&&Yc(w);}}}break;case 19:case 17:case 21:case 22:case 23:break;
	default:throw Error(p(163));}zj||b.flags&512&&Ij(b);}catch(u){Cj(b,b.return,u);}}if(b===a){X=null;break}c=b.sibling;if(null!==c){c.return=b.return;X=c;break}X=b.return;}}function Wj(a){for(;null!==X;){var b=X;if(b===a){X=null;break}var c=b.sibling;if(null!==c){c.return=b.return;X=c;break}X=b.return;}}
	function Zj(a){for(;null!==X;){var b=X;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Hj(4,b);}catch(k){Cj(b,c,k);}break;case 1:var d=b.stateNode;if("function"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount();}catch(k){Cj(b,e,k);}}var f=b.return;try{Ij(b);}catch(k){Cj(b,f,k);}break;case 5:var g=b.return;try{Ij(b);}catch(k){Cj(b,g,k);}}}catch(k){Cj(b,b.return,k);}if(b===a){X=null;break}var h=b.sibling;if(null!==h){h.return=b.return;X=h;break}X=b.return;}}
	var bk=Math.ceil,ck=sa.ReactCurrentDispatcher,dk=sa.ReactCurrentOwner,ek=sa.ReactCurrentBatchConfig,K=0,J=null,Y=null,Z=0,Vi=0,ej=Of(0),W=0,fk=null,zg=0,gk=0,hk=0,ik=null,jk=null,Vj=0,Ti=Infinity,Di=!1,Ei=null,Gi=null,kk=!1,lk=null,mk=0,nk=0,ok=null,pk=-1,qk=0;function M(){return 0!==(K&6)?D():-1!==pk?pk:pk=D()}
	function Dg(a){if(0===(a.mode&1))return 1;if(0!==(K&2)&&0!==Z)return Z&-Z;if(null!==eg.transition)return 0===qk&&(a=oc,oc<<=1,0===(oc&4194240)&&(oc=64),qk=a),qk;a=E;if(0!==a)return a;a=window.event;a=void 0===a?16:ed(a.type);return a}function Eg(a,b,c){if(50<nk)throw nk=0,ok=null,Error(p(185));var d=rk(a,b);if(null===d)return null;wc(d,b,c);if(0===(K&2)||d!==J)d===J&&(0===(K&2)&&(gk|=b),4===W&&sk(d,Z)),tk(d,c),1===b&&0===K&&0===(a.mode&1)&&(Ti=D()+500,$f&&dg());return d}
	function rk(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}
	function tk(a,b){var c=a.callbackNode;tc(a,b);var d=rc(a,a===J?Z:0);if(0===d)null!==c&&Zb(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&Zb(c);if(1===b)0===a.tag?cg(uk.bind(null,a)):bg(uk.bind(null,a)),Df(function(){0===K&&dg();}),c=null;else {switch(zc(d)){case 1:c=cc;break;case 4:c=dc;break;case 16:c=ec;break;case 536870912:c=gc;break;default:c=ec;}c=vk(c,wk.bind(null,a));}a.callbackPriority=b;a.callbackNode=c;}}
	function wk(a,b){pk=-1;qk=0;if(0!==(K&6))throw Error(p(327));var c=a.callbackNode;if(xk()&&a.callbackNode!==c)return null;var d=rc(a,a===J?Z:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=yk(a,d);else {b=d;var e=K;K|=2;var f=zk();if(J!==a||Z!==b)Ti=D()+500,Ak(a,b);do try{Bk();break}catch(h){Ck(a,h);}while(1);kg();ck.current=f;K=e;null!==Y?b=0:(J=null,Z=0,b=W);}if(0!==b){2===b&&(e=uc(a),0!==e&&(d=e,b=Dk(a,e)));if(1===b)throw c=fk,Ak(a,0),sk(a,d),tk(a,D()),c;if(6===b)sk(a,d);else {e=
	a.current.alternate;if(0===(d&30)&&!Ek(e)&&(b=yk(a,d),2===b&&(f=uc(a),0!==f&&(d=f,b=Dk(a,f))),1===b))throw c=fk,Ak(a,0),sk(a,d),tk(a,D()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(p(345));case 2:Fk(a,jk);break;case 3:sk(a,d);if((d&130023424)===d&&(b=Vj+500-D(),10<b)){if(0!==rc(a,0))break;e=a.suspendedLanes;if((e&d)!==d){M();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=zf(Fk.bind(null,a,jk),b);break}Fk(a,jk);break;case 4:sk(a,d);if((d&4194240)===d)break;b=
	a.eventTimes;for(e=-1;0<d;){var g=31-lc(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f;}d=e;d=D()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*bk(d/1960))-d;if(10<d){a.timeoutHandle=zf(Fk.bind(null,a,jk),d);break}Fk(a,jk);break;case 5:Fk(a,jk);break;default:throw Error(p(329));}}}tk(a,D());return a.callbackNode===c?wk.bind(null,a):null}function Dk(a,b){var c=ik;a.current.memoizedState.isDehydrated&&(Ak(a,b).flags|=256);a=yk(a,b);2!==a&&(b=jk,jk=c,null!==b&&Ri(b));return a}
	function Ri(a){null===jk?jk=a:jk.push.apply(jk,a);}function Ek(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!Ce(f(),e))return !1}catch(g){return !1}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else {if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return !0;b=b.return;}b.sibling.return=b.return;b=b.sibling;}}return !0}
	function sk(a,b){b&=~hk;b&=~gk;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-lc(b),d=1<<c;a[c]=-1;b&=~d;}}function uk(a){if(0!==(K&6))throw Error(p(327));xk();var b=rc(a,0);if(0===(b&1))return tk(a,D()),null;var c=yk(a,b);if(0!==a.tag&&2===c){var d=uc(a);0!==d&&(b=d,c=Dk(a,d));}if(1===c)throw c=fk,Ak(a,0),sk(a,b),tk(a,D()),c;if(6===c)throw Error(p(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;Fk(a,jk);tk(a,D());return null}
	function Gk(a,b){var c=K;K|=1;try{return a(b)}finally{K=c,0===K&&(Ti=D()+500,$f&&dg());}}function Hk(a){null!==lk&&0===lk.tag&&0===(K&6)&&xk();var b=K;K|=1;var c=ek.transition,d=E;try{if(ek.transition=null,E=1,a)return a()}finally{E=d,ek.transition=c,K=b,0===(K&6)&&dg();}}function Ui(){Vi=ej.current;G(ej);}
	function Ak(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Af(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;Wg(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&Uf();break;case 3:zh();G(Qf);G(I);Eh();break;case 5:Bh(d);break;case 4:zh();break;case 13:G(P);break;case 19:G(P);break;case 10:lg(d.type._context);break;case 22:case 23:Ui();}c=c.return;}J=a;Y=a=mh(a.current,null);Z=Vi=b;W=0;fk=null;hk=gk=zg=0;jk=ik=null;if(null!==qg){for(b=
	0;b<qg.length;b++)if(c=qg[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g;}c.pending=d;}qg=null;}return a}
	function Ck(a,b){do{var c=Y;try{kg();Fh.current=Rh;if(Ih){for(var d=Q.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next;}Ih=!1;}Hh=0;S=R$6=Q=null;Jh=!1;Kh=0;dk.current=null;if(null===c||null===c.return){W=1;fk=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=Z;h.flags|=32768;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var l=k,m=h,w=m.tag;if(0===(m.mode&1)&&(0===w||11===w||15===w)){var u=m.alternate;u?(m.updateQueue=u.updateQueue,m.memoizedState=u.memoizedState,
	m.lanes=u.lanes):(m.updateQueue=null,m.memoizedState=null);}var y=Ji(g);if(null!==y){y.flags&=-257;Ki(y,g,h,f,b);y.mode&1&&Hi(f,l,b);b=y;k=l;var n=b.updateQueue;if(null===n){var v=new Set;v.add(k);b.updateQueue=v;}else n.add(k);break a}else {if(0===(b&1)){Hi(f,l,b);Si();break a}k=Error(p(426));}}else if(N&&h.mode&1){var C=Ji(g);if(null!==C){0===(C.flags&65536)&&(C.flags|=256);Ki(C,g,h,f,b);hh(k);break a}}f=k;4!==W&&(W=2);null===ik?ik=[f]:ik.push(f);k=zi(k,h);h=g;do{switch(h.tag){case 3:h.flags|=65536;
	b&=-b;h.lanes|=b;var t=Ci(h,k,b);xg(h,t);break a;case 1:f=k;var r=h.type,x=h.stateNode;if(0===(h.flags&128)&&("function"===typeof r.getDerivedStateFromError||null!==x&&"function"===typeof x.componentDidCatch&&(null===Gi||!Gi.has(x)))){h.flags|=65536;b&=-b;h.lanes|=b;var B=Fi(h,f,b);xg(h,B);break a}}h=h.return;}while(null!==h)}Ik(c);}catch(O){b=O;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}function zk(){var a=ck.current;ck.current=Rh;return null===a?Rh:a}
	function Si(){if(0===W||3===W||2===W)W=4;null===J||0===(zg&268435455)&&0===(gk&268435455)||sk(J,Z);}function yk(a,b){var c=K;K|=2;var d=zk();J===a&&Z===b||Ak(a,b);do try{Jk();break}catch(e){Ck(a,e);}while(1);kg();K=c;ck.current=d;if(null!==Y)throw Error(p(261));J=null;Z=0;return W}function Jk(){for(;null!==Y;)Kk(Y);}function Bk(){for(;null!==Y&&!$b();)Kk(Y);}function Kk(a){var b=Lk(a.alternate,a,Vi);a.memoizedProps=a.pendingProps;null===b?Ik(a):Y=b;dk.current=null;}
	function Ik(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=Qi(c,b,Vi),null!==c){Y=c;return}}else {c=xj(c,b);if(null!==c){c.flags&=32767;Y=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else {W=6;Y=null;return}}b=b.sibling;if(null!==b){Y=b;return}Y=b=a;}while(null!==b);0===W&&(W=5);}function Fk(a,b){var c=E,d=ek.transition;try{ek.transition=null,E=1,Mk(a,b,c);}finally{ek.transition=d,E=c;}return null}
	function Mk(a,b,c){do xk();while(null!==lk);if(0!==(K&6))throw Error(p(327));var d=a.finishedWork,e=a.finishedLanes;if(null===d)return null;a.finishedWork=null;a.finishedLanes=0;if(d===a.current)throw Error(p(177));a.callbackNode=null;a.callbackPriority=0;var f=d.lanes|d.childLanes;xc(a,f);a===J&&(Y=J=null,Z=0);0===(d.subtreeFlags&2064)&&0===(d.flags&2064)||kk||(kk=!0,vk(ec,function(){xk();return null}));f=0!==(d.flags&15990);if(0!==(d.subtreeFlags&15990)||f){f=ek.transition;ek.transition=null;var g=
	E;E=1;var h=K;K|=4;dk.current=null;Fj(a,d);Uj(a,d);Je(xf);xf=null;a.current=d;Xj(d);ac();K=h;E=g;ek.transition=f;}else a.current=d;kk&&(kk=!1,lk=a,mk=e);f=a.pendingLanes;0===f&&(Gi=null);jc(d.stateNode);tk(a,D());if(null!==b)for(c=a.onRecoverableError,d=0;d<b.length;d++)c(b[d]);if(Di)throw Di=!1,a=Ei,Ei=null,a;0!==(mk&1)&&0!==a.tag&&xk();f=a.pendingLanes;0!==(f&1)?a===ok?nk++:(nk=0,ok=a):nk=0;dg();return null}
	function xk(){if(null!==lk){var a=zc(mk),b=ek.transition,c=E;try{ek.transition=null;E=16>a?16:a;if(null===lk)var d=!1;else {a=lk;lk=null;mk=0;if(0!==(K&6))throw Error(p(331));var e=K;K|=4;for(X=a.current;null!==X;){var f=X,g=f.child;if(0!==(X.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var l=h[k];for(X=l;null!==X;){var m=X;switch(m.tag){case 0:case 11:case 15:Gj(8,m,f);}var w=m.child;if(null!==w)w.return=m,X=w;else for(;null!==X;){m=X;var u=m.sibling,y=m.return;Lj(m);if(m===
	l){X=null;break}if(null!==u){u.return=y;X=u;break}X=y;}}}var n=f.alternate;if(null!==n){var v=n.child;if(null!==v){n.child=null;do{var C=v.sibling;v.sibling=null;v=C;}while(null!==v)}}X=f;}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,X=g;else b:for(;null!==X;){f=X;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Gj(9,f,f.return);}var t=f.sibling;if(null!==t){t.return=f.return;X=t;break b}X=f.return;}}var r=a.current;for(X=r;null!==X;){g=X;var x=g.child;if(0!==(g.subtreeFlags&2064)&&null!==
	x)x.return=g,X=x;else b:for(g=r;null!==X;){h=X;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Hj(9,h);}}catch(O){Cj(h,h.return,O);}if(h===g){X=null;break b}var B=h.sibling;if(null!==B){B.return=h.return;X=B;break b}X=h.return;}}K=e;dg();if(ic&&"function"===typeof ic.onPostCommitFiberRoot)try{ic.onPostCommitFiberRoot(hc,a);}catch(O){}d=!0;}return d}finally{E=c,ek.transition=b;}}return !1}function Nk(a,b,c){b=zi(c,b);b=Ci(a,b,1);vg(a,b);b=M();a=rk(a,1);null!==a&&(wc(a,1,b),tk(a,b));}
	function Cj(a,b,c){if(3===a.tag)Nk(a,a,c);else for(;null!==b;){if(3===b.tag){Nk(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if("function"===typeof b.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Gi||!Gi.has(d))){a=zi(c,a);a=Fi(b,a,1);vg(b,a);a=M();b=rk(b,1);null!==b&&(wc(b,1,a),tk(b,a));break}}b=b.return;}}
	function Ii(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=M();a.pingedLanes|=a.suspendedLanes&c;J===a&&(Z&c)===c&&(4===W||3===W&&(Z&130023424)===Z&&500>D()-Vj?Ak(a,0):hk|=c);tk(a,b);}function Ok(a,b){0===b&&(0===(a.mode&1)?b=1:(b=pc,pc<<=1,0===(pc&130023424)&&(pc=4194304)));var c=M();a=rk(a,b);null!==a&&(wc(a,b,c),tk(a,c));}function qj(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);Ok(a,c);}
	function Tj(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);break;case 19:d=a.stateNode;break;default:throw Error(p(314));}null!==d&&d.delete(b);Ok(a,c);}var Lk;
	Lk=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||Qf.current)og=!0;else {if(0===(a.lanes&c)&&0===(b.flags&128))return og=!1,wj(a,b,c);og=0!==(a.flags&131072)?!0:!1;}else og=!1,N&&0!==(b.flags&1048576)&&Ug(b,Ng,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);a=b.pendingProps;var e=Sf(b,I.current);ng(b,c);e=Nh(null,b,d,a,e,c);var f=Sh();b.flags|=1;"object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof?
	(b.tag=1,b.memoizedState=null,b.updateQueue=null,Tf(d)?(f=!0,Xf(b)):f=!1,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,sg(b),e.updater=Fg,b.stateNode=e,e._reactInternals=b,Jg(b,d,a,c),b=hj(null,b,d,!0,f,c)):(b.tag=0,N&&f&&Vg(b),Xi(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=Pk(d);a=fg(d,a);switch(e){case 0:b=cj(null,b,d,a,c);break a;case 1:b=gj(null,b,
	d,a,c);break a;case 11:b=Yi(null,b,d,a,c);break a;case 14:b=$i(null,b,d,fg(d.type,a),c);break a}throw Error(p(306,d,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:fg(d,e),cj(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:fg(d,e),gj(a,b,d,e,c);case 3:a:{ij(b);if(null===a)throw Error(p(387));d=b.pendingProps;f=b.memoizedState;e=f.element;tg(a,b);yg(b,d,null,c);var g=b.memoizedState;d=g.element;if(f.isDehydrated)if(f={element:d,isDehydrated:!1,
	cache:g.cache,transitions:g.transitions},b.updateQueue.baseState=f,b.memoizedState=f,b.flags&256){e=Error(p(423));b=jj(a,b,d,c,e);break a}else if(d!==e){e=Error(p(424));b=jj(a,b,d,c,e);break a}else for(Yg=Ff(b.stateNode.containerInfo.firstChild),Xg=b,N=!0,Zg=null,c=sh(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else {gh();if(d===e){b=Zi(a,b,c);break a}Xi(a,b,d,c);}b=b.child;}return b;case 5:return Ah(b),null===a&&dh(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,
	yf(d,e)?g=null:null!==f&&yf(d,f)&&(b.flags|=32),fj(a,b),Xi(a,b,g,c),b.child;case 6:return null===a&&dh(b),null;case 13:return mj(a,b,c);case 4:return yh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=rh(b,null,d,c):Xi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:fg(d,e),Yi(a,b,d,e,c);case 7:return Xi(a,b,b.pendingProps,c),b.child;case 8:return Xi(a,b,b.pendingProps.children,c),b.child;case 12:return Xi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=
	b.type._context;e=b.pendingProps;f=b.memoizedProps;g=e.value;H(gg,d._currentValue);d._currentValue=g;if(null!==f)if(Ce(f.value,g)){if(f.children===e.children&&!Qf.current){b=Zi(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=ug(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var m=l.pending;null===m?k.next=k:(k.next=m.next,m.next=k);l.pending=k;}}f.lanes|=
	c;k=f.alternate;null!==k&&(k.lanes|=c);mg(f.return,c,b);h.lanes|=c;break}k=k.next;}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===f.tag){g=f.return;if(null===g)throw Error(p(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);mg(g,c,b);g=f.sibling;}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return;}f=g;}Xi(a,b,e.children,c);b=b.child;}return b;case 9:return e=b.type,d=b.pendingProps.children,
	ng(b,c),e=pg(e),d=d(e),b.flags|=1,Xi(a,b,d,c),b.child;case 14:return d=b.type,e=fg(d,b.pendingProps),e=fg(d.type,e),$i(a,b,d,e,c);case 15:return bj(a,b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:fg(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),b.tag=1,Tf(d)?(a=!0,Xf(b)):a=!1,ng(b,c),Hg(b,d,e),Jg(b,d,e,c),hj(null,b,d,!0,a,c);case 19:return vj(a,b,c);case 22:return dj(a,b,c)}throw Error(p(156,b.tag));};function vk(a,b){return Yb(a,b)}
	function Qk(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null;}function ah(a,b,c,d){return new Qk(a,b,c,d)}function aj(a){a=a.prototype;return !(!a||!a.isReactComponent)}
	function Pk(a){if("function"===typeof a)return aj(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Ba)return 11;if(a===Ea)return 14}return 2}
	function mh(a,b){var c=a.alternate;null===c?(c=ah(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};
	c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
	function oh(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)aj(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case va:return qh(c.children,e,f,b);case wa:g=8;e|=8;break;case xa:return a=ah(12,c,b,e|2),a.elementType=xa,a.lanes=f,a;case Ca:return a=ah(13,c,b,e),a.elementType=Ca,a.lanes=f,a;case Da:return a=ah(19,c,b,e),a.elementType=Da,a.lanes=f,a;case Ga:return nj(c,e,f,b);default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case ya:g=10;break a;case Aa:g=9;break a;case Ba:g=11;
	break a;case Ea:g=14;break a;case Fa:g=16;d=null;break a}throw Error(p(130,null==a?a:typeof a,""));}b=ah(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function qh(a,b,c,d){a=ah(7,a,d,b);a.lanes=c;return a}function nj(a,b,c,d){a=ah(22,a,d,b);a.elementType=Ga;a.lanes=c;a.stateNode={};return a}function nh(a,b,c){a=ah(6,a,null,b);a.lanes=c;return a}
	function ph(a,b,c){b=ah(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
	function Rk(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=vc(0);this.expirationTimes=vc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=vc(0);this.identifierPrefix=d;this.onRecoverableError=e;this.mutableSourceEagerHydrationData=
	null;}function Sk(a,b,c,d,e,f,g,h,k){a=new Rk(a,b,c,h,k);1===b?(b=1,!0===f&&(b|=8)):b=0;f=ah(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null};sg(f);return a}function Tk(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return {$$typeof:ua,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
	function Uk(a){if(!a)return Pf;a=a._reactInternals;a:{if(Sb(a)!==a||1!==a.tag)throw Error(p(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(Tf(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return;}while(null!==b);throw Error(p(171));}if(1===a.tag){var c=a.type;if(Tf(c))return Wf(a,c,b)}return b}
	function Vk(a,b,c,d,e,f,g,h,k){a=Sk(c,d,!0,a,e,f,g,h,k);a.context=Uk(null);c=a.current;d=M();e=Dg(c);f=ug(d,e);f.callback=void 0!==b&&null!==b?b:null;vg(c,f);a.current.lanes=e;wc(a,e,d);tk(a,d);return a}function Wk(a,b,c,d){var e=b.current,f=M(),g=Dg(e);c=Uk(c);null===b.context?b.context=c:b.pendingContext=c;b=ug(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);vg(e,b);a=Eg(e,g,f);null!==a&&wg(a,e,g);return g}
	function Xk(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Yk(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b;}}function Zk(a,b){Yk(a,b);(a=a.alternate)&&Yk(a,b);}function $k(){return null}var al="function"===typeof reportError?reportError:function(a){console.error(a);};function bl(a){this._internalRoot=a;}
	cl.prototype.render=bl.prototype.render=function(a){var b=this._internalRoot;if(null===b)throw Error(p(409));Wk(a,b,null,null);};cl.prototype.unmount=bl.prototype.unmount=function(){var a=this._internalRoot;if(null!==a){this._internalRoot=null;var b=a.containerInfo;Hk(function(){Wk(null,a,null,null);});b[pf]=null;}};function cl(a){this._internalRoot=a;}
	cl.prototype.unstable_scheduleHydration=function(a){if(a){var b=Dc();a={blockedOn:null,target:a,priority:b};for(var c=0;c<Mc.length&&0!==b&&b<Mc[c].priority;c++);Mc.splice(c,0,a);0===c&&Rc(a);}};function dl(a){return !(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType)}function el(a){return !(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function fl(){}
	function gl(a,b,c,d,e){if(e){if("function"===typeof d){var f=d;d=function(){var a=Xk(g);f.call(a);};}var g=Vk(b,d,a,0,null,!1,!1,"",fl);a._reactRootContainer=g;a[pf]=g.current;nf(8===a.nodeType?a.parentNode:a);Hk();return g}for(;e=a.lastChild;)a.removeChild(e);if("function"===typeof d){var h=d;d=function(){var a=Xk(k);h.call(a);};}var k=Sk(a,0,!1,null,null,!1,!1,"",fl);a._reactRootContainer=k;a[pf]=k.current;nf(8===a.nodeType?a.parentNode:a);Hk(function(){Wk(b,k,c,d);});return k}
	function hl(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f;if("function"===typeof e){var h=e;e=function(){var a=Xk(g);h.call(a);};}Wk(b,g,a,e);}else g=gl(c,b,a,e,d);return Xk(g)}Ac=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=qc(b.pendingLanes);0!==c&&(yc(b,c|1),tk(b,D()),0===(K&6)&&(Ti=D()+500,dg()));}break;case 13:var d=M();Hk(function(){return Eg(a,1,d)});Zk(a,1);}};Bc=function(a){if(13===a.tag){var b=M();Eg(a,134217728,b);Zk(a,134217728);}};
	Cc=function(a){if(13===a.tag){var b=M(),c=Dg(a);Eg(a,c,b);Zk(a,c);}};Dc=function(){return E};Ec=function(a,b){var c=E;try{return E=a,b()}finally{E=c;}};
	vb=function(a,b,c){switch(b){case "input":Za(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Ab(d);if(!e)throw Error(p(90));Ua(d);Za(d,e);}}}break;case "textarea":fb(a,c);break;case "select":b=c.value,null!=b&&cb(a,!!c.multiple,b,!1);}};Db=Gk;Eb=Hk;
	var il={usingClientEntryPoint:!1,Events:[zb,pe,Ab,Bb,Cb,Gk]},jl={findFiberByHostInstance:Sc,bundleType:0,version:"18.0.0-fc46dba67-20220329",rendererPackageName:"react-dom"};
	var kl={bundleType:jl.bundleType,version:jl.version,rendererPackageName:jl.rendererPackageName,rendererConfig:jl.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:sa.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Wb(a);return null===a?null:a.stateNode},findFiberByHostInstance:jl.findFiberByHostInstance||
	$k,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.0.0-fc46dba67-20220329"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var ll=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!ll.isDisabled&&ll.supportsFiber)try{hc=ll.inject(kl),ic=ll;}catch(a){}}reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=il;
	reactDom_production_min.createPortal=function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!dl(b))throw Error(p(200));return Tk(a,b,null,c)};reactDom_production_min.createRoot=function(a,b){if(!dl(a))throw Error(p(299));var c=!1,d="",e=al;null!==b&&void 0!==b&&(!0===b.unstable_strictMode&&(c=!0),void 0!==b.identifierPrefix&&(d=b.identifierPrefix),void 0!==b.onRecoverableError&&(e=b.onRecoverableError));b=Sk(a,1,!1,null,null,c,!1,d,e);a[pf]=b.current;nf(8===a.nodeType?a.parentNode:a);return new bl(b)};
	reactDom_production_min.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(p(188));a=Object.keys(a).join(",");throw Error(p(268,a));}a=Wb(b);a=null===a?null:a.stateNode;return a};reactDom_production_min.flushSync=function(a){return Hk(a)};reactDom_production_min.hydrate=function(a,b,c){if(!el(b))throw Error(p(200));return hl(null,a,b,!0,c)};
	reactDom_production_min.hydrateRoot=function(a,b,c){if(!dl(a))throw Error(p(405));var d=null!=c&&c.hydratedSources||null,e=!1,f="",g=al;null!==c&&void 0!==c&&(!0===c.unstable_strictMode&&(e=!0),void 0!==c.identifierPrefix&&(f=c.identifierPrefix),void 0!==c.onRecoverableError&&(g=c.onRecoverableError));b=Vk(b,null,a,1,null!=c?c:null,e,!1,f,g);a[pf]=b.current;nf(a);if(d)for(a=0;a<d.length;a++)c=d[a],e=c._getVersion,e=e(c._source),null==b.mutableSourceEagerHydrationData?b.mutableSourceEagerHydrationData=[c,e]:b.mutableSourceEagerHydrationData.push(c,
	e);return new cl(b)};reactDom_production_min.render=function(a,b,c){if(!el(b))throw Error(p(200));return hl(null,a,b,!1,c)};reactDom_production_min.unmountComponentAtNode=function(a){if(!el(a))throw Error(p(40));return a._reactRootContainer?(Hk(function(){hl(null,null,a,!1,function(){a._reactRootContainer=null;a[pf]=null;});}),!0):!1};reactDom_production_min.unstable_batchedUpdates=Gk;
	reactDom_production_min.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!el(c))throw Error(p(200));if(null==a||void 0===a._reactInternals)throw Error(p(38));return hl(a,b,c,!1,d)};reactDom_production_min.version="18.0.0-fc46dba67-20220329";

	function checkDCE() {
	  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	  if (
	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
	  ) {
	    return;
	  }
	  try {
	    // Verify that the code above has been dead code eliminated (DCE'd).
	    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
	  } catch (err) {
	    // DevTools shouldn't crash React, no matter what.
	    // We should still report in case we break this code.
	    console.error(err);
	  }
	}

	{
	  // DCE check should happen before ReactDOM bundle executes so that
	  // DevTools can report bad minification during injection.
	  checkDCE();
	  reactDom.exports = reactDom_production_min;
	}

	var ReactDOM = reactDom.exports;

	var dist$7 = {};

	var lib = {};

	var reflect$1 = {};

	var format = {};

	(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isLiteralNode = exports.TI_NULL = exports.TI_THIS = exports.TI_FALSE = exports.TI_TRUE = exports.TI_UNDEFINED = exports.TI_UNKNOWN = exports.TI_ANY = exports.TI_VOID = exports.T_INTRINSICS = exports.T_ENUM = exports.T_OBJECT = exports.T_STAND_IN = exports.T_CALLSITE = exports.T_FALSE = exports.T_TRUE = exports.T_MAPPED = exports.T_GENERIC = exports.T_THIS = exports.T_ARRAY = exports.T_TUPLE = exports.T_NULL = exports.T_UNDEFINED = exports.T_VOID = exports.T_UNKNOWN = exports.T_ANY = exports.T_INTERSECTION = exports.T_UNION = exports.F_INFERRED = exports.F_EXPORTED = exports.F_ASYNC = exports.F_OPTIONAL = exports.F_ARROW_FUNCTION = exports.F_FUNCTION = exports.F_INTERFACE = exports.F_CLASS = exports.F_STATIC = exports.F_METHOD = exports.F_PROPERTY = exports.F_PROTECTED = exports.F_PRIVATE = exports.F_PUBLIC = exports.F_ABSTRACT = exports.F_READONLY = void 0;
	exports.F_READONLY = 'R';
	exports.F_ABSTRACT = 'A';
	exports.F_PUBLIC = '$';
	exports.F_PRIVATE = '#';
	exports.F_PROTECTED = '@';
	exports.F_PROPERTY = 'P';
	exports.F_METHOD = 'M';
	exports.F_STATIC = 'S';
	exports.F_CLASS = 'C';
	exports.F_INTERFACE = 'I';
	exports.F_FUNCTION = 'F';
	exports.F_ARROW_FUNCTION = '>';
	exports.F_OPTIONAL = '?';
	exports.F_ASYNC = 'a';
	exports.F_EXPORTED = 'e';
	exports.F_INFERRED = '.';
	exports.T_UNION = '|';
	exports.T_INTERSECTION = '&';
	exports.T_ANY = '~';
	exports.T_UNKNOWN = 'U';
	exports.T_VOID = 'V';
	exports.T_UNDEFINED = 'u';
	exports.T_NULL = 'n';
	exports.T_TUPLE = 'T';
	exports.T_ARRAY = '[';
	exports.T_THIS = 't';
	exports.T_GENERIC = 'g';
	exports.T_MAPPED = 'm';
	exports.T_TRUE = '1';
	exports.T_FALSE = '0';
	exports.T_CALLSITE = 'c';
	exports.T_STAND_IN = '5';
	exports.T_OBJECT = 'O';
	exports.T_ENUM = 'e';
	exports.T_INTRINSICS = [exports.T_VOID, exports.T_ANY, exports.T_UNKNOWN, exports.T_UNDEFINED, exports.T_TRUE, exports.T_FALSE, exports.T_THIS, exports.T_NULL];
	exports.TI_VOID = { TΦ: exports.T_VOID };
	exports.TI_ANY = { TΦ: exports.T_ANY };
	exports.TI_UNKNOWN = { TΦ: exports.T_UNKNOWN };
	exports.TI_UNDEFINED = { TΦ: exports.T_UNDEFINED };
	exports.TI_TRUE = { TΦ: exports.T_TRUE };
	exports.TI_FALSE = { TΦ: exports.T_FALSE };
	exports.TI_THIS = { TΦ: exports.T_THIS };
	exports.TI_NULL = { TΦ: exports.T_NULL };
	function isLiteralNode(node) {
	    return !!node['$__isTSNode'];
	}
	exports.isLiteralNode = isLiteralNode;

	}(format));

	var getParameterNames$2 = {};

	/**
	 * Original from https://github.com/goatslacker/get-parameter-names/blob/master/index.js
	 */
	Object.defineProperty(getParameterNames$2, "__esModule", { value: true });
	getParameterNames$2.getParameterNames = void 0;
	const COMMENTS$1 = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
	const DEFAULT_PARAMS$1 = /=[^,]+/mg;
	const FAT_ARROWS$1 = /=>.*$/mg;
	function getParameterNames$1(fn) {
	    const code = fn.toString()
	        .replace(COMMENTS$1, '')
	        .replace(FAT_ARROWS$1, '')
	        .replace(DEFAULT_PARAMS$1, '');
	    const result = code.slice(code.indexOf('(') + 1, code.indexOf(')'))
	        .match(/([^\s,]+)/g);
	    return result === null ? [] : result;
	}
	getParameterNames$2.getParameterNames = getParameterNames$1;

	var sealed = {};

	Object.defineProperty(sealed, "__esModule", { value: true });
	sealed.Sealed = void 0;
	function Sealed$1() {
	    return (target) => {
	        Object.seal(target);
	        return target;
	    };
	}
	sealed.Sealed = Sealed$1;

	(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __decorate = (commonjsGlobal && commonjsGlobal.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __metadata = (commonjsGlobal && commonjsGlobal.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var ReflectedClass_1;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ReflectedCallSite = exports.reflect = exports.matchesShape = exports.implementsInterface = exports.ReflectedClass = exports.ReflectedProperty = exports.ReflectedMethod = exports.ReflectedFunction = exports.ReflectedMember = exports.ReflectedConstructorParameter = exports.ReflectedFunctionParameter = exports.ReflectedMethodParameter = exports.ReflectedParameter = exports.ReflectedFlags = exports.ReflectedTupleElement = exports.ReflectedMappedRef = exports.ReflectedEnumRef = exports.ReflectedGenericRef = exports.ReflectedTupleRef = exports.ReflectedAnyRef = exports.ReflectedUnknownRef = exports.ReflectedTrueRef = exports.ReflectedFalseRef = exports.ReflectedUndefinedRef = exports.ReflectedNullRef = exports.ReflectedVoidRef = exports.ReflectedArrayRef = exports.ReflectedIntersectionRef = exports.ReflectedUnionRef = exports.ReflectedLiteralRef = exports.ReflectedInterfaceRef = exports.ReflectedObjectRef = exports.ReflectedObjectMember = exports.ReflectedClassRef = exports.ReflectedTypeRef = exports.TYPE_REF_KIND_EXPANSION = exports.isCallSite = exports.reify = void 0;
	const format$1 = __importStar(format);
	const get_parameter_names_1 = getParameterNames$2;
	const sealed_1 = sealed;
	const NotProvided = Symbol();
	/**
	 * Obtain an object which uniquely identifies an interface type.
	 * You may prefer reflect<InterfaceType>() if you are writing reflect(reify<InterfaceType>()) or
	 * ReflectedClass.from(reify<InterfaceType>())
	 */
	function reify(callSite) {
	    if (!isCallSite(callSite))
	        throw new Error(`reify<T>() can only be used when project is built with the typescript-rtti transformer`);
	    let param = reflect(callSite).typeParameters[0];
	    if (param.is('interface'))
	        return param.token;
	    throw new Error(`reify<${param}>(): Type parameter must be an interface reference, not an arbitrary type`);
	}
	exports.reify = reify;
	function isCallSite(callSite) {
	    return (callSite === null || callSite === void 0 ? void 0 : callSite.TΦ) === 'c';
	}
	exports.isCallSite = isCallSite;
	function Flag(value) {
	    return (target, propertyKey) => {
	        if (!target.flagToProperty)
	            target.flagToProperty = {};
	        if (!target.propertyToFlag)
	            target.propertyToFlag = {};
	        target.flagToProperty[value] = propertyKey;
	        target.propertyToFlag[propertyKey] = value;
	    };
	}
	exports.TYPE_REF_KIND_EXPANSION = {
	    [format$1.T_UNKNOWN]: 'unknown',
	    [format$1.T_ANY]: 'any',
	    [format$1.T_UNION]: 'union',
	    [format$1.T_INTERSECTION]: 'intersection',
	    [format$1.T_TUPLE]: 'tuple',
	    [format$1.T_ARRAY]: 'array',
	    [format$1.T_GENERIC]: 'generic',
	    [format$1.T_VOID]: 'void',
	    [format$1.T_NULL]: 'null',
	    [format$1.T_UNDEFINED]: 'undefined',
	    [format$1.T_MAPPED]: 'mapped',
	    [format$1.T_ENUM]: 'enum',
	    [format$1.T_FALSE]: 'false',
	    [format$1.T_TRUE]: 'true',
	    [format$1.T_OBJECT]: 'object'
	};
	class ReflectedTypeRef {
	    /** @internal */
	    constructor(_ref) {
	        this._ref = _ref;
	    }
	    toString() {
	        return `[${this.kind} type]`;
	    }
	    /** @internal */
	    static Kind(kind) {
	        return (target) => {
	            ReflectedTypeRef.kinds[kind] = target;
	        };
	    }
	    /**
	     * Check if the given value matches this type reference. Collects any errors into the `errors` list.
	     * @param value
	     * @param errors
	     * @param context
	     * @returns
	     */
	    matchesValue(value, errors, context) {
	        errors.push(new Error(`No validation available for type with kind '${this.kind}'`));
	        return false;
	    }
	    /**
	     * Check if the given type reference is equivalent to this type reference.
	     * @param ref
	     * @returns
	     */
	    equals(ref) {
	        if (this === ref)
	            return true;
	        if (ref.constructor !== this.constructor)
	            return false;
	        return this.matches(ref);
	    }
	    matches(ref) {
	        return true;
	    }
	    get kind() {
	        let ref = this._ref;
	        if (ref === null || ['string', 'number'].includes(typeof ref))
	            return 'literal';
	        if (typeof ref === 'object' && 'TΦ' in ref)
	            return exports.TYPE_REF_KIND_EXPANSION[ref.TΦ];
	        if (typeof ref === 'object')
	            return 'interface';
	        return 'class';
	    }
	    /** @internal */
	    get ref() {
	        return this._ref;
	    }
	    /**
	     * Checks if this type reference is a Promise, optionally a Promise of a specific type.
	     * If the type reference does not specify a type of Promise but you have provided a type
	     * to check for, this will return false.
	     * @param klass The type of promise to check for. Would be String when looking for Promise<string>
	     */
	    isPromise(klass) {
	        if (this.isClass(Promise))
	            return !klass;
	        if (this.isGeneric(Promise)) {
	            if (this.typeParameters.length === 0)
	                return !klass;
	            return this.typeParameters[0].isClass(klass);
	        }
	        return false;
	    }
	    /**
	     * Checks if this type reference is a class. Note: If the class reference has type parameters,
	     * (ie it is generic) this check will fail, and instead isGeneric() will succeed.
	     * @param klass
	     */
	    isClass(klass) {
	        let literalTypes = {
	            'string': String,
	            'number': Number,
	            'boolean': Boolean,
	            'object': Object
	        };
	        if (this.kind === 'literal')
	            return literalTypes[typeof this.ref] === klass;
	        if (this.kind === 'null')
	            return Object === klass;
	        if (['true', 'false'].includes(this.kind))
	            return Boolean === klass;
	        return this.kind === 'class' && (!klass || this.ref === klass);
	    }
	    isInterface(interfaceType) {
	        if (interfaceType)
	            return this.isInterface() && this.ref.identity === interfaceType.identity;
	        else
	            return this.kind === 'interface';
	    }
	    isLiteral(value = NotProvided) {
	        if (value === null)
	            return this.isNull();
	        if (value === true)
	            return this.isTrue();
	        if (value === false)
	            return this.isFalse();
	        return this.kind === 'literal' && (value === NotProvided || this.ref === value);
	    }
	    is(kind) {
	        if (typeof kind === 'function')
	            return this instanceof kind;
	        else if (typeof kind === 'string')
	            return this.kind === kind;
	    }
	    as(subclass) {
	        if (typeof subclass === 'function' && !(this instanceof subclass))
	            throw new TypeError(`Value of type ${this.constructor.name} cannot be converted to ${subclass.name}`);
	        else if (typeof subclass === 'string' && this.kind !== subclass)
	            throw new TypeError(`Type has kind ${this.kind}, expected ${subclass}`);
	        return this;
	    }
	    isVoid() { return this.kind === 'void'; }
	    isNull() { return this.kind === 'null'; }
	    isUndefined() { return this.kind === 'undefined'; }
	    isTrue() { return this.kind === 'true'; }
	    isFalse() { return this.kind === 'false'; }
	    isStringLiteral() { return this.kind === 'literal' && typeof this.ref === 'string'; }
	    isNumberLiteral() { return this.kind === 'literal' && typeof this.ref === 'number'; }
	    isBooleanLiteral() { return this.isTrue() || this.isFalse(); }
	    /**
	     * Check if this type reference is a generic type, optionally checking if the generic's
	     * base type is the given class. For instance isGeneric(Promise) is true for Promise<string>.
	     * @param klass
	     */
	    isGeneric(klass) {
	        if (this.kind === 'generic') {
	            let rtGeneric = this.ref;
	            if (!rtGeneric.t['TΦ']) { // this is a class
	                return !klass || rtGeneric.t === klass;
	            }
	            return true;
	        }
	        return false;
	    }
	    isUnion(elementDiscriminator) {
	        return elementDiscriminator
	            ? this.isUnion() && this.types.every(e => elementDiscriminator(e))
	            : this.kind === 'union';
	    }
	    isIntersection(elementDiscriminator) {
	        return elementDiscriminator
	            ? this.isIntersection() && this.types.every(e => elementDiscriminator(e))
	            : this.kind === 'intersection';
	    }
	    isArray(elementDiscriminator) {
	        return elementDiscriminator
	            ? this.isArray() && elementDiscriminator(this.elementType)
	            : this.kind === 'array';
	    }
	    isTuple(elementDiscriminators) {
	        return elementDiscriminators
	            ? this.isTuple() && this.elements.every((e, i) => elementDiscriminators[i](e))
	            : this.kind === 'tuple';
	    }
	    isUnknown() {
	        return this.kind === 'unknown';
	    }
	    isAny() {
	        return this.kind === 'any';
	    }
	    /**
	     * Creates an "unknown"
	     * @internal
	     */
	    static createUnknown() {
	        return this.createFromRtRef({ TΦ: format$1.T_UNKNOWN });
	    }
	    /** @internal */
	    static createFromRtRef(ref) {
	        let kind;
	        if (ref === null || !['object', 'function'].includes(typeof ref))
	            kind = 'literal';
	        else if (typeof ref === 'object' && 'TΦ' in ref)
	            kind = exports.TYPE_REF_KIND_EXPANSION[ref.TΦ];
	        else if (typeof ref === 'object')
	            kind = 'interface';
	        else
	            kind = 'class';
	        return new (ReflectedTypeRef.kinds[kind] || ReflectedTypeRef)(ref);
	    }
	}
	exports.ReflectedTypeRef = ReflectedTypeRef;
	ReflectedTypeRef.kinds = {};
	let ReflectedClassRef = class ReflectedClassRef extends ReflectedTypeRef {
	    get kind() { return 'class'; }
	    get class() { return this.ref; }
	    get reflectedClass() { return ReflectedClass.for(this.class); }
	    toString() { return `class ${this.class.name}`; }
	    matches(ref) {
	        return this.class === ref.class;
	    }
	    matchesValue(value, errors = [], context) {
	        if (this.ref === String)
	            return typeof value === 'string';
	        else if (this.ref === Number)
	            return typeof value === 'number';
	        else if (this.ref === Boolean)
	            return typeof value === 'boolean';
	        else if (this.ref === Object)
	            return typeof value === 'object';
	        else if (this.ref === Function)
	            return typeof value === 'function';
	        else if (this.ref === Symbol)
	            return typeof value === 'symbol';
	        return ReflectedClass.for(this.ref).matchesValue(value);
	    }
	};
	ReflectedClassRef = __decorate([
	    ReflectedTypeRef.Kind('class')
	], ReflectedClassRef);
	exports.ReflectedClassRef = ReflectedClassRef;
	class ReflectedObjectMember {
	    constructor(ref) {
	        this.ref = ref;
	        this.name = ref.n;
	        this.type = ReflectedTypeRef.createFromRtRef(this.ref.t);
	    }
	    get flags() {
	        if (!this._flags)
	            this._flags = new ReflectedFlags(this.ref.f);
	        return this._flags;
	    }
	    get isOptional() { return this.flags.isOptional; }
	    equals(member) {
	        return this.name === member.name && this.type.equals(member.type);
	    }
	    toString() { var _a, _b; return `${this.name}: ${(_b = (_a = this.type) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '<error>'}`; }
	}
	exports.ReflectedObjectMember = ReflectedObjectMember;
	let ReflectedObjectRef = class ReflectedObjectRef extends ReflectedTypeRef {
	    get kind() { return 'object'; }
	    get members() {
	        if (!this._members)
	            this._members = this.ref.m.map(m => new ReflectedObjectMember(m));
	        return this._members;
	    }
	    toString() { return `{ ${this.members.map(m => m.toString()).join(', ')} }`; }
	    matches(ref) {
	        if (this.members.length !== ref.members.length)
	            return false;
	        for (let member of this.members) {
	            let matchingMember = ref.members.find(x => x.name);
	            if (!member.equals(matchingMember))
	                return false;
	        }
	        return true;
	    }
	    matchesValue(value, errors = [], context) {
	        if (typeof value !== 'object')
	            return false;
	        let matches = true;
	        for (let member of this.members) {
	            let hasValue = member.name in value;
	            if (!hasValue) {
	                if (!member.isOptional) {
	                    errors.push(new TypeError(`Missing value for member ${member.toString()}`));
	                    matches = false;
	                }
	                continue;
	            }
	            let memberValue = value[member.name];
	            let memberErrors = [];
	            if (!member.type.matchesValue(memberValue, memberErrors, context)) {
	                errors.push(new TypeError(`Value for member ${member.toString()} is invalid`));
	                errors.push(...memberErrors);
	                matches = false;
	            }
	        }
	        return matches;
	    }
	};
	ReflectedObjectRef = __decorate([
	    ReflectedTypeRef.Kind('object')
	], ReflectedObjectRef);
	exports.ReflectedObjectRef = ReflectedObjectRef;
	let ReflectedInterfaceRef = class ReflectedInterfaceRef extends ReflectedTypeRef {
	    get kind() { return 'interface'; }
	    get token() { return this.ref; }
	    get reflectedInterface() { return ReflectedClass.for(this.token); }
	    toString() { return `interface ${this.token.name}`; }
	    matches(ref) {
	        return this.token === ref.token;
	    }
	    matchesValue(value, errors = [], context) {
	        return ReflectedClass.for(this.ref).matchesValue(value);
	    }
	};
	ReflectedInterfaceRef = __decorate([
	    ReflectedTypeRef.Kind('interface')
	], ReflectedInterfaceRef);
	exports.ReflectedInterfaceRef = ReflectedInterfaceRef;
	let ReflectedLiteralRef = class ReflectedLiteralRef extends ReflectedTypeRef {
	    get kind() { return 'literal'; }
	    get value() { return this.ref; }
	    toString() { return JSON.stringify(this.value); }
	    matches(ref) {
	        return this.value === ref.value;
	    }
	    matchesValue(value, errors, context) {
	        return this.ref === value;
	    }
	};
	ReflectedLiteralRef = __decorate([
	    ReflectedTypeRef.Kind('literal')
	], ReflectedLiteralRef);
	exports.ReflectedLiteralRef = ReflectedLiteralRef;
	let ReflectedUnionRef = class ReflectedUnionRef extends ReflectedTypeRef {
	    get kind() { return 'union'; }
	    toString() { return `[${this.types.join(' | ')}]`; }
	    get types() {
	        if (this._types)
	            return this._types;
	        return this._types = (this.ref.t || []).map(t => ReflectedTypeRef.createFromRtRef(t));
	    }
	    matches(ref) {
	        if (this.types.length !== ref.types.length)
	            return false;
	        for (let type of this.types) {
	            if (!ref.types.some(x => type.equals(x)))
	                return false;
	        }
	        return true;
	    }
	    matchesValue(value, errors = [], context) {
	        return this.types.some(t => t.matchesValue(value, errors, context));
	    }
	};
	ReflectedUnionRef = __decorate([
	    ReflectedTypeRef.Kind('union')
	], ReflectedUnionRef);
	exports.ReflectedUnionRef = ReflectedUnionRef;
	let ReflectedIntersectionRef = class ReflectedIntersectionRef extends ReflectedTypeRef {
	    get kind() { return 'intersection'; }
	    toString() { return `${this.types.join(' & ')}`; }
	    get types() {
	        if (this._types)
	            return this._types;
	        return this._types = (this.ref.t || []).map(t => ReflectedTypeRef.createFromRtRef(t));
	    }
	    matches(ref) {
	        if (this.types.length !== ref.types.length)
	            return false;
	        for (let type of this.types) {
	            if (!ref.types.some(x => type.equals(x)))
	                return false;
	        }
	        return true;
	    }
	    matchesValue(value, errors = [], context) {
	        return this.types.every(t => t.matchesValue(value, errors, context));
	    }
	};
	ReflectedIntersectionRef = __decorate([
	    ReflectedTypeRef.Kind('intersection')
	], ReflectedIntersectionRef);
	exports.ReflectedIntersectionRef = ReflectedIntersectionRef;
	let ReflectedArrayRef = class ReflectedArrayRef extends ReflectedTypeRef {
	    get kind() { return 'array'; }
	    toString() { return `${this.elementType}[]`; }
	    get elementType() {
	        if (this._elementType)
	            return this._elementType;
	        return this._elementType = ReflectedTypeRef.createFromRtRef(this.ref.e);
	    }
	    matches(ref) {
	        return this.elementType.equals(ref.elementType);
	    }
	    matchesValue(value, errors, context) {
	        if (!Array.isArray(value)) {
	            errors.push(new TypeError(`Value should be an array`));
	            return false;
	        }
	        return value.every(value => this.elementType.matchesValue(value, errors, context));
	    }
	};
	ReflectedArrayRef = __decorate([
	    ReflectedTypeRef.Kind('array')
	], ReflectedArrayRef);
	exports.ReflectedArrayRef = ReflectedArrayRef;
	let ReflectedVoidRef = class ReflectedVoidRef extends ReflectedTypeRef {
	    get kind() { return 'void'; }
	    toString() { return `void`; }
	    matchesValue(value, errors, context) {
	        if (value !== void 0) {
	            errors.push(new Error(`Value must not be present`));
	            return false;
	        }
	        return true;
	    }
	};
	ReflectedVoidRef = __decorate([
	    ReflectedTypeRef.Kind('void')
	], ReflectedVoidRef);
	exports.ReflectedVoidRef = ReflectedVoidRef;
	let ReflectedNullRef = class ReflectedNullRef extends ReflectedTypeRef {
	    get kind() { return 'null'; }
	    toString() { return `null`; }
	    matchesValue(value, errors, context) {
	        return value === null;
	    }
	};
	ReflectedNullRef = __decorate([
	    ReflectedTypeRef.Kind('null')
	], ReflectedNullRef);
	exports.ReflectedNullRef = ReflectedNullRef;
	let ReflectedUndefinedRef = class ReflectedUndefinedRef extends ReflectedTypeRef {
	    get kind() { return 'undefined'; }
	    toString() { return `undefined`; }
	    matchesValue(value, errors, context) {
	        return value === undefined;
	    }
	};
	ReflectedUndefinedRef = __decorate([
	    ReflectedTypeRef.Kind('undefined')
	], ReflectedUndefinedRef);
	exports.ReflectedUndefinedRef = ReflectedUndefinedRef;
	let ReflectedFalseRef = class ReflectedFalseRef extends ReflectedTypeRef {
	    get kind() { return 'false'; }
	    toString() { return `false`; }
	    matchesValue(value, errors, context) {
	        return value === false;
	    }
	};
	ReflectedFalseRef = __decorate([
	    ReflectedTypeRef.Kind('false')
	], ReflectedFalseRef);
	exports.ReflectedFalseRef = ReflectedFalseRef;
	let ReflectedTrueRef = class ReflectedTrueRef extends ReflectedTypeRef {
	    get kind() { return 'true'; }
	    toString() { return `true`; }
	    matchesValue(value, errors, context) {
	        return value === true;
	    }
	};
	ReflectedTrueRef = __decorate([
	    ReflectedTypeRef.Kind('true')
	], ReflectedTrueRef);
	exports.ReflectedTrueRef = ReflectedTrueRef;
	let ReflectedUnknownRef = class ReflectedUnknownRef extends ReflectedTypeRef {
	    get kind() { return 'unknown'; }
	    toString() { return `unknown`; }
	    matchesValue(value, errors, context) {
	        return true;
	    }
	};
	ReflectedUnknownRef = __decorate([
	    ReflectedTypeRef.Kind('unknown')
	], ReflectedUnknownRef);
	exports.ReflectedUnknownRef = ReflectedUnknownRef;
	let ReflectedAnyRef = class ReflectedAnyRef extends ReflectedTypeRef {
	    get kind() { return 'any'; }
	    toString() { return `any`; }
	    matchesValue(value, errors, context) {
	        return true;
	    }
	};
	ReflectedAnyRef = __decorate([
	    ReflectedTypeRef.Kind('any')
	], ReflectedAnyRef);
	exports.ReflectedAnyRef = ReflectedAnyRef;
	let ReflectedTupleRef = class ReflectedTupleRef extends ReflectedTypeRef {
	    get kind() { return 'tuple'; }
	    toString() { return `[${this.elements.join(', ')}]`; }
	    get elements() {
	        if (this._elements)
	            return this._elements;
	        return this._elements = (this.ref.e || []).map(e => new ReflectedTupleElement(e));
	    }
	    matches(ref) {
	        if (this.elements.length !== ref.elements.length)
	            return false;
	        return this.elements.every((x, i) => x.name === ref.elements[i].name && x.type.equals(ref.elements[i].type));
	    }
	    matchesValue(value, errors, context) {
	        if (!Array.isArray(value)) {
	            errors.push(new Error(`Value must be an array`));
	            return false;
	        }
	        let array = value;
	        if (array.length !== this.elements.length) {
	            errors.push(new Error(`Array must have ${this.elements.length} values to match tuple type`));
	            return false;
	        }
	        return this.elements.every((v, i) => v.type.matchesValue(array[i], errors, context));
	    }
	};
	ReflectedTupleRef = __decorate([
	    ReflectedTypeRef.Kind('tuple')
	], ReflectedTupleRef);
	exports.ReflectedTupleRef = ReflectedTupleRef;
	let ReflectedGenericRef = class ReflectedGenericRef extends ReflectedTypeRef {
	    get kind() { return 'generic'; }
	    toString() { return `${this.baseType}<${this.typeParameters.join(', ')}>`; }
	    get baseType() {
	        if (this._baseType)
	            return this._baseType;
	        return this._baseType = ReflectedTypeRef.createFromRtRef(this.ref.t);
	    }
	    get typeParameters() {
	        if (this._typeParameters)
	            return this._typeParameters;
	        return this._typeParameters = this.ref.p.map(p => ReflectedTypeRef.createFromRtRef(p));
	    }
	    matches(ref) {
	        if (this.typeParameters.length !== ref.typeParameters.length)
	            return false;
	        return this.typeParameters.every((x, i) => x.equals(ref.typeParameters[i]));
	    }
	    matchesValue(value, errors, context) {
	        return this.baseType.matchesValue(value, errors, context);
	    }
	};
	ReflectedGenericRef = __decorate([
	    ReflectedTypeRef.Kind('generic')
	], ReflectedGenericRef);
	exports.ReflectedGenericRef = ReflectedGenericRef;
	let ReflectedEnumRef = class ReflectedEnumRef extends ReflectedTypeRef {
	    get kind() { return 'enum'; }
	    toString() { return `enum`; } // TODO: name of enum?
	    get enum() {
	        if (!this._enum)
	            this._enum = this.ref.e;
	        return this._enum;
	    }
	    get values() {
	        if (!this._values) {
	            this._values = Object.keys(this.enum)
	                .filter(x => !/^\d+$/.test(x))
	                .map(name => ({ name, value: this.enum[name] }));
	        }
	        return this._values;
	    }
	    matches(ref) {
	        return this.enum === ref.enum;
	    }
	    matchesValue(value, errors, context) {
	        return value in this.enum;
	    }
	};
	ReflectedEnumRef = __decorate([
	    ReflectedTypeRef.Kind('enum')
	], ReflectedEnumRef);
	exports.ReflectedEnumRef = ReflectedEnumRef;
	let ReflectedMappedRef = class ReflectedMappedRef extends ReflectedTypeRef {
	    get kind() { return 'mapped'; }
	    toString() { return `${this.baseType}<${this.typeParameters.join(', ')}>`; }
	    get baseType() {
	        if (this._baseType)
	            return this._baseType;
	        return this._baseType = ReflectedTypeRef.createFromRtRef(this.ref.t);
	    }
	    get typeParameters() {
	        if (this._typeParameters)
	            return this._typeParameters;
	        return this._typeParameters = this.ref.p.map(p => ReflectedTypeRef.createFromRtRef(p));
	    }
	    matches(ref) {
	        if (this.typeParameters.length !== ref.typeParameters.length)
	            return false;
	        return this.typeParameters.every((x, i) => x.equals(ref.typeParameters[i]));
	    }
	    matchesValue(value, errors, context) {
	        return this.baseType.matchesValue(value, errors, context);
	    }
	};
	ReflectedMappedRef = __decorate([
	    ReflectedTypeRef.Kind('mapped')
	], ReflectedMappedRef);
	exports.ReflectedMappedRef = ReflectedMappedRef;
	class ReflectedTupleElement {
	    constructor(ref) {
	        this.ref = ref;
	    }
	    toString() {
	        return `${this.name} : ${this.type}`;
	    }
	    get name() {
	        return this.ref.n;
	    }
	    get type() {
	        if (this._type)
	            return this._type;
	        return this._type = ReflectedTypeRef.createFromRtRef(this.ref.t);
	    }
	}
	exports.ReflectedTupleElement = ReflectedTupleElement;
	class ReflectedFlags {
	    constructor(flags) {
	        if (!flags)
	            flags = '';
	        Object.keys(this.flagToProperty)
	            .forEach(flag => this[this.flagToProperty[flag]] = flags.includes(flag));
	    }
	    toString() {
	        return Object.keys(this.propertyToFlag)
	            .map(property => this[property] ? this.propertyToFlag[property] : '')
	            .join('');
	    }
	}
	__decorate([
	    Flag(format$1.F_READONLY),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isReadonly", void 0);
	__decorate([
	    Flag(format$1.F_ABSTRACT),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isAbstract", void 0);
	__decorate([
	    Flag(format$1.F_PUBLIC),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isPublic", void 0);
	__decorate([
	    Flag(format$1.F_PRIVATE),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isPrivate", void 0);
	__decorate([
	    Flag(format$1.F_PROTECTED),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isProtected", void 0);
	__decorate([
	    Flag(format$1.F_PROPERTY),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isProperty", void 0);
	__decorate([
	    Flag(format$1.F_METHOD),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isMethod", void 0);
	__decorate([
	    Flag(format$1.F_CLASS),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isClass", void 0);
	__decorate([
	    Flag(format$1.F_INTERFACE),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isInterface", void 0);
	__decorate([
	    Flag(format$1.F_OPTIONAL),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isOptional", void 0);
	__decorate([
	    Flag(format$1.F_ASYNC),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isAsync", void 0);
	__decorate([
	    Flag(format$1.F_EXPORTED),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isExported", void 0);
	__decorate([
	    Flag(format$1.F_INFERRED),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isInferred", void 0);
	exports.ReflectedFlags = ReflectedFlags;
	/**
	 * Reflection data for a parameter
	 */
	class ReflectedParameter {
	    constructor(rawMetadata, index) {
	        this.rawMetadata = rawMetadata;
	        this.index = index;
	    }
	    /**
	     * Get the unmangled original name for this parameter
	     */
	    get name() {
	        return this.rawMetadata.n;
	    }
	    /**
	     * Get the reflected type of this parameter
	     */
	    get type() {
	        if (this._type)
	            return this._type;
	        return this._type = ReflectedTypeRef.createFromRtRef(this.rawMetadata.t());
	    }
	    /**
	     * Get flags that define aspects of this property.
	     */
	    get flags() {
	        if (this._flags)
	            return this._flags;
	        return this._flags = new ReflectedFlags(this.rawMetadata.f);
	    }
	    /**
	     * True if this parameter is optional
	     */
	    get isOptional() {
	        return this.flags.isOptional;
	    }
	    /**
	     * Retrieve the initializer for this parameter. Invoking the initializer produces the
	     * default value for the parameter. Caution: The initializer depends on the value of 'this'.
	     * Use evaluateInitializer() to properly invoke the initializer.
	     */
	    get initializer() {
	        return this.rawMetadata.v;
	    }
	    /**
	     * Evaluate the initializer for this parameter with the given value for 'this'. If not provided,
	     * 'this' is an empty object. This is suitable for constructor parameters but instance method parameters
	     * may reference properties of the object, and so getting the correct value may require passing an
	     * appropriate instance.
	     *
	     * @param thisObject
	     * @returns
	     */
	    evaluateInitializer(thisObject = {}) {
	        return this.initializer.apply(thisObject, []);
	    }
	}
	exports.ReflectedParameter = ReflectedParameter;
	/**
	 * Reflection data for a method parameter
	 */
	class ReflectedMethodParameter extends ReflectedParameter {
	    constructor(method, rawMetadata, index) {
	        super(rawMetadata, index);
	        this.method = method;
	        this.rawMetadata = rawMetadata;
	        this.index = index;
	    }
	    get parent() { return this.method; }
	    get class() { return this.method.class; }
	}
	exports.ReflectedMethodParameter = ReflectedMethodParameter;
	/**
	 * Reflection data for a method parameter
	 */
	class ReflectedFunctionParameter extends ReflectedParameter {
	    constructor(func, rawMetadata, index) {
	        super(rawMetadata, index);
	        this.func = func;
	        this.rawMetadata = rawMetadata;
	        this.index = index;
	    }
	    get parent() { return this.func; }
	}
	exports.ReflectedFunctionParameter = ReflectedFunctionParameter;
	/**
	 * Reflection data for a constructor parameter
	 */
	class ReflectedConstructorParameter extends ReflectedParameter {
	    constructor(reflectedClass, rawMetadata, index) {
	        super(rawMetadata, index);
	        this.reflectedClass = reflectedClass;
	        this.rawMetadata = rawMetadata;
	        this.index = index;
	        this._class = reflectedClass;
	    }
	    get parent() { return this.class; }
	    /**
	     * Retrieve the reflected class that this constructor parameter is defined on.
	     */
	    get class() {
	        return this._class;
	    }
	    /**
	     * True if this constructor parameter is declared readonly, meaning it is
	     * also an instance property of the class.
	     */
	    get isReadonly() {
	        return this.flags.isReadonly;
	    }
	    /**
	     * True if this constructor parameter is declared public, meaning it is
	     * also an instance property of the class.
	     */
	    get isPublic() {
	        return this.flags.isPublic;
	    }
	    /**
	     * True if this constructor parameter is declared protected, meaning it is
	     * also an instance property of the class.
	     */
	    get isProtected() {
	        return this.flags.isProtected;
	    }
	    /**
	     * True if this constructor parameter is declared private, meaning it is
	     * also an instance property of the class.
	     */
	    get isPrivate() {
	        return this.flags.isPrivate;
	    }
	    /**
	     * Get visibility of this constructor parameter. If the constructor
	     * parameter has no visibility modifiers, this is null.
	     */
	    get visibility() {
	        return this.isPublic ? 'public'
	            : this.isProtected ? 'protected'
	                : this.isPrivate ? 'private'
	                    : null;
	    }
	    /**
	     * True if the constructor parameter is also a property.
	     */
	    get isProperty() {
	        return this.visibility !== null || this.isReadonly;
	    }
	}
	exports.ReflectedConstructorParameter = ReflectedConstructorParameter;
	/**
	 * Reflection data for a class member
	 */
	class ReflectedMember {
	    constructor(reflectedClass, name, isStatic) {
	        this.name = name;
	        this.isStatic = isStatic;
	        this._class = reflectedClass;
	    }
	    /**
	     * Get the given metadata key for this member. This is equivalent to
	     * Reflect.getMetadata(key, this.host, this.name)
	     * @param key
	     * @returns
	     */
	    getMetadata(key) {
	        return Reflect.getMetadata(key, this.host, this.name);
	    }
	    /**
	     * Define a metadata key for this member. This is equivalent to
	     * Reflect.defineMetadata(key, value, this.host, this.name)
	     * @param key
	     * @returns
	     */
	    defineMetadata(key, value) {
	        Reflect.defineMetadata(key, value, this.host, this.name);
	        return value;
	    }
	    /**
	     * Get or define a metadata item for this member. If the key already exists, its
	     * value is returned without calling the passed function. Otherwise the passed function
	     * is called and its value is saved to the given metadata key.
	     *
	     * @param key The metadata key to fetch
	     * @param definer A function which will define the value of the metadata
	     * @returns The value of the existing metadata key or the new value returned by the definer function
	     *          which will also be defined as the appropriate metadata item on this member.
	     */
	    metadata(key, definer) {
	        if (this.hasMetadata(key))
	            return this.getMetadata(key);
	        let value = definer();
	        this.defineMetadata(key, value);
	        return value;
	    }
	    /**
	     * Check if a metadata key exists for this member. This is equivalent to
	     * Reflect.hasMetadata(key, this.host, this.name)
	     * @param key
	     * @returns
	     */
	    hasMetadata(key) {
	        return Reflect.hasMetadata(key, this.host, this.name);
	    }
	    /**
	     * Get the host object for this method. For static members this is the
	     * class constructor. For instance members this is the class's prototype.
	     */
	    get host() {
	        return this.isStatic ? this.class.class : this.class.prototype;
	    }
	    /**
	     * Get the reflected class that hosts this member
	     */
	    get class() {
	        return this._class;
	    }
	    /**
	     * Get the flags for this member. Includes modifiers and other properties about
	     * the member.
	     */
	    get flags() {
	        if (this._flags)
	            return this._flags;
	        return this._flags = new ReflectedFlags(this.getMetadata('rt:f'));
	    }
	    /**
	     * True if this member is abstract.
	     */
	    get isAbstract() {
	        return this.flags.isAbstract;
	    }
	    /**
	     * True if this member has private visibility.
	     */
	    get isPrivate() {
	        return this.flags.isPrivate;
	    }
	    /**
	     * True if this member has public visibility.
	     */
	    get isPublic() {
	        return this.visibility === 'public';
	    }
	    /**
	     * True if this member is specifically marked as public
	     * (as opposed to default visibility).
	     */
	    get isMarkedPublic() {
	        return this.flags.isPublic;
	    }
	    /**
	     * True if this member has protected visibility.
	     */
	    get isProtected() {
	        return this.flags.isProtected;
	    }
	    /**
	     * Get the visibility (accessibility) of this member.
	     * Can be 'public', 'protected', or 'private'
	     */
	    get visibility() {
	        return this.isMarkedPublic ? 'public'
	            : this.isProtected ? 'protected'
	                : this.isPrivate ? 'private'
	                    : 'public';
	    }
	    /**
	     * Whether this member is marked as optional.
	     */
	    get isOptional() {
	        return this.flags.isOptional;
	    }
	}
	exports.ReflectedMember = ReflectedMember;
	class ReflectedFunction {
	    constructor(func) {
	        this.func = func;
	    }
	    static for(func) {
	        if (typeof func !== 'function')
	            throw new TypeError(`Passed value is not a function`);
	        let existing = this.reflectedFunctions.get(func);
	        if (!existing) {
	            this.reflectedFunctions.set(func, existing = new ReflectedFunction(func));
	        }
	        return existing;
	    }
	    /**
	     * Create a new ReflectedClass instance for the given type without sharing. Used during testing.
	     * @internal
	     **/
	    static new(func) {
	        return new ReflectedFunction(func);
	    }
	    matchesValue(object, errors = [], context) {
	        return object === this.func;
	    }
	    /**
	     * Check if the function has the given metadata key defined. This is equivalent
	     * to Reflect.hasMetadata(key, value, this.func)
	     * @param key
	     * @returns
	     */
	    hasMetadata(key) {
	        return Reflect.hasMetadata(key, this.func);
	    }
	    /**
	     * Get the specified metadata key for this function. This is equivalent
	     * to Reflect.getMetadata(key, value, this.func)
	     * @param key
	     * @returns
	     */
	    getMetadata(key) {
	        return Reflect.getMetadata(key, this.func);
	    }
	    /**
	     * Define a metadata key for this function. This is equivalent
	     * to Reflect.defineMetadata(key, value, this.func)
	     * @param key The metadata key to define.
	     * @param value
	     */
	    defineMetadata(key, value) {
	        Reflect.defineMetadata(key, value, this.func);
	        return value;
	    }
	    /**
	     * Get or define a metadata item for this function. If the key already exists, its
	     * value is returned without calling the passed function. Otherwise the passed function
	     * is called and its value is saved to the given metadata key.
	     *
	     * @param key The metadata key to fetch
	     * @param definer A function which will define the value of the metadata
	     * @returns The value of the existing metadata key or the new value returned by the definer function
	     *          which will also be defined as the appropriate metadata item on this function.
	     */
	    metadata(key, definer) {
	        if (this.hasMetadata(key))
	            return this.getMetadata(key);
	        let value = definer();
	        this.defineMetadata(key, value);
	        return value;
	    }
	    /**
	     * Get the flags for this function.
	     */
	    get flags() {
	        if (this._flags)
	            return this._flags;
	        return this._flags = new ReflectedFlags(this.getMetadata('rt:f'));
	    }
	    /**
	     * @internal
	     */
	    get rawParameterMetadata() {
	        if (this._rawParameterMetadata)
	            return this._rawParameterMetadata;
	        return this._rawParameterMetadata = this.getMetadata('rt:p');
	    }
	    /**
	     * Names of the parameters for this function.
	     */
	    get parameterNames() {
	        return this.rawParameterMetadata.map(x => x.n);
	    }
	    /**
	     * Types for the parameter types of this function.
	     */
	    get parameterTypes() {
	        if (this._parameterTypes !== undefined)
	            return this._parameterTypes;
	        if (this.rawParameterMetadata !== undefined) {
	            return this._parameterTypes = this.rawParameterMetadata.map(param => {
	                return param.t ? ReflectedTypeRef.createFromRtRef(param.t()) : ReflectedTypeRef.createUnknown();
	            });
	        }
	        else if (this.hasMetadata('design:paramtypes')) {
	            let params = this.getMetadata('design:paramtypes');
	            return this._parameterTypes = (params || []).map(t => ReflectedTypeRef.createFromRtRef(() => t));
	        }
	        return [];
	    }
	    /**
	     * Retrieve the set of reflected parameters for this method.
	     */
	    get parameters() {
	        if (this._parameters)
	            return this._parameters;
	        return this._parameters = this.rawParameterMetadata.map((x, i) => new ReflectedFunctionParameter(this, x, i));
	    }
	    /**
	     * Get the parameter with the specified name
	     * @param name
	     * @returns The reflected parameter
	     */
	    getParameter(name) {
	        return this.parameters.find(x => x.name === name);
	    }
	    /**
	     * Retrieve the return type of this function.
	     */
	    get returnType() {
	        if (this._returnType !== undefined)
	            return this._returnType;
	        let typeResolver = this.getMetadata('rt:t');
	        if (!typeResolver && this.hasMetadata('design:returntype')) {
	            let designReturnType = this.getMetadata('design:returntype');
	            typeResolver = () => (designReturnType || null);
	        }
	        if (!typeResolver)
	            return ReflectedTypeRef.createUnknown();
	        return this._returnType = ReflectedTypeRef.createFromRtRef(typeResolver());
	    }
	    /**
	     * True if the return type was inferred using the Typescript type checker. False if
	     * the return type was defined explicitly.
	     */
	    get returnTypeInferred() {
	        return this.flags.isInferred;
	    }
	    /**
	     * True if this function is declared as async.
	     */
	    get isAsync() {
	        return this.flags.isAsync;
	    }
	}
	exports.ReflectedFunction = ReflectedFunction;
	ReflectedFunction.reflectedFunctions = new WeakMap();
	/**
	 * Reflection data for a class method
	 */
	class ReflectedMethod extends ReflectedMember {
	    matchesValue(object, errors = [], context) {
	        return object === this.func;
	    }
	    get func() {
	        if (this.isStatic)
	            return this.class[this.name];
	        else
	            return this.class.prototype[this.name];
	    }
	    /**
	     * @internal
	     */
	    get rawParameterMetadata() {
	        if (this._rawParameterMetadata)
	            return this._rawParameterMetadata;
	        return this._rawParameterMetadata = this.getMetadata('rt:p');
	    }
	    /**
	     * Retrieve the reflected method for the given method function.
	     * If the function is not a method, a TypeError is thrown.
	     * @param method
	     */
	    static for(method) {
	        if (!hasAnyFlag(method, [format$1.F_METHOD]))
	            throw new TypeError(`The function is not a method, or the class is not annotated with runtime type metadata`);
	        if (!Reflect.hasMetadata('rt:h', method))
	            throw new TypeError(`The function is a method, but is not annotated with a host class`);
	        let host = Reflect.getMetadata('rt:h', method);
	        if (!host)
	            throw new TypeError(`The method has a defined host, but it is null/undefined`);
	        return ReflectedClass.for(host()).getMethod(method.name);
	    }
	    /**
	     * Retrieve an array with the parameter names for this method.
	     */
	    get parameterNames() {
	        return this.rawParameterMetadata.map(x => x.n);
	    }
	    /**
	     * Retrieve an array with the parameter types for this method.
	     */
	    get parameterTypes() {
	        if (this._parameterTypes !== undefined)
	            return this._parameterTypes;
	        if (this.rawParameterMetadata !== undefined) {
	            return this._parameterTypes = this.rawParameterMetadata.map(param => {
	                return param.t ? ReflectedTypeRef.createFromRtRef(param.t()) : ReflectedTypeRef.createUnknown();
	            });
	        }
	        else if (this.hasMetadata('design:paramtypes')) {
	            let params = this.getMetadata('design:paramtypes');
	            return this._parameterTypes = (params || []).map(t => ReflectedTypeRef.createFromRtRef(() => t));
	        }
	        return [];
	    }
	    /**
	     * Retrieve the set of reflected parameters for this method.
	     */
	    get parameters() {
	        if (this._parameters)
	            return this._parameters;
	        return this._parameters = this.rawParameterMetadata.map((x, i) => new ReflectedMethodParameter(this, x, i));
	    }
	    /**
	     * Get a reflected parameter by name
	     * @param name
	     * @returns The reflected parameter
	     */
	    getParameter(name) {
	        return this.parameters.find(x => x.name === name);
	    }
	    /**
	     * Get the return type of this method.
	     */
	    get returnType() {
	        if (this._returnType !== undefined)
	            return this._returnType;
	        let typeResolver = this.getMetadata('rt:t');
	        if (!typeResolver && this.hasMetadata('design:returntype')) {
	            let designReturnType = this.getMetadata('design:returntype');
	            typeResolver = () => (designReturnType || null);
	        }
	        if (!typeResolver)
	            return ReflectedTypeRef.createUnknown();
	        return this._returnType = ReflectedTypeRef.createFromRtRef(typeResolver());
	    }
	    /**
	     * True if the return type was inferred using the Typescript type checker. False if
	     * the return type was defined explicitly.
	     */
	    get returnTypeInferred() {
	        return this.flags.isInferred;
	    }
	    /**
	     * True if this method is declared as async.
	     */
	    get isAsync() {
	        return this.flags.isAsync;
	    }
	}
	exports.ReflectedMethod = ReflectedMethod;
	/**
	 * Represents a reflected property of a class or interface.
	 */
	class ReflectedProperty extends ReflectedMember {
	    /**
	     * Get the type of this property.
	     */
	    get type() {
	        if (this._type !== undefined)
	            return this._type;
	        let typeResolver;
	        if (this.hasMetadata('rt:t')) {
	            typeResolver = this.getMetadata('rt:t');
	        }
	        else if (this.hasMetadata('design:type')) {
	            let designType = this.getMetadata('design:type');
	            typeResolver = () => designType;
	        }
	        if (!typeResolver)
	            return this._type = ReflectedTypeRef.createUnknown();
	        return this._type = ReflectedTypeRef.createFromRtRef(typeResolver());
	    }
	    /**
	     * True if this property is marked readonly.
	     */
	    get isReadonly() {
	        return this.flags.isReadonly;
	    }
	    /**
	     * Check if the given value matches the type of this property, and would
	     * thus be a valid assignment.
	     * @param object
	     * @param errors
	     * @returns
	     */
	    matchesValue(object, errors = []) {
	        return this.type.matchesValue(object, errors);
	    }
	}
	exports.ReflectedProperty = ReflectedProperty;
	function getFlags(value) {
	    if (!Reflect.hasMetadata('rt:f', value))
	        return '';
	    let flagsValue = Reflect.getMetadata('rt:f', value);
	    if (typeof flagsValue === 'string')
	        return flagsValue;
	    return '';
	}
	function hasAnyFlag(value, desiredFlags) {
	    let flags = getFlags(value);
	    return desiredFlags.some(x => flags.includes(x));
	}
	/**
	 * Provides access to the known runtime type metadata for a particular class
	 * or Interface value (as obtained by reify<InterfaceT>()).
	 */
	let ReflectedClass = ReflectedClass_1 = class ReflectedClass {
	    /**
	     * Constructs a new ReflectedClass. Use ReflectedClass.for() to obtain a ReflectedClass.
	     */
	    constructor(klass) {
	        this._hasPropertyNamesMeta = false;
	        this._hasStaticPropertyNameMeta = false;
	        this._dynamicStaticProperties = new Map();
	        this._dynamicProperties = new Map();
	        this._class = klass;
	    }
	    /**
	     * Obtain a ReflectedClass for the given class constructor, Interface value or instance.
	     * @param constructorOrValue Can be a class constructor, Interface, or an instance of a class (in which case the
	     *                           instance's constructor will be used)
	     * @returns The ReflectedClass.
	     */
	    static for(constructorOrValue) {
	        let flags = getFlags(constructorOrValue);
	        if (flags.includes(format$1.F_INTERFACE))
	            return this.forConstructorOrInterface(constructorOrValue);
	        else if (flags.includes(format$1.F_CLASS))
	            return this.forConstructorOrInterface(constructorOrValue);
	        else if (flags.includes(format$1.F_FUNCTION))
	            throw new TypeError(`Value is a function, use ReflectedFunction.for() or reflect(func) instead`);
	        // Heuristic based on shape
	        if (typeof constructorOrValue === 'function' || ('name' in constructorOrValue && 'prototype' in constructorOrValue && typeof constructorOrValue.identity === 'symbol'))
	            return this.forConstructorOrInterface(constructorOrValue);
	        // Assume it's an instance of a class
	        return this.forConstructorOrInterface(constructorOrValue.constructor);
	    }
	    /**
	     * Create a new ReflectedClass instance for the given type without sharing. Used during testing.
	     * @internal
	     **/
	    static new(constructorOrInterface) {
	        return new ReflectedClass_1(constructorOrInterface);
	    }
	    static forConstructorOrInterface(constructorOrInterface) {
	        let existing = this.reflectedClasses.get(constructorOrInterface);
	        if (!existing) {
	            this.reflectedClasses.set(constructorOrInterface, existing = new ReflectedClass_1(constructorOrInterface));
	        }
	        return existing;
	    }
	    /**
	     * Get the interfaces that this class implements.
	     */
	    get interfaces() {
	        if (this._interfaces !== undefined)
	            return this._interfaces;
	        if (this.hasMetadata('rt:i')) {
	            return this._interfaces = this.getMetadata('rt:i')
	                .map(resolver => resolver())
	                .filter(x => !!x)
	                .map(ref => ReflectedTypeRef.createFromRtRef(ref));
	        }
	        return [];
	    }
	    /**
	     * Check if this class implements the given interface. The parameter can be a reified interface
	     * reference or a class reference. Note that implementing a class is not the same as extending a class.
	     *
	     * @param interfaceType
	     * @returns boolean
	     */
	    implements(interfaceType) {
	        return !!this.interfaces.find(i => typeof interfaceType === 'function' ? i.isClass(interfaceType) : i.isInterface(interfaceType));
	    }
	    /**
	     * Check if the given value matches the shape of this type, and thus would be a valid assignment.
	     * @param object
	     * @param errors
	     * @returns
	     */
	    matchesValue(object, errors = []) {
	        if (object === null || object === void 0) {
	            errors.push(new Error(`Value is undefined`));
	            return false;
	        }
	        if (typeof object !== 'object') {
	            errors.push(new Error(`Value must be an object`));
	            return false;
	        }
	        let matches = true;
	        if (globalThis.RTTI_TRACE === true)
	            console.log(`Type checking value against type '${this.class.name}'`);
	        for (let prop of this.properties) {
	            let hasValue = prop.name in object;
	            let value = object[prop.name];
	            if (!hasValue && !prop.isOptional) {
	                errors.push(new Error(`Property '${prop.name}' is missing in value`));
	                matches = false;
	            }
	            if (!hasValue)
	                continue;
	            let propMatch = prop.matchesValue(value, errors);
	            if (globalThis.RTTI_TRACE === true)
	                console.log(` - ${this.class.name}#${prop.name} : ${prop.type} | valid(${JSON.stringify(value)}) => ${propMatch}`);
	            matches && (matches = propMatch);
	        }
	        return matches;
	    }
	    /**
	     * Get the prototype object for this reflected class.
	     */
	    get prototype() {
	        return this._class.prototype;
	    }
	    /**
	     * Get the class constructor for this reflected class.
	     */
	    get class() {
	        return this._class;
	    }
	    /**
	     * Get the reflected superclass for this class.
	     */
	    get super() {
	        var _a, _b;
	        if (this._super !== undefined)
	            return this._super;
	        let parentClass = (_b = (_a = Object.getPrototypeOf(this.class.prototype)) === null || _a === void 0 ? void 0 : _a.constructor) !== null && _b !== void 0 ? _b : Object;
	        if (parentClass === Object)
	            return this._super = null;
	        else
	            return this._super = ReflectedClass_1.for(parentClass);
	    }
	    /**
	     * Check if the function has the given metadata key defined. This is equivalent
	     * to Reflect.hasMetadata(key, this.class)
	     * @param key
	     * @returns
	     */
	    hasMetadata(key) {
	        return Reflect.hasMetadata(key, this.class);
	    }
	    /**
	     * Get the specified metadata key. This is equivalent to Reflect.getMetadata(key, this.class).
	     * @param key
	     * @returns
	     */
	    getMetadata(key) {
	        return Reflect.getMetadata(key, this.class);
	    }
	    /**
	     * Define a metadata key on this class. This is equivalent to Reflect.defineMetadata(key, value, this.class).
	     * @param key
	     * @param value
	     * @returns
	     */
	    defineMetadata(key, value) {
	        Reflect.defineMetadata(key, value, this.class);
	        return value;
	    }
	    /**
	     * Get or define a metadata item for this class/interface. If the key already exists, its
	     * value is returned without calling the passed function. Otherwise the passed function
	     * is called and its value is saved to the given metadata key.
	     *
	     * @param key The metadata key to fetch
	     * @param definer A function which will define the value of the metadata
	     * @returns The value of the existing metadata key or the new value returned by the definer function
	     *          which will also be defined as the appropriate metadata item on this class/interface.
	     */
	    metadata(key, definer) {
	        if (this.hasMetadata(key))
	            return this.getMetadata(key);
	        let value = definer();
	        this.defineMetadata(key, value);
	        return value;
	    }
	    /**
	     * Define a metadata key on this class's prototype object. This is equivalent to Reflect.defineMetadata(key, value, this.class.prototype)
	     * @param key
	     * @param value
	     * @returns
	     */
	    definePrototypeMetadata(key, value) {
	        Reflect.defineMetadata(key, value, this.class.prototype);
	        return value;
	    }
	    /**
	     * Retrieve the set of property names that are defined directly on this class, excluding
	     * those which are inherited.
	     */
	    get ownPropertyNames() {
	        if (this._ownPropertyNames)
	            return this._ownPropertyNames;
	        let propertyNames;
	        if (this.hasMetadata('rt:P')) {
	            propertyNames = this.getMetadata('rt:P');
	            this._hasPropertyNamesMeta = !!propertyNames;
	        }
	        else {
	            propertyNames = Object.getOwnPropertyNames(this.class.prototype)
	                .filter(x => x !== 'constructor')
	                .filter(x => {
	                // All properties which have `get` defined must be considered properties, not methods.
	                // We need to avoid executing getters inadvertently while determining the type of the property.
	                // https://github.com/typescript-rtti/typescript-rtti/issues/52
	                let descriptor = Object.getOwnPropertyDescriptor(this.class.prototype, x);
	                if (descriptor.get)
	                    return true;
	                return typeof this.class.prototype[x] === 'function';
	            });
	        }
	        return this._ownPropertyNames = propertyNames || [];
	    }
	    /**
	     * Retrieve the set of method names that are defined directly on this class, excluding
	     * those which are inherited.
	     */
	    get ownMethodNames() {
	        if (this._ownMethodNames)
	            return this._ownMethodNames;
	        let methodNames = this.getMetadata('rt:m');
	        if (!methodNames) {
	            methodNames = Object.getOwnPropertyNames(this.class.prototype)
	                .filter(x => x !== 'constructor')
	                .filter(x => {
	                // All properties which have `get` defined must be considered properties, not methods.
	                // We need to avoid executing getters inadvertently while determining the type of the property.
	                // https://github.com/typescript-rtti/typescript-rtti/issues/52
	                let descriptor = Object.getOwnPropertyDescriptor(this.class.prototype, x);
	                if (descriptor.get)
	                    return false;
	                return typeof this.class.prototype[x] === 'function';
	            });
	        }
	        return this._ownMethodNames = methodNames;
	    }
	    /**
	     * Retrieve the set of static property names that are defined directly on this class, excluding
	     * those which are inherited. Always empty for interfaces.
	     */
	    get ownStaticPropertyNames() {
	        if (this._ownStaticPropertyNames)
	            return this._ownStaticPropertyNames;
	        let ownStaticPropertyNames = this.getMetadata('rt:SP');
	        this._hasStaticPropertyNameMeta = !!ownStaticPropertyNames;
	        if (!ownStaticPropertyNames) {
	            this._hasStaticPropertyNameMeta = false;
	            ownStaticPropertyNames = Object.getOwnPropertyNames(this.class)
	                .filter(x => !['length', 'prototype', 'name'].includes(x))
	                .filter(x => typeof this.class[x] !== 'function');
	        }
	        return this._ownStaticPropertyNames = ownStaticPropertyNames;
	    }
	    /**
	     * Retrieve the set of static method names that are defined directly on this class,
	     * excluding those which are inherited. Always empty for interfaces
	     */
	    get ownStaticMethodNames() {
	        if (this._ownStaticMethodNames)
	            return this._ownStaticMethodNames;
	        let ownStaticMethodNames = this.getMetadata('rt:Sm');
	        if (!ownStaticMethodNames) {
	            ownStaticMethodNames = Object.getOwnPropertyNames(this.class)
	                .filter(x => !['length', 'prototype', 'name'].includes(x))
	                .filter(x => typeof this.class[x] === 'function');
	        }
	        return this._ownStaticMethodNames = ownStaticMethodNames;
	    }
	    /**
	     * Retrieve the set of flags for this class/interface. Use this to check for modifiers or other properties
	     * of the class/interface.
	     */
	    get flags() {
	        if (this._flags)
	            return this._flags;
	        return this._flags = new ReflectedFlags(this.getMetadata('rt:f'));
	    }
	    /**
	     * True if the class is marked abstract.
	     */
	    get isAbstract() {
	        return this.flags.isAbstract;
	    }
	    /**
	     * Get the instance method names for this reflected class/interface.
	     */
	    get methodNames() {
	        if (this._methodNames)
	            return this._methodNames;
	        if (this.super) {
	            return this._methodNames = this.super.methodNames.concat(this.ownMethodNames);
	        }
	        else {
	            return this._methodNames = this.ownMethodNames;
	        }
	    }
	    /**
	     * Get the static property names defined for this reflected class. Always empty for interfaces.
	     */
	    get staticPropertyNames() {
	        if (this._staticPropertyNames)
	            return this._staticPropertyNames;
	        if (this.super) {
	            return this._staticPropertyNames = this.super.staticPropertyNames.concat(this.ownStaticPropertyNames);
	        }
	        else {
	            return this._staticPropertyNames = this.ownStaticPropertyNames;
	        }
	    }
	    /**
	     * Retrieve an array of the names of static methods defined on this reflected class.
	     * Always empty for interfaces.
	     */
	    get staticMethodNames() {
	        if (this._staticMethodNames)
	            return this._staticMethodNames;
	        if (this.super) {
	            return this._staticMethodNames = this.super.staticMethodNames.concat(this.ownStaticMethodNames);
	        }
	        else {
	            return this._staticMethodNames = this.ownStaticMethodNames;
	        }
	    }
	    /**
	     * Retrieve an array of the names of instance properties defined on this class/interface
	     */
	    get propertyNames() {
	        if (this._propertyNames)
	            return this._propertyNames;
	        if (this.super) {
	            return this._propertyNames = this.super.propertyNames.concat(this.ownPropertyNames);
	        }
	        else {
	            return this._propertyNames = this.ownPropertyNames;
	        }
	    }
	    /**
	     * Retrieve the set of reflected methods defined directly on this class/interface.
	     */
	    get ownMethods() {
	        if (this._ownMethods)
	            return this._ownMethods;
	        return this._ownMethods = this.ownMethodNames.map(name => new ReflectedMethod(this, name, false));
	    }
	    /**
	     * Retrieve the set of reflected static properties defined directly on this class. Always empty
	     * for interfaces.
	     */
	    get ownStaticProperties() {
	        if (this._ownStaticProperties)
	            return this._ownStaticProperties;
	        return this._ownStaticProperties = this.staticPropertyNames.map(x => new ReflectedProperty(this, x, true));
	    }
	    /**
	     * Retrieve the set of reflected static methods defined directly on this class. Always
	     * empty for interfaces.
	     */
	    get ownStaticMethods() {
	        if (this._ownStaticMethods)
	            return this._ownStaticMethods;
	        return this._ownStaticMethods = this.ownStaticMethodNames.map(name => new ReflectedMethod(this, name, true));
	    }
	    /**
	     * Retrieve the set of reflected instance methods defined on this class/interface.
	     */
	    get methods() {
	        if (this._methods)
	            return this._methods;
	        if (this.super)
	            return this._methods = this.super.methods.concat(this.ownMethods);
	        else
	            return this._methods = this.ownMethods;
	    }
	    /**
	     * Retrieve the set of reflected static properties defined on this class. Always
	     * empty for interfaces.
	     */
	    get staticProperties() {
	        if (this._staticProperties)
	            return this._staticProperties;
	        if (this.super)
	            return this._staticProperties = this.super.staticProperties.concat(this.ownStaticProperties);
	        else
	            return this._staticProperties = this.ownStaticProperties;
	    }
	    /**
	     * Retrieve the set of reflected static methods defined on this class. Always
	     * empty for interfaces
	     */
	    get staticMethods() {
	        if (this._staticMethods)
	            return this._staticMethods;
	        if (this.super)
	            return this._staticMethods = this.super.staticMethods.concat(this.ownStaticMethods);
	        else
	            return this._staticMethods = this.ownStaticMethods;
	    }
	    /**
	     * Retrieve the set of reflected instance properties defined directly on this class/interface
	     */
	    get ownProperties() {
	        if (this._ownProperties)
	            return this._ownProperties;
	        return this._ownProperties = this.ownPropertyNames.map(name => new ReflectedProperty(this, name, false));
	    }
	    /**
	     * Retrieve the set of reflected instance methods defined on this class/interface
	     */
	    get properties() {
	        if (this._properties)
	            return this._properties;
	        if (this.super)
	            return this._properties = this.super.properties.concat(this.ownProperties);
	        else
	            return this._properties = this.ownProperties;
	    }
	    get rawParameterMetadata() {
	        if (this._rawParameterMetadata)
	            return this._rawParameterMetadata;
	        let rawParams = this.getMetadata('rt:p');
	        if (rawParams === void 0 && this.hasMetadata('design:paramtypes')) {
	            let types = this.getMetadata('design:paramtypes');
	            let names = (0, get_parameter_names_1.getParameterNames)(this.class);
	            rawParams = names.map((n, i) => ({ n, t: () => types[i] }));
	        }
	        return this._rawParameterMetadata = rawParams || [];
	    }
	    /**
	     * Retrieve an array of the parameter names for this class's constructor.
	     */
	    get parameterNames() {
	        return this.rawParameterMetadata.map(x => x.n);
	    }
	    /**
	     * Retrieve an array of the types for the parameters of this class's
	     * constructor.
	     */
	    get parameterTypes() {
	        return this.rawParameterMetadata.map(x => x.t);
	    }
	    /**
	     * Retrieve the set of reflected parameters for this class's constructor.
	     */
	    get parameters() {
	        if (this._parameters)
	            return this._parameters;
	        return this._parameters = this.rawParameterMetadata.map((x, i) => new ReflectedConstructorParameter(this, x, i));
	    }
	    /**
	     * Get a reflected constructor parameter by name.
	     * @param name
	     * @returns
	     */
	    getParameter(name) {
	        return this.parameters.find(x => x.name === name);
	    }
	    /**
	     * Get a reflected instance method (declared directly on this class) by name
	     * @param name
	     * @returns
	     */
	    getOwnMethod(name) {
	        return this.ownMethods.find(x => x.name === name);
	    }
	    /**
	     * Get a reflected instance method by name
	     * @param name
	     * @returns
	     */
	    getMethod(name) {
	        return this.methods.find(x => x.name === name);
	    }
	    /**
	     * Get a reflected static method by name
	     * @param name
	     * @returns
	     */
	    getStaticMethod(name) {
	        return this.staticMethods.find(x => x.name === name);
	    }
	    /**
	     * Get a reflected static property (declared directly on this class) by name
	     * @param name
	     * @returns
	     */
	    getOwnStaticProperty(name) {
	        let matchingProp = this.ownStaticProperties.find(x => x.name === name);
	        if (matchingProp)
	            return matchingProp;
	        if (!this._hasStaticPropertyNameMeta) {
	            if (this._dynamicStaticProperties.has(name))
	                return this._dynamicStaticProperties.get(name);
	            let prop = new ReflectedProperty(this, name, true);
	            this._dynamicStaticProperties.set(name, prop);
	            return prop;
	        }
	    }
	    /**
	     * Get a reflected static property by name
	     * @param name
	     * @returns
	     */
	    getStaticProperty(name) {
	        let matchingProp = this.staticProperties.find(x => x.name === name);
	        if (matchingProp)
	            return matchingProp;
	        if (!this._hasStaticPropertyNameMeta) {
	            if (this._dynamicStaticProperties.has(name))
	                return this._dynamicStaticProperties.get(name);
	            let prop = new ReflectedProperty(this, name, true);
	            this._dynamicStaticProperties.set(name, prop);
	            return prop;
	        }
	    }
	    /**
	     * Get a reflected instance property (declared directly on this class) by name
	     * @param name
	     * @returns
	     */
	    getOwnProperty(name) {
	        let matchingProp = this.ownProperties.find(x => x.name === name);
	        if (matchingProp)
	            return matchingProp;
	        if (!this._hasPropertyNamesMeta) {
	            if (this._dynamicProperties.has(name))
	                return this._dynamicProperties.get(name);
	            let prop = new ReflectedProperty(this, name, false);
	            this._dynamicProperties.set(name, prop);
	            return prop;
	        }
	    }
	    /**
	     * Get a reflected instance property by name
	     * @param name
	     * @returns
	     */
	    getProperty(name) {
	        let matchingProp = this.properties.find(x => x.name === name);
	        if (matchingProp)
	            return matchingProp;
	        if (!this._hasPropertyNamesMeta) {
	            if (this._dynamicProperties.has(name))
	                return this._dynamicProperties.get(name);
	            let prop = new ReflectedProperty(this, name, false);
	            this._dynamicProperties.set(name, prop);
	            return prop;
	        }
	    }
	};
	ReflectedClass.reflectedClasses = new WeakMap();
	ReflectedClass = ReflectedClass_1 = __decorate([
	    (0, sealed_1.Sealed)(),
	    __metadata("design:paramtypes", [Object])
	], ReflectedClass);
	exports.ReflectedClass = ReflectedClass;
	/**
	 * Returns true if the class (or the class of the given value) implement the given interface.
	 * Note that interfaceType can be a class constructor. Implementing a class is not the same as extending a class.
	 *
	 * @param value The value to check. Can be a constructor or a value (whose constructor will be checked)
	 * @param interfaceType The interface type to use. Can be a class constructor or an Interface object.
	 * @returns True if the interface is implemented
	 */
	function implementsInterface(value, interfaceType) {
	    if (value === null || value === undefined || !['object', 'function'].includes(typeof value))
	        return false;
	    if (interfaceType === null || interfaceType === undefined)
	        throw new TypeError(`Interface type must not be undefined`);
	    if (typeof value === 'object')
	        return ReflectedClass.for(value.constructor).implements(interfaceType);
	    else if (typeof value === 'function')
	        return ReflectedClass.for(value).implements(interfaceType);
	}
	exports.implementsInterface = implementsInterface;
	/**
	 * Returns true if the given value matches the shape of the interface / class passed as interfaceType.
	 *
	 * @param value
	 * @param interfaceType
	 * @returns True if the value is the correct shape
	 */
	function matchesShape(value, interfaceType) {
	    if (interfaceType === null || interfaceType === undefined)
	        throw new TypeError(`Interface type must not be undefined`);
	    return ReflectedClass.for(interfaceType).matchesValue(value);
	}
	exports.matchesShape = matchesShape;
	/**
	 * @rtti:callsite 1
	 */
	function reflect(value = NotProvided, callSite) {
	    if (value === NotProvided && !callSite) {
	        throw new Error(`reflect<T>() can only be used when project is built with the typescript-rtti transformer`);
	    }
	    if (!value)
	        throw new TypeError(`Could not reflect on null/undefined`);
	    if (isCallSite(value))
	        return new ReflectedCallSite(value);
	    if (value === NotProvided && isCallSite(callSite))
	        return new ReflectedCallSite(callSite).typeParameters[0];
	    if (!['object', 'function'].includes(typeof value)) {
	        // Primitive value
	        return reflect(value.constructor);
	    }
	    let flags = getFlags(value);
	    if (flags.includes(format$1.F_FUNCTION))
	        return ReflectedFunction.for(value);
	    if (flags.includes(format$1.F_METHOD))
	        return ReflectedMethod.for(value);
	    if (typeof value === 'function' && !value.prototype)
	        return ReflectedFunction.for(value);
	    return ReflectedClass.for(value);
	}
	exports.reflect = reflect;
	class ReflectedCallSite {
	    constructor(callSite) {
	        this.callSite = callSite;
	    }
	    get parameters() {
	        if (!this._parameters)
	            this._parameters = this.callSite.p.map(x => ReflectedTypeRef.createFromRtRef(x));
	        return this._parameters;
	    }
	    get typeParameters() {
	        if (!this._typeParameters) {
	            this._typeParameters = this.callSite.tp.map(x => ReflectedTypeRef.createFromRtRef(x));
	        }
	        return this._typeParameters;
	    }
	}
	exports.ReflectedCallSite = ReflectedCallSite;

	}(reflect$1));

	(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(reflect$1, exports);

	}(lib));

	(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(lib, exports);

	}(dist$7));

	var common = {};

	(function (exports) {
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(format, exports);

	}(common));

	var events$5 = {exports: {}};

	var R$5 = typeof Reflect === 'object' ? Reflect : null;
	var ReflectApply$5 = R$5 && typeof R$5.apply === 'function'
	  ? R$5.apply
	  : function ReflectApply(target, receiver, args) {
	    return Function.prototype.apply.call(target, receiver, args);
	  };

	var ReflectOwnKeys$5;
	if (R$5 && typeof R$5.ownKeys === 'function') {
	  ReflectOwnKeys$5 = R$5.ownKeys;
	} else if (Object.getOwnPropertySymbols) {
	  ReflectOwnKeys$5 = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target)
	      .concat(Object.getOwnPropertySymbols(target));
	  };
	} else {
	  ReflectOwnKeys$5 = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target);
	  };
	}

	function ProcessEmitWarning$5(warning) {
	  if (console && console.warn) console.warn(warning);
	}

	var NumberIsNaN$5 = Number.isNaN || function NumberIsNaN(value) {
	  return value !== value;
	};

	function EventEmitter$1$4() {
	  EventEmitter$1$4.init.call(this);
	}
	events$5.exports = EventEmitter$1$4;
	events$5.exports.once = once$5;

	// Backwards-compat with node 0.10.x
	EventEmitter$1$4.EventEmitter = EventEmitter$1$4;

	EventEmitter$1$4.prototype._events = undefined;
	EventEmitter$1$4.prototype._eventsCount = 0;
	EventEmitter$1$4.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	var defaultMaxListeners$5 = 10;

	function checkListener$5(listener) {
	  if (typeof listener !== 'function') {
	    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
	  }
	}

	Object.defineProperty(EventEmitter$1$4, 'defaultMaxListeners', {
	  enumerable: true,
	  get: function() {
	    return defaultMaxListeners$5;
	  },
	  set: function(arg) {
	    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN$5(arg)) {
	      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
	    }
	    defaultMaxListeners$5 = arg;
	  }
	});

	EventEmitter$1$4.init = function() {

	  if (this._events === undefined ||
	      this._events === Object.getPrototypeOf(this)._events) {
	    this._events = Object.create(null);
	    this._eventsCount = 0;
	  }

	  this._maxListeners = this._maxListeners || undefined;
	};

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter$1$4.prototype.setMaxListeners = function setMaxListeners(n) {
	  if (typeof n !== 'number' || n < 0 || NumberIsNaN$5(n)) {
	    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
	  }
	  this._maxListeners = n;
	  return this;
	};

	function _getMaxListeners$5(that) {
	  if (that._maxListeners === undefined)
	    return EventEmitter$1$4.defaultMaxListeners;
	  return that._maxListeners;
	}

	EventEmitter$1$4.prototype.getMaxListeners = function getMaxListeners() {
	  return _getMaxListeners$5(this);
	};

	EventEmitter$1$4.prototype.emit = function emit(type) {
	  var args = [];
	  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
	  var doError = (type === 'error');

	  var events = this._events;
	  if (events !== undefined)
	    doError = (doError && events.error === undefined);
	  else if (!doError)
	    return false;

	  // If there is no 'error' event listener then throw.
	  if (doError) {
	    var er;
	    if (args.length > 0)
	      er = args[0];
	    if (er instanceof Error) {
	      // Note: The comments on the `throw` lines are intentional, they show
	      // up in Node's output if this results in an unhandled exception.
	      throw er; // Unhandled 'error' event
	    }
	    // At least give some kind of context to the user
	    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
	    err.context = er;
	    throw err; // Unhandled 'error' event
	  }

	  var handler = events[type];

	  if (handler === undefined)
	    return false;

	  if (typeof handler === 'function') {
	    ReflectApply$5(handler, this, args);
	  } else {
	    var len = handler.length;
	    var listeners = arrayClone$5(handler, len);
	    for (var i = 0; i < len; ++i)
	      ReflectApply$5(listeners[i], this, args);
	  }

	  return true;
	};

	function _addListener$5(target, type, listener, prepend) {
	  var m;
	  var events;
	  var existing;

	  checkListener$5(listener);

	  events = target._events;
	  if (events === undefined) {
	    events = target._events = Object.create(null);
	    target._eventsCount = 0;
	  } else {
	    // To avoid recursion in the case that type === "newListener"! Before
	    // adding it to the listeners, first emit "newListener".
	    if (events.newListener !== undefined) {
	      target.emit('newListener', type,
	                  listener.listener ? listener.listener : listener);

	      // Re-assign `events` because a newListener handler could have caused the
	      // this._events to be assigned to a new object
	      events = target._events;
	    }
	    existing = events[type];
	  }

	  if (existing === undefined) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    existing = events[type] = listener;
	    ++target._eventsCount;
	  } else {
	    if (typeof existing === 'function') {
	      // Adding the second element, need to change to array.
	      existing = events[type] =
	        prepend ? [listener, existing] : [existing, listener];
	      // If we've already got an array, just append.
	    } else if (prepend) {
	      existing.unshift(listener);
	    } else {
	      existing.push(listener);
	    }

	    // Check for listener leak
	    m = _getMaxListeners$5(target);
	    if (m > 0 && existing.length > m && !existing.warned) {
	      existing.warned = true;
	      // No error code for this since it is a Warning
	      // eslint-disable-next-line no-restricted-syntax
	      var w = new Error('Possible EventEmitter memory leak detected. ' +
	                          existing.length + ' ' + String(type) + ' listeners ' +
	                          'added. Use emitter.setMaxListeners() to ' +
	                          'increase limit');
	      w.name = 'MaxListenersExceededWarning';
	      w.emitter = target;
	      w.type = type;
	      w.count = existing.length;
	      ProcessEmitWarning$5(w);
	    }
	  }

	  return target;
	}

	EventEmitter$1$4.prototype.addListener = function addListener(type, listener) {
	  return _addListener$5(this, type, listener, false);
	};

	EventEmitter$1$4.prototype.on = EventEmitter$1$4.prototype.addListener;

	EventEmitter$1$4.prototype.prependListener =
	    function prependListener(type, listener) {
	      return _addListener$5(this, type, listener, true);
	    };

	function onceWrapper$5() {
	  if (!this.fired) {
	    this.target.removeListener(this.type, this.wrapFn);
	    this.fired = true;
	    if (arguments.length === 0)
	      return this.listener.call(this.target);
	    return this.listener.apply(this.target, arguments);
	  }
	}

	function _onceWrap$5(target, type, listener) {
	  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
	  var wrapped = onceWrapper$5.bind(state);
	  wrapped.listener = listener;
	  state.wrapFn = wrapped;
	  return wrapped;
	}

	EventEmitter$1$4.prototype.once = function once(type, listener) {
	  checkListener$5(listener);
	  this.on(type, _onceWrap$5(this, type, listener));
	  return this;
	};

	EventEmitter$1$4.prototype.prependOnceListener =
	    function prependOnceListener(type, listener) {
	      checkListener$5(listener);
	      this.prependListener(type, _onceWrap$5(this, type, listener));
	      return this;
	    };

	// Emits a 'removeListener' event if and only if the listener was removed.
	EventEmitter$1$4.prototype.removeListener =
	    function removeListener(type, listener) {
	      var list, events, position, i, originalListener;

	      checkListener$5(listener);

	      events = this._events;
	      if (events === undefined)
	        return this;

	      list = events[type];
	      if (list === undefined)
	        return this;

	      if (list === listener || list.listener === listener) {
	        if (--this._eventsCount === 0)
	          this._events = Object.create(null);
	        else {
	          delete events[type];
	          if (events.removeListener)
	            this.emit('removeListener', type, list.listener || listener);
	        }
	      } else if (typeof list !== 'function') {
	        position = -1;

	        for (i = list.length - 1; i >= 0; i--) {
	          if (list[i] === listener || list[i].listener === listener) {
	            originalListener = list[i].listener;
	            position = i;
	            break;
	          }
	        }

	        if (position < 0)
	          return this;

	        if (position === 0)
	          list.shift();
	        else {
	          spliceOne$5(list, position);
	        }

	        if (list.length === 1)
	          events[type] = list[0];

	        if (events.removeListener !== undefined)
	          this.emit('removeListener', type, originalListener || listener);
	      }

	      return this;
	    };

	EventEmitter$1$4.prototype.off = EventEmitter$1$4.prototype.removeListener;

	EventEmitter$1$4.prototype.removeAllListeners =
	    function removeAllListeners(type) {
	      var listeners, events, i;

	      events = this._events;
	      if (events === undefined)
	        return this;

	      // not listening for removeListener, no need to emit
	      if (events.removeListener === undefined) {
	        if (arguments.length === 0) {
	          this._events = Object.create(null);
	          this._eventsCount = 0;
	        } else if (events[type] !== undefined) {
	          if (--this._eventsCount === 0)
	            this._events = Object.create(null);
	          else
	            delete events[type];
	        }
	        return this;
	      }

	      // emit removeListener for all listeners on all events
	      if (arguments.length === 0) {
	        var keys = Object.keys(events);
	        var key;
	        for (i = 0; i < keys.length; ++i) {
	          key = keys[i];
	          if (key === 'removeListener') continue;
	          this.removeAllListeners(key);
	        }
	        this.removeAllListeners('removeListener');
	        this._events = Object.create(null);
	        this._eventsCount = 0;
	        return this;
	      }

	      listeners = events[type];

	      if (typeof listeners === 'function') {
	        this.removeListener(type, listeners);
	      } else if (listeners !== undefined) {
	        // LIFO order
	        for (i = listeners.length - 1; i >= 0; i--) {
	          this.removeListener(type, listeners[i]);
	        }
	      }

	      return this;
	    };

	function _listeners$5(target, type, unwrap) {
	  var events = target._events;

	  if (events === undefined)
	    return [];

	  var evlistener = events[type];
	  if (evlistener === undefined)
	    return [];

	  if (typeof evlistener === 'function')
	    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

	  return unwrap ?
	    unwrapListeners$5(evlistener) : arrayClone$5(evlistener, evlistener.length);
	}

	EventEmitter$1$4.prototype.listeners = function listeners(type) {
	  return _listeners$5(this, type, true);
	};

	EventEmitter$1$4.prototype.rawListeners = function rawListeners(type) {
	  return _listeners$5(this, type, false);
	};

	EventEmitter$1$4.listenerCount = function(emitter, type) {
	  if (typeof emitter.listenerCount === 'function') {
	    return emitter.listenerCount(type);
	  } else {
	    return listenerCount$5.call(emitter, type);
	  }
	};

	EventEmitter$1$4.prototype.listenerCount = listenerCount$5;
	function listenerCount$5(type) {
	  var events = this._events;

	  if (events !== undefined) {
	    var evlistener = events[type];

	    if (typeof evlistener === 'function') {
	      return 1;
	    } else if (evlistener !== undefined) {
	      return evlistener.length;
	    }
	  }

	  return 0;
	}

	EventEmitter$1$4.prototype.eventNames = function eventNames() {
	  return this._eventsCount > 0 ? ReflectOwnKeys$5(this._events) : [];
	};

	function arrayClone$5(arr, n) {
	  var copy = new Array(n);
	  for (var i = 0; i < n; ++i)
	    copy[i] = arr[i];
	  return copy;
	}

	function spliceOne$5(list, index) {
	  for (; index + 1 < list.length; index++)
	    list[index] = list[index + 1];
	  list.pop();
	}

	function unwrapListeners$5(arr) {
	  var ret = new Array(arr.length);
	  for (var i = 0; i < ret.length; ++i) {
	    ret[i] = arr[i].listener || arr[i];
	  }
	  return ret;
	}

	function once$5(emitter, name) {
	  return new Promise(function (resolve, reject) {
	    function errorListener(err) {
	      emitter.removeListener(name, resolver);
	      reject(err);
	    }

	    function resolver() {
	      if (typeof emitter.removeListener === 'function') {
	        emitter.removeListener('error', errorListener);
	      }
	      resolve([].slice.call(arguments));
	    }
	    eventTargetAgnosticAddListener$5(emitter, name, resolver, { once: true });
	    if (name !== 'error') {
	      addErrorHandlerIfEventEmitter$5(emitter, errorListener, { once: true });
	    }
	  });
	}

	function addErrorHandlerIfEventEmitter$5(emitter, handler, flags) {
	  if (typeof emitter.on === 'function') {
	    eventTargetAgnosticAddListener$5(emitter, 'error', handler, flags);
	  }
	}

	function eventTargetAgnosticAddListener$5(emitter, name, listener, flags) {
	  if (typeof emitter.on === 'function') {
	    if (flags.once) {
	      emitter.once(name, listener);
	    } else {
	      emitter.on(name, listener);
	    }
	  } else if (typeof emitter.addEventListener === 'function') {
	    // EventTarget does not have `error` event semantics like Node
	    // EventEmitters, we do not listen for `error` events here.
	    emitter.addEventListener(name, function wrapListener(arg) {
	      // IE does not have builtin `{ once: true }` support so we
	      // have to do it manually.
	      if (flags.once) {
	        emitter.removeEventListener(name, wrapListener);
	      }
	      listener(arg);
	    });
	  } else {
	    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
	  }
	}

	var EventEmitter$2$1 = events$5.exports;

	const __RΦ$r$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$r$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$r$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$r$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [95]: { LΦ: t => SyntaxError }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Обработчик синтаксической ошибки в коде source.
	 * @param error
	 * @param source
	 */
	function syntaxErrorHandler$1$1(error, source) {
	    console.group('Синтаксическая ошибка');
	    console.log(error.message);
	    console.log(source);
	    console.log(error.stack);
	    console.groupEnd();
	}
	__RΦ$r$1$1.m("rt:p", [{ n: "error", t: () => __RΦ$r$1$1.a(95), v: null }, { n: "source", t: () => __RΦ$r$1$1.a(14), v: null }])(syntaxErrorHandler$1$1);
	__RΦ$r$1$1.m("rt:f", "F")(syntaxErrorHandler$1$1);
	__RΦ$r$1$1.m("rt:t", () => __RΦ$r$1$1.a(23))(syntaxErrorHandler$1$1);

	const __RΦ$q$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$q$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$q$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$q$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [112]: { LΦ: t => Object } } };
	/**
	 * Выполнить скрипт из текста, который возвращает значение типа T.
	 * @param source
	 */
	function execFunctionScript$1$1(source) {
	    if (!source.trim()) {
	        throw new Error('Не задано тело функции');
	    }
	    try {
	        const code = new Function('', `return (${source})`);
	        return code();
	    }
	    catch (error) {
	        if (error instanceof SyntaxError) {
	            syntaxErrorHandler$1$1(error, source);
	        }
	        throw error;
	    }
	}
	__RΦ$q$1$1.m("rt:p", [{ n: "source", t: () => __RΦ$q$1$1.a(14), v: null }])(execFunctionScript$1$1);
	__RΦ$q$1$1.m("rt:f", "F")(execFunctionScript$1$1);
	__RΦ$q$1$1.m("rt:t", () => __RΦ$q$1$1.a(112))(execFunctionScript$1$1);

	const __RΦ$p$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$p$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$p$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$p$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [113]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$p$1$1.a(10), __RΦ$p$1$1.a(14)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Выполнить скрипт из текста, который ничего не возвращает.
	 * @param source
	 */
	function execActionScript$1$1(source) {
	    if (source) {
	        try {
	            const code = new Function('', source);
	            code();
	        }
	        catch (error) {
	            if (error instanceof SyntaxError) {
	                syntaxErrorHandler$1$1(error, source);
	            }
	            throw error;
	        }
	    }
	}
	__RΦ$p$1$1.m("rt:p", [{ n: "source", t: () => __RΦ$p$1$1.a(113), v: null }])(execActionScript$1$1);
	__RΦ$p$1$1.m("rt:f", "F")(execActionScript$1$1);
	__RΦ$p$1$1.m("rt:t", () => __RΦ$p$1$1.a(23))(execActionScript$1$1);

	const __RΦ$o$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$o$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$o$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$o$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String } } };
	const SPACE$1$1 = ' ';
	const EOL$1$1 = '\n';
	const trim$1$1 = __RΦ$o$1$1.f((message) => message.trim()
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	, [__RΦ$o$1$1.m("rt:p", [{ n: "message", t: () => __RΦ$o$1$1.a(14), v: null }]), __RΦ$o$1$1.m("rt:f", "F>"), __RΦ$o$1$1.m("rt:t", () => __RΦ$o$1$1.a(14))], "trim");
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	function toOneLine$1$1(message) {
	    return message.trim().split(EOL$1$1).map(trim$1$1).join(SPACE$1$1);
	}
	__RΦ$o$1$1.m("rt:p", [{ n: "message", t: () => __RΦ$o$1$1.a(14), v: null }])(toOneLine$1$1);
	__RΦ$o$1$1.m("rt:f", "F")(toOneLine$1$1);
	__RΦ$o$1$1.m("rt:t", () => __RΦ$o$1$1.a(14))(toOneLine$1$1);

	const __RΦ$n$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$n$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$n$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$n$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1]: { RΦ: t => ({ TΦ: "~" }) } } };
	function isBrowser$1$1() {
	    return new Function('try { return this === window } catch (e) { return false }')();
	}
	__RΦ$n$1$1.m("rt:p", [])(isBrowser$1$1);
	__RΦ$n$1$1.m("rt:f", "F")(isBrowser$1$1);
	__RΦ$n$1$1.m("rt:t", () => __RΦ$n$1$1.a(1))(isBrowser$1$1);

	const __RΦ$m$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$m$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$m$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$m$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [21]: { LΦ: t => Boolean } } };
	var IΦdefault$9$1$1 = { name: "IStoppable", prototype: {}, identity: Symbol("IStoppable (interface)") };
	(t => __RΦ$m$1$1.t[150] = t)(IΦdefault$9$1$1);
	__RΦ$m$1$1.m("rt:P", [])(IΦdefault$9$1$1);
	__RΦ$m$1$1.m("rt:m", ["stop"])(IΦdefault$9$1$1);
	__RΦ$m$1$1.m("rt:f", "Ie")(IΦdefault$9$1$1);
	__RΦ$m$1$1.m("rt:p", [])(IΦdefault$9$1$1.prototype, "stop");
	__RΦ$m$1$1.m("rt:f", "M")(IΦdefault$9$1$1.prototype, "stop");
	__RΦ$m$1$1.m("rt:t", () => __RΦ$m$1$1.a(23))(IΦdefault$9$1$1.prototype, "stop");
	__RΦ$m$1$1.m("rt:p", [])(IΦdefault$9$1$1.prototype, "stop");
	__RΦ$m$1$1.m("rt:f", "M")(IΦdefault$9$1$1.prototype, "stop");
	__RΦ$m$1$1.m("rt:t", () => __RΦ$m$1$1.a(23))(IΦdefault$9$1$1.prototype, "stop");
	function isStoppable$1$1(object) {
	    return 'stop' in object && typeof object.stop === 'function';
	}
	__RΦ$m$1$1.m("rt:p", [{ n: "object", t: () => __RΦ$m$1$1.a(1), v: null }])(isStoppable$1$1);
	__RΦ$m$1$1.m("rt:f", "F")(isStoppable$1$1);
	__RΦ$m$1$1.m("rt:t", () => __RΦ$m$1$1.a(21))(isStoppable$1$1);

	const __RΦ$l$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$l$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$l$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$l$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$8$1$1 = { name: "IStartable", prototype: {}, identity: Symbol("IStartable (interface)") };
	(t => __RΦ$l$1$1.t[149] = t)(IΦdefault$8$1$1);
	__RΦ$l$1$1.m("rt:P", [])(IΦdefault$8$1$1);
	__RΦ$l$1$1.m("rt:m", ["start"])(IΦdefault$8$1$1);
	__RΦ$l$1$1.m("rt:f", "Ie")(IΦdefault$8$1$1);
	__RΦ$l$1$1.m("rt:p", [])(IΦdefault$8$1$1.prototype, "start");
	__RΦ$l$1$1.m("rt:f", "M")(IΦdefault$8$1$1.prototype, "start");
	__RΦ$l$1$1.m("rt:t", () => __RΦ$l$1$1.a(23))(IΦdefault$8$1$1.prototype, "start");
	__RΦ$l$1$1.m("rt:p", [])(IΦdefault$8$1$1.prototype, "start");
	__RΦ$l$1$1.m("rt:f", "M")(IΦdefault$8$1$1.prototype, "start");
	__RΦ$l$1$1.m("rt:t", () => __RΦ$l$1$1.a(23))(IΦdefault$8$1$1.prototype, "start");

	/**
	 * Состояния таймера.
	 */
	var ETimerState$1$1;
	(function (ETimerState) {
	    ETimerState["Started"] = "started";
	    ETimerState["Paused"] = "paused";
	    ETimerState["Stopped"] = "stopped";
	})(ETimerState$1$1 || (ETimerState$1$1 = {}));

	const __RΦ$k$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$k$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$k$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$k$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [666]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$k$1$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [667]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$k$1$1.a(4) }] }) }, [668]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$k$1$1.a(4) }] }) } } };
	var IΦdefault$7$1$1 = { name: "IStateHandlers", prototype: {}, identity: Symbol("IStateHandlers (interface)") };
	(t => __RΦ$k$1$1.t[669] = t)(IΦdefault$7$1$1);
	__RΦ$k$1$1.m("rt:P", ["started", "paused", "stopped"])(IΦdefault$7$1$1);
	__RΦ$k$1$1.m("rt:m", [])(IΦdefault$7$1$1);
	__RΦ$k$1$1.m("rt:f", "Ie")(IΦdefault$7$1$1);
	__RΦ$k$1$1.m("rt:t", () => __RΦ$k$1$1.a(666))(IΦdefault$7$1$1.prototype, "started");
	__RΦ$k$1$1.m("rt:f", "P?")(IΦdefault$7$1$1.prototype, "started");
	__RΦ$k$1$1.m("rt:t", () => __RΦ$k$1$1.a(667))(IΦdefault$7$1$1.prototype, "paused");
	__RΦ$k$1$1.m("rt:f", "P?")(IΦdefault$7$1$1.prototype, "paused");
	__RΦ$k$1$1.m("rt:t", () => __RΦ$k$1$1.a(668))(IΦdefault$7$1$1.prototype, "stopped");
	__RΦ$k$1$1.m("rt:f", "P?")(IΦdefault$7$1$1.prototype, "stopped");
	__RΦ$k$1$1.m("rt:t", () => __RΦ$k$1$1.a(666))(IΦdefault$7$1$1.prototype, "started");
	__RΦ$k$1$1.m("rt:f", "P?")(IΦdefault$7$1$1.prototype, "started");
	__RΦ$k$1$1.m("rt:t", () => __RΦ$k$1$1.a(667))(IΦdefault$7$1$1.prototype, "paused");
	__RΦ$k$1$1.m("rt:f", "P?")(IΦdefault$7$1$1.prototype, "paused");
	__RΦ$k$1$1.m("rt:t", () => __RΦ$k$1$1.a(668))(IΦdefault$7$1$1.prototype, "stopped");
	__RΦ$k$1$1.m("rt:f", "P?")(IΦdefault$7$1$1.prototype, "stopped");

	const __RΦ$j$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$j$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$j$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$j$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [689]: { RΦ: t => ({ TΦ: "e", e: ETimerState$1$1 }) }, [673]: { RΦ: t => ({ TΦ: "g", t: __RΦ$j$1$1.a(669), p: [__RΦ$j$1$1.a(672)] }) }, [669]: { LΦ: t => IΦdefault$7$1$1 }, [672]: { LΦ: t => Object }, [690]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$j$1$1.a(10), __RΦ$j$1$1.a(672)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	/**
	 * Запустить определенный скрипт в зависимости от состояния таймера.
	 * @param state Текущее состояние таймера.
	 * @param stateHandlers Массив скриптов (ключ - имя состояния, значение - скрипт).
	 */
	function handleByState$1$1(state, stateHandlers) {
	    switch (state) {
	        case ETimerState$1$1.Started: return stateHandlers.started ? stateHandlers.started() : undefined;
	        case ETimerState$1$1.Paused: return stateHandlers.paused ? stateHandlers.paused() : undefined;
	        case ETimerState$1$1.Stopped: return stateHandlers.stopped ? stateHandlers.stopped() : undefined;
	    }
	}
	__RΦ$j$1$1.m("rt:p", [{ n: "state", t: () => __RΦ$j$1$1.a(689), v: null }, { n: "stateHandlers", t: () => __RΦ$j$1$1.a(673), v: null }])(handleByState$1$1);
	__RΦ$j$1$1.m("rt:f", "F")(handleByState$1$1);
	__RΦ$j$1$1.m("rt:t", () => __RΦ$j$1$1.a(690))(handleByState$1$1);

	const __RΦ$i$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$i$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$i$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$i$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [1603]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$i$1$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1551]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$i$1$1.a(10), __RΦ$i$1$1.a(15)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [689]: { RΦ: t => ({ TΦ: "e", e: ETimerState$1$1 }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Простая реализация таймера.
	 */
	class Timer$1$1 {
	    timeout;
	    action;
	    timerId;
	    /**
	     * Время запуска таймера. В миллисекундах.
	     * @private
	     */
	    time = 0;
	    /**
	     * Время постановки на паузу. В миллисекундах.
	     * @private
	     */
	    pauseTime = 0;
	    /**
	     * Общее время остановки таймера. В миллисекундах.
	     * @private
	     */
	    pauseInterval = 0;
	    /**
	     * Текущее состояние таймера
	     * @private
	     */
	    state = ETimerState$1$1.Stopped;
	    /**
	     * Внимание, внутри action определена this как Timer.
	     * @param timeout
	     * @param action
	     */
	    constructor(timeout, action) {
	        this.timeout = timeout;
	        this.action = action;
	    }
	    /**
	     * Запуск таймера.
	     * Стартовать таймер сначала или продолжить с паузы.
	     */
	    start() {
	        handleByState$1$1(this.state, {
	            paused: __RΦ$i$1$1.f(() => {
	                this.state = ETimerState$1$1.Started;
	                this.pauseInterval += Date.now() - this.pauseTime;
	            }, [__RΦ$i$1$1.m("rt:p", []), __RΦ$i$1$1.m("rt:f", "F>"), __RΦ$i$1$1.m("rt:t", () => __RΦ$i$1$1.a(23))], "paused"),
	            stopped: __RΦ$i$1$1.f(() => {
	                this.state = ETimerState$1$1.Started;
	                this.timerId = window.setInterval(this.tick.bind(this), this.timeout);
	                this.time = Date.now();
	            }, [__RΦ$i$1$1.m("rt:p", []), __RΦ$i$1$1.m("rt:f", "F>"), __RΦ$i$1$1.m("rt:t", () => __RΦ$i$1$1.a(23))], "stopped")
	        });
	    }
	    /**
	     * Поставить на паузу таймер.
	     * Состояние сохраняется, счет приостанавливается.
	     */
	    pause() {
	        handleByState$1$1(this.state, {
	            started: __RΦ$i$1$1.f(() => {
	                this.state = ETimerState$1$1.Paused;
	                this.pauseTime = Date.now();
	            }, [__RΦ$i$1$1.m("rt:p", []), __RΦ$i$1$1.m("rt:f", "F>"), __RΦ$i$1$1.m("rt:t", () => __RΦ$i$1$1.a(23))], "started")
	        });
	    }
	    /**
	     * Остановить таймер.
	     * Полный сброс таймера.
	     */
	    stop() {
	        const stop = __RΦ$i$1$1.f(() => {
	            this.state = ETimerState$1$1.Stopped;
	            clearInterval(this.timerId);
	            this.timerId = undefined;
	            this.time = 0;
	        }, [__RΦ$i$1$1.m("rt:p", []), __RΦ$i$1$1.m("rt:f", "F>"), __RΦ$i$1$1.m("rt:t", () => __RΦ$i$1$1.a(23))], "stop");
	        handleByState$1$1(this.state, {
	            started: stop,
	            paused: stop
	        });
	    }
	    /**
	     * Количество миллисекунд с начала старта таймера.
	     * С учетом всех пауз.
	     */
	    get interval() {
	        const result = handleByState$1$1(this.state, {
	            started: () => Date.now() - this.time - this.pauseTime,
	            paused: () => this.time - this.pauseTime,
	            stopped: () => 0
	        });
	        return result === undefined ? 0 : result;
	    }
	    /**
	     * Выполняемая нагрузка таймера.
	     * @private
	     */
	    tick() {
	        handleByState$1$1(this.state, {
	            started: __RΦ$i$1$1.f(() => this.action.call(this), [__RΦ$i$1$1.m("rt:p", []), __RΦ$i$1$1.m("rt:f", "F>"), __RΦ$i$1$1.m("rt:t", () => __RΦ$i$1$1.a(23))], "started")
	        });
	    }
	}
	(t => __RΦ$i$1$1.t[692] = t)(Timer$1$1);
	__RΦ$i$1$1.m("rt:SP", [])(Timer$1$1);
	__RΦ$i$1$1.m("rt:P", ["timerId", "time", "pauseTime", "pauseInterval", "state", "timeout", "action", "interval"])(Timer$1$1);
	__RΦ$i$1$1.m("rt:Sm", [])(Timer$1$1);
	__RΦ$i$1$1.m("rt:m", ["start", "pause", "stop", "tick"])(Timer$1$1);
	__RΦ$i$1$1.m("rt:p", [{ n: "timeout", t: () => __RΦ$i$1$1.a(15), v: null, f: "#" }, { n: "action", t: () => __RΦ$i$1$1.a(1603), v: null, f: "#" }])(Timer$1$1);
	__RΦ$i$1$1.m("rt:i", [() => undefined, () => undefined])(Timer$1$1);
	__RΦ$i$1$1.m("rt:f", "Ce")(Timer$1$1);
	__RΦ$i$1$1.m("rt:t", () => __RΦ$i$1$1.a(1551))(Timer$1$1.prototype, "timerId");
	__RΦ$i$1$1.m("rt:f", "P#")(Timer$1$1.prototype, "timerId");
	__RΦ$i$1$1.m("rt:t", () => __RΦ$i$1$1.a(15))(Timer$1$1.prototype, "time");
	__RΦ$i$1$1.m("rt:f", "P#")(Timer$1$1.prototype, "time");
	__RΦ$i$1$1.m("rt:t", () => __RΦ$i$1$1.a(15))(Timer$1$1.prototype, "pauseTime");
	__RΦ$i$1$1.m("rt:f", "P#")(Timer$1$1.prototype, "pauseTime");
	__RΦ$i$1$1.m("rt:t", () => __RΦ$i$1$1.a(15))(Timer$1$1.prototype, "pauseInterval");
	__RΦ$i$1$1.m("rt:f", "P#")(Timer$1$1.prototype, "pauseInterval");
	__RΦ$i$1$1.m("rt:t", () => __RΦ$i$1$1.a(689))(Timer$1$1.prototype, "state");
	__RΦ$i$1$1.m("rt:f", "P#")(Timer$1$1.prototype, "state");
	__RΦ$i$1$1.m("rt:f", "M$.")(Timer$1$1.prototype["start"]);
	((t, p) => __RΦ$i$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$1$1.prototype, "start");
	__RΦ$i$1$1.m("rt:p", [])(Timer$1$1.prototype, "start");
	__RΦ$i$1$1.m("rt:f", "M$.")(Timer$1$1.prototype, "start");
	__RΦ$i$1$1.m("rt:t", () => __RΦ$i$1$1.a(23))(Timer$1$1.prototype, "start");
	__RΦ$i$1$1.m("rt:f", "M$.")(Timer$1$1.prototype["pause"]);
	((t, p) => __RΦ$i$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$1$1.prototype, "pause");
	__RΦ$i$1$1.m("rt:p", [])(Timer$1$1.prototype, "pause");
	__RΦ$i$1$1.m("rt:f", "M$.")(Timer$1$1.prototype, "pause");
	__RΦ$i$1$1.m("rt:t", () => __RΦ$i$1$1.a(23))(Timer$1$1.prototype, "pause");
	__RΦ$i$1$1.m("rt:f", "M$.")(Timer$1$1.prototype["stop"]);
	((t, p) => __RΦ$i$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$1$1.prototype, "stop");
	__RΦ$i$1$1.m("rt:p", [])(Timer$1$1.prototype, "stop");
	__RΦ$i$1$1.m("rt:f", "M$.")(Timer$1$1.prototype, "stop");
	__RΦ$i$1$1.m("rt:t", () => __RΦ$i$1$1.a(23))(Timer$1$1.prototype, "stop");
	__RΦ$i$1$1.m("rt:t", () => __RΦ$i$1$1.a(15))(Timer$1$1.prototype, "interval");
	__RΦ$i$1$1.m("rt:f", "P$")(Timer$1$1.prototype, "interval");
	__RΦ$i$1$1.m("rt:f", "M#.")(Timer$1$1.prototype["tick"]);
	((t, p) => __RΦ$i$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$1$1.prototype, "tick");
	__RΦ$i$1$1.m("rt:p", [])(Timer$1$1.prototype, "tick");
	__RΦ$i$1$1.m("rt:f", "M#.")(Timer$1$1.prototype, "tick");
	__RΦ$i$1$1.m("rt:t", () => __RΦ$i$1$1.a(23))(Timer$1$1.prototype, "tick");

	const __RΦ$h$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$h$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$h$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$h$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1607]: { LΦ: t => Object } } };
	var IΦdefault$6$1$1 = { name: "ICreator", prototype: {}, identity: Symbol("ICreator (interface)") };
	(t => __RΦ$h$1$1.t[1608] = t)(IΦdefault$6$1$1);
	__RΦ$h$1$1.m("rt:P", [])(IΦdefault$6$1$1);
	__RΦ$h$1$1.m("rt:m", ["create"])(IΦdefault$6$1$1);
	__RΦ$h$1$1.m("rt:f", "Ie")(IΦdefault$6$1$1);
	__RΦ$h$1$1.m("rt:p", [])(IΦdefault$6$1$1.prototype, "create");
	__RΦ$h$1$1.m("rt:f", "M")(IΦdefault$6$1$1.prototype, "create");
	__RΦ$h$1$1.m("rt:t", () => __RΦ$h$1$1.a(1607))(IΦdefault$6$1$1.prototype, "create");
	__RΦ$h$1$1.m("rt:p", [])(IΦdefault$6$1$1.prototype, "create");
	__RΦ$h$1$1.m("rt:f", "M")(IΦdefault$6$1$1.prototype, "create");
	__RΦ$h$1$1.m("rt:t", () => __RΦ$h$1$1.a(1607))(IΦdefault$6$1$1.prototype, "create");

	const __RΦ$g$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$g$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$g$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$g$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1610]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$g$1$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1618]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$g$1$1.a(10), __RΦ$g$1$1.a(1612)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1612]: { LΦ: t => Object }, [1615]: { RΦ: t => ({ TΦ: "g", t: __RΦ$g$1$1.a(1608), p: [__RΦ$g$1$1.a(1612)] }) }, [1608]: { LΦ: t => IΦdefault$6$1$1 } } };
	/**
	 * Отложенная инициализация.
	 * @link https://metanit.com/sharp/tutorial/20.1.php
	 * @link https://docs.microsoft.com/ru-ru/dotnet/api/system.lazy-1?view=net-5.0
	 */
	class Lazy$1$1 {
	    createFn;
	    #value;
	    #creator;
	    constructor(createFn) {
	        this.createFn = createFn;
	        this.#creator = {
	            create() {
	                return createFn();
	            }
	        };
	    }
	    get value() {
	        if (!this.#value) {
	            this.#value = this.#creator.create();
	        }
	        return this.#value;
	    }
	}
	(t => __RΦ$g$1$1.t[1611] = t)(Lazy$1$1);
	__RΦ$g$1$1.m("rt:SP", [])(Lazy$1$1);
	__RΦ$g$1$1.m("rt:P", ["#value", "#creator", "createFn", "value"])(Lazy$1$1);
	__RΦ$g$1$1.m("rt:Sm", [])(Lazy$1$1);
	__RΦ$g$1$1.m("rt:m", [])(Lazy$1$1);
	__RΦ$g$1$1.m("rt:p", [{ n: "createFn", t: () => __RΦ$g$1$1.a(1610), v: null, f: "#" }])(Lazy$1$1);
	__RΦ$g$1$1.m("rt:f", "Ce")(Lazy$1$1);
	__RΦ$g$1$1.m("rt:t", () => __RΦ$g$1$1.a(1618))(Lazy$1$1.prototype, "#value");
	__RΦ$g$1$1.m("rt:f", "P")(Lazy$1$1.prototype, "#value");
	__RΦ$g$1$1.m("rt:t", () => __RΦ$g$1$1.a(1615))(Lazy$1$1.prototype, "#creator");
	__RΦ$g$1$1.m("rt:f", "P")(Lazy$1$1.prototype, "#creator");
	__RΦ$g$1$1.m("rt:t", () => __RΦ$g$1$1.a(1612))(Lazy$1$1.prototype, "value");
	__RΦ$g$1$1.m("rt:f", "P")(Lazy$1$1.prototype, "value");

	const __RΦ$f$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$f$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$f$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$f$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	var IΦdefault$5$1$1 = { name: "IPoint", prototype: {}, identity: Symbol("IPoint (interface)") };
	(t => __RΦ$f$1$1.t[141] = t)(IΦdefault$5$1$1);
	__RΦ$f$1$1.m("rt:P", ["x", "y"])(IΦdefault$5$1$1);
	__RΦ$f$1$1.m("rt:m", [])(IΦdefault$5$1$1);
	__RΦ$f$1$1.m("rt:f", "Ie")(IΦdefault$5$1$1);
	__RΦ$f$1$1.m("rt:t", () => __RΦ$f$1$1.a(15))(IΦdefault$5$1$1.prototype, "x");
	__RΦ$f$1$1.m("rt:f", "P")(IΦdefault$5$1$1.prototype, "x");
	__RΦ$f$1$1.m("rt:t", () => __RΦ$f$1$1.a(15))(IΦdefault$5$1$1.prototype, "y");
	__RΦ$f$1$1.m("rt:f", "P")(IΦdefault$5$1$1.prototype, "y");
	__RΦ$f$1$1.m("rt:t", () => __RΦ$f$1$1.a(15))(IΦdefault$5$1$1.prototype, "x");
	__RΦ$f$1$1.m("rt:f", "P")(IΦdefault$5$1$1.prototype, "x");
	__RΦ$f$1$1.m("rt:t", () => __RΦ$f$1$1.a(15))(IΦdefault$5$1$1.prototype, "y");
	__RΦ$f$1$1.m("rt:f", "P")(IΦdefault$5$1$1.prototype, "y");

	const __RΦ$e$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$e$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$e$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$e$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [141]: { LΦ: t => IΦdefault$5$1$1 }, [1627]: { TΦ: "5", name: "default" }, [21]: { LΦ: t => Boolean }, [1636]: { RΦ: t => ({ TΦ: "[", e: __RΦ$e$1$1.a(15) }) }, [14]: { LΦ: t => String } } };
	/*
	 * Увеличить длину вектора можно так:
	 * Vector.translate(Vector.identity.scale(length))
	 *
	 */
	/**
	 * Вектор.
	 * @unmutable
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/vector/Vector.js
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/Point.js
	 */
	class Vector$1$1 {
	    x;
	    y;
	    /**
	     * Расстояние от начала координат до точки.
	     */
	    static distance(point) {
	        // noinspection JSSuspiciousNameCombination
	        return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
	    }
	    /**
	     * Создать вектор на основе угла и длины.
	     */
	    static create(angle, length) {
	        return new Vector$1$1(length * Math.cos(angle), length * Math.sin(angle));
	    }
	    /**
	     * Угол между вектором и положительной осью.
	     * Принимает значение от -Math.PI до Math.PI радиан.
	     */
	    get angle() {
	        return Math.atan2(this.y, this.x);
	    }
	    /**
	     * Модуль (длина) вектора.
	     */
	    get length() {
	        return Vector$1$1.distance(this);
	    }
	    /**
	     * Возвращает true, если вектор является нулевым.
	     */
	    get isNull() {
	        return this.x === 0 && this.y === 0;
	    }
	    /**
	     * Конструктор вектора.
	     * @param x
	     * @param y
	     */
	    constructor(x = 0, y = 0) {
	        this.x = x;
	        this.y = y;
	    }
	    /**
	     * Получить единичный вектор, равный по направлению исходному.
	     * Он же направляющий вектор (единичный, равный по направлению).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get identity() {
	        return (new Vector$1$1(Math.cos(this.angle), Math.sin(this.angle)));
	    }
	    /**
	     * Получить обратный вектор (инверсия вектора).
	     */
	    get inverse() {
	        return new Vector$1$1(-this.x, -this.y);
	    }
	    /**
	     * Нормаль вектора (единичный вектор, перпендикулярный исходному).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get normal() {
	        return this.clone().rotate(Math.PI / 2).identity;
	        // TODO Проверить эту формулу нахождения перпендикулярного вектора.
	        /*
	            a: 1 / parallel.x(),
	            b: -1 / parallel.y(),
	        */
	    }
	    /**
	     * Сложение векторов.
	     * @param vector
	     */
	    translate(vector) {
	        return new Vector$1$1(this.x + vector.x, this.y + vector.y);
	    }
	    /**
	     * Вращение вектора.
	     * @param angle
	     */
	    rotate(angle) {
	        return new Vector$1$1(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle));
	    }
	    /**
	     * Умножение вектора на число.
	     */
	    scale(scale) {
	        return new Vector$1$1(this.x * scale, this.y * scale);
	    }
	    /**
	     * Скалярное произведение векторов.
	     * @param vector
	     */
	    multiply(vector) {
	        return new Vector$1$1(this.x * vector.x, this.y * vector.y);
	    }
	    /**
	     * Взятие остатка от деления.
	     * @param vector
	     */
	    mod(vector) {
	        return new Vector$1$1(this.x % vector.x, this.y % vector.y);
	    }
	    clone() {
	        return new Vector$1$1(this.x, this.y);
	    }
	    toArray() {
	        return [this.x, this.y];
	    }
	    toString(digits = 2) {
	        return `[${this.x.toFixed(digits)}, ${this.y.toFixed(digits)}]`;
	    }
	}
	(t => __RΦ$e$1$1.t[1627] = t)(Vector$1$1);
	__RΦ$e$1$1.m("rt:SP", [])(Vector$1$1);
	__RΦ$e$1$1.m("rt:P", ["angle", "length", "isNull", "x", "y", "identity", "inverse", "normal"])(Vector$1$1);
	__RΦ$e$1$1.m("rt:Sm", ["distance", "create"])(Vector$1$1);
	__RΦ$e$1$1.m("rt:m", ["translate", "rotate", "scale", "multiply", "mod", "clone", "toArray", "toString"])(Vector$1$1);
	__RΦ$e$1$1.m("rt:p", [{ n: "x", t: () => __RΦ$e$1$1.a(15), v: function () { return 0; }, f: "$R" }, { n: "y", t: () => __RΦ$e$1$1.a(15), v: function () { return 0; }, f: "$R" }])(Vector$1$1);
	__RΦ$e$1$1.m("rt:i", [() => undefined])(Vector$1$1);
	__RΦ$e$1$1.m("rt:f", "Ce")(Vector$1$1);
	__RΦ$e$1$1.m("rt:f", "M$S")(Vector$1$1["distance"]);
	((t, p) => __RΦ$e$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1$1, "distance");
	__RΦ$e$1$1.m("rt:p", [{ n: "point", t: () => __RΦ$e$1$1.a(141), v: null }])(Vector$1$1, "distance");
	__RΦ$e$1$1.m("rt:f", "M$S")(Vector$1$1, "distance");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(15))(Vector$1$1, "distance");
	__RΦ$e$1$1.m("rt:f", "M$S")(Vector$1$1["create"]);
	((t, p) => __RΦ$e$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1$1, "create");
	__RΦ$e$1$1.m("rt:p", [{ n: "angle", t: () => __RΦ$e$1$1.a(15), v: null }, { n: "length", t: () => __RΦ$e$1$1.a(15), v: null }])(Vector$1$1, "create");
	__RΦ$e$1$1.m("rt:f", "M$S")(Vector$1$1, "create");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(1627))(Vector$1$1, "create");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(15))(Vector$1$1.prototype, "angle");
	__RΦ$e$1$1.m("rt:f", "P$")(Vector$1$1.prototype, "angle");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(15))(Vector$1$1.prototype, "length");
	__RΦ$e$1$1.m("rt:f", "P$")(Vector$1$1.prototype, "length");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(21))(Vector$1$1.prototype, "isNull");
	__RΦ$e$1$1.m("rt:f", "P$")(Vector$1$1.prototype, "isNull");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(1627))(Vector$1$1.prototype, "identity");
	__RΦ$e$1$1.m("rt:f", "P$")(Vector$1$1.prototype, "identity");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(1627))(Vector$1$1.prototype, "inverse");
	__RΦ$e$1$1.m("rt:f", "P$")(Vector$1$1.prototype, "inverse");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(1627))(Vector$1$1.prototype, "normal");
	__RΦ$e$1$1.m("rt:f", "P$")(Vector$1$1.prototype, "normal");
	__RΦ$e$1$1.m("rt:f", "M$")(Vector$1$1.prototype["translate"]);
	((t, p) => __RΦ$e$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1$1.prototype, "translate");
	__RΦ$e$1$1.m("rt:p", [{ n: "vector", t: () => __RΦ$e$1$1.a(1627), v: null }])(Vector$1$1.prototype, "translate");
	__RΦ$e$1$1.m("rt:f", "M$")(Vector$1$1.prototype, "translate");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(1627))(Vector$1$1.prototype, "translate");
	__RΦ$e$1$1.m("rt:f", "M$.")(Vector$1$1.prototype["rotate"]);
	((t, p) => __RΦ$e$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1$1.prototype, "rotate");
	__RΦ$e$1$1.m("rt:p", [{ n: "angle", t: () => __RΦ$e$1$1.a(15), v: null }])(Vector$1$1.prototype, "rotate");
	__RΦ$e$1$1.m("rt:f", "M$.")(Vector$1$1.prototype, "rotate");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(1627))(Vector$1$1.prototype, "rotate");
	__RΦ$e$1$1.m("rt:f", "M$.")(Vector$1$1.prototype["scale"]);
	((t, p) => __RΦ$e$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1$1.prototype, "scale");
	__RΦ$e$1$1.m("rt:p", [{ n: "scale", t: () => __RΦ$e$1$1.a(15), v: null }])(Vector$1$1.prototype, "scale");
	__RΦ$e$1$1.m("rt:f", "M$.")(Vector$1$1.prototype, "scale");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(1627))(Vector$1$1.prototype, "scale");
	__RΦ$e$1$1.m("rt:f", "M$")(Vector$1$1.prototype["multiply"]);
	((t, p) => __RΦ$e$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1$1.prototype, "multiply");
	__RΦ$e$1$1.m("rt:p", [{ n: "vector", t: () => __RΦ$e$1$1.a(1627), v: null }])(Vector$1$1.prototype, "multiply");
	__RΦ$e$1$1.m("rt:f", "M$")(Vector$1$1.prototype, "multiply");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(1627))(Vector$1$1.prototype, "multiply");
	__RΦ$e$1$1.m("rt:f", "M$")(Vector$1$1.prototype["mod"]);
	((t, p) => __RΦ$e$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1$1.prototype, "mod");
	__RΦ$e$1$1.m("rt:p", [{ n: "vector", t: () => __RΦ$e$1$1.a(1627), v: null }])(Vector$1$1.prototype, "mod");
	__RΦ$e$1$1.m("rt:f", "M$")(Vector$1$1.prototype, "mod");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(1627))(Vector$1$1.prototype, "mod");
	__RΦ$e$1$1.m("rt:f", "M$.")(Vector$1$1.prototype["clone"]);
	((t, p) => __RΦ$e$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1$1.prototype, "clone");
	__RΦ$e$1$1.m("rt:p", [])(Vector$1$1.prototype, "clone");
	__RΦ$e$1$1.m("rt:f", "M$.")(Vector$1$1.prototype, "clone");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(1627))(Vector$1$1.prototype, "clone");
	__RΦ$e$1$1.m("rt:f", "M$.")(Vector$1$1.prototype["toArray"]);
	((t, p) => __RΦ$e$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1$1.prototype, "toArray");
	__RΦ$e$1$1.m("rt:p", [])(Vector$1$1.prototype, "toArray");
	__RΦ$e$1$1.m("rt:f", "M$.")(Vector$1$1.prototype, "toArray");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(1636))(Vector$1$1.prototype, "toArray");
	__RΦ$e$1$1.m("rt:f", "M$.")(Vector$1$1.prototype["toString"]);
	((t, p) => __RΦ$e$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1$1.prototype, "toString");
	__RΦ$e$1$1.m("rt:p", [{ n: "digits", t: () => __RΦ$e$1$1.a(15), v: function () { return 2; } }])(Vector$1$1.prototype, "toString");
	__RΦ$e$1$1.m("rt:f", "M$.")(Vector$1$1.prototype, "toString");
	__RΦ$e$1$1.m("rt:t", () => __RΦ$e$1$1.a(14))(Vector$1$1.prototype, "toString");

	const __RΦ$d$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$d$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$d$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$d$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	class Angle$1$1 {
	    /**
	     * Конвертация угла из радиан в градусы.
	     * @param value
	     */
	    static toDegree(value) {
	        return value / Math.PI * 180;
	    }
	    /**
	     * Конвертация угла из градусов в радианы.
	     * @param value
	     */
	    static toRadian(value) {
	        return value * Math.PI / 180;
	    }
	}
	(t => __RΦ$d$1$1.t[1638] = t)(Angle$1$1);
	__RΦ$d$1$1.m("rt:SP", [])(Angle$1$1);
	__RΦ$d$1$1.m("rt:P", [])(Angle$1$1);
	__RΦ$d$1$1.m("rt:Sm", ["toDegree", "toRadian"])(Angle$1$1);
	__RΦ$d$1$1.m("rt:m", [])(Angle$1$1);
	__RΦ$d$1$1.m("rt:f", "Ce")(Angle$1$1);
	__RΦ$d$1$1.m("rt:f", "M$S.")(Angle$1$1["toDegree"]);
	((t, p) => __RΦ$d$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle$1$1, "toDegree");
	__RΦ$d$1$1.m("rt:p", [{ n: "value", t: () => __RΦ$d$1$1.a(15), v: null }])(Angle$1$1, "toDegree");
	__RΦ$d$1$1.m("rt:f", "M$S.")(Angle$1$1, "toDegree");
	__RΦ$d$1$1.m("rt:t", () => __RΦ$d$1$1.a(15))(Angle$1$1, "toDegree");
	__RΦ$d$1$1.m("rt:f", "M$S.")(Angle$1$1["toRadian"]);
	((t, p) => __RΦ$d$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle$1$1, "toRadian");
	__RΦ$d$1$1.m("rt:p", [{ n: "value", t: () => __RΦ$d$1$1.a(15), v: null }])(Angle$1$1, "toRadian");
	__RΦ$d$1$1.m("rt:f", "M$S.")(Angle$1$1, "toRadian");
	__RΦ$d$1$1.m("rt:t", () => __RΦ$d$1$1.a(15))(Angle$1$1, "toRadian");

	const __RΦ$c$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$c$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$c$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$c$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [151]: { LΦ: t => Object }, [152]: { LΦ: t => Object } } };
	var IΦdefault$4$1$1 = { name: "IKeyValueObject", prototype: {}, identity: Symbol("IKeyValueObject (interface)") };
	(t => __RΦ$c$1$1.t[153] = t)(IΦdefault$4$1$1);
	__RΦ$c$1$1.m("rt:P", ["key", "value"])(IΦdefault$4$1$1);
	__RΦ$c$1$1.m("rt:m", [])(IΦdefault$4$1$1);
	__RΦ$c$1$1.m("rt:f", "Ie")(IΦdefault$4$1$1);
	__RΦ$c$1$1.m("rt:t", () => __RΦ$c$1$1.a(151))(IΦdefault$4$1$1.prototype, "key");
	__RΦ$c$1$1.m("rt:f", "P")(IΦdefault$4$1$1.prototype, "key");
	__RΦ$c$1$1.m("rt:t", () => __RΦ$c$1$1.a(152))(IΦdefault$4$1$1.prototype, "value");
	__RΦ$c$1$1.m("rt:f", "P")(IΦdefault$4$1$1.prototype, "value");
	__RΦ$c$1$1.m("rt:t", () => __RΦ$c$1$1.a(151))(IΦdefault$4$1$1.prototype, "key");
	__RΦ$c$1$1.m("rt:f", "P")(IΦdefault$4$1$1.prototype, "key");
	__RΦ$c$1$1.m("rt:t", () => __RΦ$c$1$1.a(152))(IΦdefault$4$1$1.prototype, "value");
	__RΦ$c$1$1.m("rt:f", "P")(IΦdefault$4$1$1.prototype, "value");

	const __RΦ$b$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$b$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$b$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$b$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1828]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$1$1.a(156), p: [__RΦ$b$1$1.a(1826), __RΦ$b$1$1.a(1827)] }) }, [156]: { LΦ: t => Map }, [1826]: { LΦ: t => Object }, [1827]: { LΦ: t => Object }, [1832]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$1$1.a(1836) }) }, [1836]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$1$1.a(153), p: [__RΦ$b$1$1.a(1826), __RΦ$b$1$1.a(1835)] }) }, [153]: { LΦ: t => IΦdefault$4$1$1 }, [1835]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b$1$1.a(10), __RΦ$b$1$1.a(1827)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1839]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b$1$1.a(1840), p: [__RΦ$b$1$1.a(1837), __RΦ$b$1$1.a(1838)] }) }, [1840]: { LΦ: t => Object }, [1837]: { LΦ: t => Object }, [1838]: { LΦ: t => Object }, [1844]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$1$1.a(1846) }) }, [1846]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$1$1.a(153), p: [__RΦ$b$1$1.a(1837), __RΦ$b$1$1.a(1838)] }) }, [1663]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b$1$1.a(1656), __RΦ$b$1$1.a(1661)] }) }, [1656]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$1$1.a(156), p: [__RΦ$b$1$1.a(1645), __RΦ$b$1$1.a(1646)] }) }, [1645]: { LΦ: t => Object }, [1646]: { LΦ: t => Object }, [1661]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b$1$1.a(1662), p: [__RΦ$b$1$1.a(1645), __RΦ$b$1$1.a(1646)] }) }, [1662]: { LΦ: t => Object }, [1647]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$1$1.a(1650) }) }, [1650]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$1$1.a(153), p: [__RΦ$b$1$1.a(1645), __RΦ$b$1$1.a(1646)] }) }, [15]: { LΦ: t => Number } } };
	/**
	 * Конвертация разнообразных значений.
	 */
	class Convert$1$1 {
	    static toArray(object) {
	        const result = [];
	        if (object instanceof Map) {
	            for (const [key, value] of object) {
	                result.push({ key, value });
	            }
	        }
	        else {
	            for (const key in object) {
	                if (!object.hasOwnProperty(key))
	                    continue;
	                result.push({ key, value: Reflect.get(object, key) });
	            }
	        }
	        return result;
	    }
	    /**
	     * Конвертировать миллисекунды в секунды.
	     * @param millisecond
	     */
	    static toSecond(millisecond) {
	        return millisecond / 1000;
	    }
	}
	(t => __RΦ$b$1$1.t[1824] = t)(Convert$1$1);
	__RΦ$b$1$1.m("rt:SP", [])(Convert$1$1);
	__RΦ$b$1$1.m("rt:P", [])(Convert$1$1);
	__RΦ$b$1$1.m("rt:Sm", ["toArray", "toArray", "toArray", "toSecond"])(Convert$1$1);
	__RΦ$b$1$1.m("rt:m", [])(Convert$1$1);
	__RΦ$b$1$1.m("rt:f", "Ce")(Convert$1$1);
	__RΦ$b$1$1.m("rt:f", "M$S")(Convert$1$1["toArray"]);
	((t, p) => __RΦ$b$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$1$1, "toArray");
	__RΦ$b$1$1.m("rt:p", [{ n: "object", t: () => __RΦ$b$1$1.a(1828), v: null }])(Convert$1$1, "toArray");
	__RΦ$b$1$1.m("rt:f", "M$S")(Convert$1$1, "toArray");
	__RΦ$b$1$1.m("rt:t", () => __RΦ$b$1$1.a(1832))(Convert$1$1, "toArray");
	__RΦ$b$1$1.m("rt:f", "M$S")(Convert$1$1["toArray"]);
	((t, p) => __RΦ$b$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$1$1, "toArray");
	__RΦ$b$1$1.m("rt:p", [{ n: "object", t: () => __RΦ$b$1$1.a(1839), v: null }])(Convert$1$1, "toArray");
	__RΦ$b$1$1.m("rt:f", "M$S")(Convert$1$1, "toArray");
	__RΦ$b$1$1.m("rt:t", () => __RΦ$b$1$1.a(1844))(Convert$1$1, "toArray");
	__RΦ$b$1$1.m("rt:f", "M$S")(Convert$1$1["toArray"]);
	((t, p) => __RΦ$b$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$1$1, "toArray");
	__RΦ$b$1$1.m("rt:p", [{ n: "object", t: () => __RΦ$b$1$1.a(1663), v: null }])(Convert$1$1, "toArray");
	__RΦ$b$1$1.m("rt:f", "M$S")(Convert$1$1, "toArray");
	__RΦ$b$1$1.m("rt:t", () => __RΦ$b$1$1.a(1647))(Convert$1$1, "toArray");
	__RΦ$b$1$1.m("rt:f", "M$S.")(Convert$1$1["toSecond"]);
	((t, p) => __RΦ$b$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$1$1, "toSecond");
	__RΦ$b$1$1.m("rt:p", [{ n: "millisecond", t: () => __RΦ$b$1$1.a(15), v: null }])(Convert$1$1, "toSecond");
	__RΦ$b$1$1.m("rt:f", "M$S.")(Convert$1$1, "toSecond");
	__RΦ$b$1$1.m("rt:t", () => __RΦ$b$1$1.a(15))(Convert$1$1, "toSecond");

	const __RΦ$a$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$a$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$a$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$a$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1873]: { LΦ: t => 60 }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [15]: { LΦ: t => Number }, [1869]: { LΦ: t => "update" }, [1875]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$1$1.a(4) }] }) }, [1850]: { RΦ: t => ({ TΦ: "t" }) }, [1871]: { LΦ: t => "render" }, [1876]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$1$1.a(4) }] }) }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$a$1$1.a(14), __RΦ$a$1$1.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1852]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$1$1.a(4) }] }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * http://gs-studio.com/news-about-it/30703----javascript
	 * https://eatdog.com.ua/assets/gamedev-slides/
	 * https://www.youtube.com/watch?v=-gsjAz9jR3Y
	 */
	class GameLoop$1$1 {
	    framePerSecond;
	    eventEmitter = new EventEmitter$2$1;
	    time = 0;
	    timeInterval = 0;
	    renderTime = 0;
	    renderTimeInterval = 0;
	    /**
	     * Текущий FPS отрисовки игровой сцены.
	     */
	    get renderFramePerSecond() {
	        return 1 / (this.renderTimeInterval / 1000);
	    }
	    /**
	     * Временной шаг, с которым вызывается функция update для вычисления игровой логики.
	     * Измеряется в миллисекундах.
	     */
	    get step() {
	        return (1 / this.framePerSecond) / 1000;
	    }
	    constructor(
	    /**
	     * Частота обновления игровой логики (генерации события update).
	     * @private
	     */
	    framePerSecond = 60 // TODO Переименовать в updatePerSecond?
	    ) {
	        this.framePerSecond = framePerSecond;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	    start() {
	        this.time = performance.now();
	        this.timeInterval = 0;
	        requestAnimationFrame(this.frame.bind(this));
	    }
	    stop() {
	    }
	    pause() {
	    }
	    frame() {
	        // Обработка логики игры.
	        {
	            const currentTime = performance.now();
	            // Исправление проблемы неактивных вкладок.
	            // Разрешить максимальную задержку между вызовами не более, чем 1 секунда.
	            this.timeInterval = this.timeInterval + Math.min(1000, currentTime - this.time);
	            while (this.timeInterval > this.step) {
	                this.timeInterval = this.timeInterval - this.step;
	                this.eventEmitter.emit('update', this.step);
	            }
	            this.time = currentTime;
	        }
	        // Обработка отрисовки сцены игры.
	        {
	            const renderCurrentTime = performance.now();
	            this.renderTimeInterval = renderCurrentTime - this.renderTime;
	            this.renderTime = renderCurrentTime;
	            this.eventEmitter.emit('render', this.timeInterval);
	        }
	        requestAnimationFrame(this.frame.bind(this));
	    }
	}
	(t => __RΦ$a$1$1.t[1849] = t)(GameLoop$1$1);
	__RΦ$a$1$1.m("rt:SP", [])(GameLoop$1$1);
	__RΦ$a$1$1.m("rt:P", ["eventEmitter", "time", "timeInterval", "renderTime", "renderTimeInterval", "renderFramePerSecond", "step", "framePerSecond"])(GameLoop$1$1);
	__RΦ$a$1$1.m("rt:Sm", [])(GameLoop$1$1);
	__RΦ$a$1$1.m("rt:m", ["on", "on", "on", "start", "stop", "pause", "frame"])(GameLoop$1$1);
	__RΦ$a$1$1.m("rt:p", [{ n: "framePerSecond", t: () => __RΦ$a$1$1.a(1873), v: function () { return 60 // TODO Переименовать в updatePerSecond?
	        ; }, f: "#R" }])(GameLoop$1$1);
	__RΦ$a$1$1.m("rt:i", [() => undefined, () => undefined])(GameLoop$1$1);
	__RΦ$a$1$1.m("rt:f", "Ce")(GameLoop$1$1);
	__RΦ$a$1$1.m("rt:t", () => __RΦ$a$1$1.a(4))(GameLoop$1$1.prototype, "eventEmitter");
	__RΦ$a$1$1.m("rt:f", "P#R")(GameLoop$1$1.prototype, "eventEmitter");
	__RΦ$a$1$1.m("rt:t", () => __RΦ$a$1$1.a(15))(GameLoop$1$1.prototype, "time");
	__RΦ$a$1$1.m("rt:f", "P#")(GameLoop$1$1.prototype, "time");
	__RΦ$a$1$1.m("rt:t", () => __RΦ$a$1$1.a(15))(GameLoop$1$1.prototype, "timeInterval");
	__RΦ$a$1$1.m("rt:f", "P#")(GameLoop$1$1.prototype, "timeInterval");
	__RΦ$a$1$1.m("rt:t", () => __RΦ$a$1$1.a(15))(GameLoop$1$1.prototype, "renderTime");
	__RΦ$a$1$1.m("rt:f", "P#")(GameLoop$1$1.prototype, "renderTime");
	__RΦ$a$1$1.m("rt:t", () => __RΦ$a$1$1.a(15))(GameLoop$1$1.prototype, "renderTimeInterval");
	__RΦ$a$1$1.m("rt:f", "P#")(GameLoop$1$1.prototype, "renderTimeInterval");
	__RΦ$a$1$1.m("rt:t", () => __RΦ$a$1$1.a(15))(GameLoop$1$1.prototype, "renderFramePerSecond");
	__RΦ$a$1$1.m("rt:f", "P$")(GameLoop$1$1.prototype, "renderFramePerSecond");
	__RΦ$a$1$1.m("rt:t", () => __RΦ$a$1$1.a(15))(GameLoop$1$1.prototype, "step");
	__RΦ$a$1$1.m("rt:f", "P$")(GameLoop$1$1.prototype, "step");
	__RΦ$a$1$1.m("rt:f", "M")(GameLoop$1$1.prototype["on"]);
	((t, p) => __RΦ$a$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$1$1.prototype, "on");
	__RΦ$a$1$1.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$1$1.a(1869), v: null }, { n: "update", t: () => __RΦ$a$1$1.a(1875), v: null }])(GameLoop$1$1.prototype, "on");
	__RΦ$a$1$1.m("rt:f", "M")(GameLoop$1$1.prototype, "on");
	__RΦ$a$1$1.m("rt:t", () => __RΦ$a$1$1.a(1850))(GameLoop$1$1.prototype, "on");
	__RΦ$a$1$1.m("rt:f", "M")(GameLoop$1$1.prototype["on"]);
	((t, p) => __RΦ$a$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$1$1.prototype, "on");
	__RΦ$a$1$1.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$1$1.a(1871), v: null }, { n: "render", t: () => __RΦ$a$1$1.a(1876), v: null }])(GameLoop$1$1.prototype, "on");
	__RΦ$a$1$1.m("rt:f", "M")(GameLoop$1$1.prototype, "on");
	__RΦ$a$1$1.m("rt:t", () => __RΦ$a$1$1.a(1850))(GameLoop$1$1.prototype, "on");
	__RΦ$a$1$1.m("rt:f", "M")(GameLoop$1$1.prototype["on"]);
	((t, p) => __RΦ$a$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$1$1.prototype, "on");
	__RΦ$a$1$1.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$1$1.a(143), v: null }, { n: "listener", t: () => __RΦ$a$1$1.a(1852), v: null }])(GameLoop$1$1.prototype, "on");
	__RΦ$a$1$1.m("rt:f", "M")(GameLoop$1$1.prototype, "on");
	__RΦ$a$1$1.m("rt:t", () => __RΦ$a$1$1.a(1850))(GameLoop$1$1.prototype, "on");
	__RΦ$a$1$1.m("rt:f", "M$")(GameLoop$1$1.prototype["start"]);
	((t, p) => __RΦ$a$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$1$1.prototype, "start");
	__RΦ$a$1$1.m("rt:p", [])(GameLoop$1$1.prototype, "start");
	__RΦ$a$1$1.m("rt:f", "M$")(GameLoop$1$1.prototype, "start");
	__RΦ$a$1$1.m("rt:t", () => __RΦ$a$1$1.a(23))(GameLoop$1$1.prototype, "start");
	__RΦ$a$1$1.m("rt:f", "M$")(GameLoop$1$1.prototype["stop"]);
	((t, p) => __RΦ$a$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$1$1.prototype, "stop");
	__RΦ$a$1$1.m("rt:p", [])(GameLoop$1$1.prototype, "stop");
	__RΦ$a$1$1.m("rt:f", "M$")(GameLoop$1$1.prototype, "stop");
	__RΦ$a$1$1.m("rt:t", () => __RΦ$a$1$1.a(23))(GameLoop$1$1.prototype, "stop");
	__RΦ$a$1$1.m("rt:f", "M$")(GameLoop$1$1.prototype["pause"]);
	((t, p) => __RΦ$a$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$1$1.prototype, "pause");
	__RΦ$a$1$1.m("rt:p", [])(GameLoop$1$1.prototype, "pause");
	__RΦ$a$1$1.m("rt:f", "M$")(GameLoop$1$1.prototype, "pause");
	__RΦ$a$1$1.m("rt:t", () => __RΦ$a$1$1.a(23))(GameLoop$1$1.prototype, "pause");
	__RΦ$a$1$1.m("rt:f", "M#.")(GameLoop$1$1.prototype["frame"]);
	((t, p) => __RΦ$a$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$1$1.prototype, "frame");
	__RΦ$a$1$1.m("rt:p", [])(GameLoop$1$1.prototype, "frame");
	__RΦ$a$1$1.m("rt:f", "M#.")(GameLoop$1$1.prototype, "frame");
	__RΦ$a$1$1.m("rt:t", () => __RΦ$a$1$1.a(23))(GameLoop$1$1.prototype, "frame");

	const __RΦ$9$1$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$9$1$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$9$1$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$9$1$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1880]: { RΦ: t => ({ TΦ: "g", t: __RΦ$9$1$3.a(156), p: [__RΦ$9$1$3.a(14), __RΦ$9$1$3.a(21)] }) }, [156]: { LΦ: t => Map }, [14]: { LΦ: t => String }, [21]: { LΦ: t => Boolean }, [1883]: { LΦ: t => KeyboardEvent }, [1890]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$1$3.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1893]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$1$3.a(4) }] }) }, [1897]: { LΦ: t => Function }, [1896]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$1$3.a(4) }] }) }, [1898]: { LΦ: t => Function } } };
	/**
	 * Вместо KeyUpDownProcessor используйте Shortcut.
	 * @deprecated
	 * @link http://khusamov.github.io/tutorial/csharp/key-down-up-process
	 */
	class KeyUpDownProcessor$1$1 {
	    /**
	     * Данный словарь хранит информацию о том, была ли нажата клавиша.
	     * В качестве ключа выступает номер клавиши,
	     * а значение это флаг (была или не была нажата клавиша).
	     * @private
	     * @link https://learn.javascript.ru/keyboard-events
	     */
	    static #theKeyWasDown = new Map;
	    static onKeyDown(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.#theKeyWasDown.has(keyCode)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.#theKeyWasDown.set(keyCode, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.#theKeyWasDown.get(keyCode)) {
	            // Помечаем что она нажата.
	            this.#theKeyWasDown.set(keyCode, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            action();
	        }
	    }
	    static onKeyUp(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Помечаем что она уже не нажата.
	        this.#theKeyWasDown.set(keyCode, false);
	        // Выполняем действие при отжатии клавиши.
	        action();
	    }
	}
	(t => __RΦ$9$1$3.t[1878] = t)(KeyUpDownProcessor$1$1);
	__RΦ$9$1$3.m("rt:SP", ["#theKeyWasDown"])(KeyUpDownProcessor$1$1);
	__RΦ$9$1$3.m("rt:P", [])(KeyUpDownProcessor$1$1);
	__RΦ$9$1$3.m("rt:Sm", ["onKeyDown", "onKeyUp"])(KeyUpDownProcessor$1$1);
	__RΦ$9$1$3.m("rt:m", [])(KeyUpDownProcessor$1$1);
	__RΦ$9$1$3.m("rt:f", "Ce")(KeyUpDownProcessor$1$1);
	__RΦ$9$1$3.m("rt:t", () => __RΦ$9$1$3.a(1880))(KeyUpDownProcessor$1$1, "#theKeyWasDown");
	__RΦ$9$1$3.m("rt:f", "P")(KeyUpDownProcessor$1$1, "#theKeyWasDown");
	__RΦ$9$1$3.m("rt:f", "M$S.")(KeyUpDownProcessor$1$1["onKeyDown"]);
	((t, p) => __RΦ$9$1$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor$1$1, "onKeyDown");
	__RΦ$9$1$3.m("rt:p", [{ n: "event", t: () => __RΦ$9$1$3.a(1883), v: null }, { n: "action", t: () => __RΦ$9$1$3.a(1890), v: null }])(KeyUpDownProcessor$1$1, "onKeyDown");
	__RΦ$9$1$3.m("rt:f", "M$S.")(KeyUpDownProcessor$1$1, "onKeyDown");
	__RΦ$9$1$3.m("rt:t", () => __RΦ$9$1$3.a(23))(KeyUpDownProcessor$1$1, "onKeyDown");
	__RΦ$9$1$3.m("rt:f", "M$S.")(KeyUpDownProcessor$1$1["onKeyUp"]);
	((t, p) => __RΦ$9$1$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor$1$1, "onKeyUp");
	__RΦ$9$1$3.m("rt:p", [{ n: "event", t: () => __RΦ$9$1$3.a(1883), v: null }, { n: "action", t: () => __RΦ$9$1$3.a(1890), v: null }])(KeyUpDownProcessor$1$1, "onKeyUp");
	__RΦ$9$1$3.m("rt:f", "M$S.")(KeyUpDownProcessor$1$1, "onKeyUp");
	__RΦ$9$1$3.m("rt:t", () => __RΦ$9$1$3.a(23))(KeyUpDownProcessor$1$1, "onKeyUp");
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyDown$1$1(listener) {
	    return __RΦ$9$1$3.f((event) => {
	        KeyUpDownProcessor$1$1.onKeyDown(event, __RΦ$9$1$3.f(() => {
	            listener(event);
	        }, [__RΦ$9$1$3.m("rt:p", []), __RΦ$9$1$3.m("rt:f", "F>"), __RΦ$9$1$3.m("rt:t", () => __RΦ$9$1$3.a(23))], ""));
	    }, [__RΦ$9$1$3.m("rt:p", [{ n: "event", t: () => __RΦ$9$1$3.a(1883), v: null }]), __RΦ$9$1$3.m("rt:f", "F>"), __RΦ$9$1$3.m("rt:t", () => __RΦ$9$1$3.a(23))], "");
	}
	__RΦ$9$1$3.m("rt:p", [{ n: "listener", t: () => __RΦ$9$1$3.a(1893), v: null }])(onKeyDown$1$1);
	__RΦ$9$1$3.m("rt:f", "F")(onKeyDown$1$1);
	__RΦ$9$1$3.m("rt:t", () => __RΦ$9$1$3.a(1897))(onKeyDown$1$1);
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyUp$1$1(listener) {
	    return __RΦ$9$1$3.f((event) => {
	        KeyUpDownProcessor$1$1.onKeyUp(event, __RΦ$9$1$3.f(() => {
	            listener(event);
	        }, [__RΦ$9$1$3.m("rt:p", []), __RΦ$9$1$3.m("rt:f", "F>"), __RΦ$9$1$3.m("rt:t", () => __RΦ$9$1$3.a(23))], ""));
	    }, [__RΦ$9$1$3.m("rt:p", [{ n: "event", t: () => __RΦ$9$1$3.a(1883), v: null }]), __RΦ$9$1$3.m("rt:f", "F>"), __RΦ$9$1$3.m("rt:t", () => __RΦ$9$1$3.a(23))], "");
	}
	__RΦ$9$1$3.m("rt:p", [{ n: "listener", t: () => __RΦ$9$1$3.a(1896), v: null }])(onKeyUp$1$1);
	__RΦ$9$1$3.m("rt:f", "F")(onKeyUp$1$1);
	__RΦ$9$1$3.m("rt:t", () => __RΦ$9$1$3.a(1898))(onKeyUp$1$1);

	const __RΦ$8$1$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$8$1$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$8$1$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$8$1$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$3$1$1 = { name: "IDisposable", prototype: {}, identity: Symbol("IDisposable (interface)") };
	(t => __RΦ$8$1$3.t[147] = t)(IΦdefault$3$1$1);
	__RΦ$8$1$3.m("rt:P", [])(IΦdefault$3$1$1);
	__RΦ$8$1$3.m("rt:m", ["dispose"])(IΦdefault$3$1$1);
	__RΦ$8$1$3.m("rt:f", "Ie")(IΦdefault$3$1$1);
	__RΦ$8$1$3.m("rt:p", [])(IΦdefault$3$1$1.prototype, "dispose");
	__RΦ$8$1$3.m("rt:f", "M")(IΦdefault$3$1$1.prototype, "dispose");
	__RΦ$8$1$3.m("rt:t", () => __RΦ$8$1$3.a(23))(IΦdefault$3$1$1.prototype, "dispose");
	__RΦ$8$1$3.m("rt:p", [])(IΦdefault$3$1$1.prototype, "dispose");
	__RΦ$8$1$3.m("rt:f", "M")(IΦdefault$3$1$1.prototype, "dispose");
	__RΦ$8$1$3.m("rt:t", () => __RΦ$8$1$3.a(23))(IΦdefault$3$1$1.prototype, "dispose");

	const __RΦ$7$1$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$7$1$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$7$1$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$7$1$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1899]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$7$1$3.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) } } };
	var IΦdefault$2$1$1 = { name: "IKeyboardListeners", prototype: {}, identity: Symbol("IKeyboardListeners (interface)") };
	(t => __RΦ$7$1$3.t[1900] = t)(IΦdefault$2$1$1);
	__RΦ$7$1$3.m("rt:P", ["down", "up"])(IΦdefault$2$1$1);
	__RΦ$7$1$3.m("rt:m", [])(IΦdefault$2$1$1);
	__RΦ$7$1$3.m("rt:f", "Ie")(IΦdefault$2$1$1);
	__RΦ$7$1$3.m("rt:t", () => __RΦ$7$1$3.a(1899))(IΦdefault$2$1$1.prototype, "down");
	__RΦ$7$1$3.m("rt:f", "P")(IΦdefault$2$1$1.prototype, "down");
	__RΦ$7$1$3.m("rt:t", () => __RΦ$7$1$3.a(1899))(IΦdefault$2$1$1.prototype, "up");
	__RΦ$7$1$3.m("rt:f", "P")(IΦdefault$2$1$1.prototype, "up");
	__RΦ$7$1$3.m("rt:t", () => __RΦ$7$1$3.a(1899))(IΦdefault$2$1$1.prototype, "down");
	__RΦ$7$1$3.m("rt:f", "P")(IΦdefault$2$1$1.prototype, "down");
	__RΦ$7$1$3.m("rt:t", () => __RΦ$7$1$3.a(1899))(IΦdefault$2$1$1.prototype, "up");
	__RΦ$7$1$3.m("rt:f", "P")(IΦdefault$2$1$1.prototype, "up");

	const __RΦ$6$1$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$6$1$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$6$1$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$6$1$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [709]: { LΦ: t => Object }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1901]: { TΦ: "5", name: "default" }, [2154]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$1$3.a(156), p: [__RΦ$6$1$3.a(14), __RΦ$6$1$3.a(1900)] }) }, [156]: { LΦ: t => Map }, [1900]: { LΦ: t => IΦdefault$2$1$1 }, [1899]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$6$1$3.a(4) }] }) }, [1880]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$1$3.a(156), p: [__RΦ$6$1$3.a(14), __RΦ$6$1$3.a(21)] }) }, [21]: { LΦ: t => Boolean }, [147]: { LΦ: t => IΦdefault$3$1$1 }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1883]: { LΦ: t => KeyboardEvent } } };
	const codeOf$1$1 = __RΦ$6$1$3.f((key) => 'Key' + key.toUpperCase(), [__RΦ$6$1$3.m("rt:p", [{ n: "key", t: () => __RΦ$6$1$3.a(14), v: null }]), __RΦ$6$1$3.m("rt:f", "F>"), __RΦ$6$1$3.m("rt:t", () => __RΦ$6$1$3.a(14))], "codeOf");
	class ShortcutDispatcher$1$1 {
	    static instanceHolder = new Lazy$1$1(() => new ShortcutDispatcher$1$1);
	    static get instance() {
	        return this.instanceHolder.value;
	    }
	    host;
	    listeners = new Map;
	    keyDownListenerBinded;
	    keyUpListenerBinded;
	    theKeyWasDown = new Map;
	    constructor(host = document) {
	        this.host = host;
	        this.keyDownListenerBinded = this.keyDownListener.bind(this);
	        this.keyUpListenerBinded = this.keyUpListener.bind(this);
	        this.host.addEventListener('keydown', this.keyDownListenerBinded);
	        this.host.addEventListener('keyup', this.keyUpListenerBinded);
	    }
	    register(key, listeners) {
	        this.listeners.set(key, listeners);
	        return {
	            dispose: __RΦ$6$1$3.f(() => {
	                this.listeners.delete(key);
	                this.theKeyWasDown.delete(codeOf$1$1(key));
	            }, [__RΦ$6$1$3.m("rt:p", []), __RΦ$6$1$3.m("rt:f", "F>"), __RΦ$6$1$3.m("rt:t", () => __RΦ$6$1$3.a(23))], "dispose")
	        };
	    }
	    keyDownListener(event) {
	        const code = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.theKeyWasDown.has(code)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.theKeyWasDown.set(code, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.theKeyWasDown.get(code)) {
	            // Помечаем что она нажата.
	            this.theKeyWasDown.set(code, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            for (const [key, listeners] of this.listeners.entries()) {
	                if (code === codeOf$1$1(key)) {
	                    listeners.down(event);
	                }
	            }
	        }
	    }
	    keyUpListener(event) {
	        // Из события извлекаем номер нажатой клавиши.
	        const code = event.code;
	        // Помечаем что она уже не нажата.
	        this.theKeyWasDown.set(code, false);
	        // Выполняем действие при отжатии клавиши.
	        for (const [key, listeners] of this.listeners.entries()) {
	            if (code === codeOf$1$1(key)) {
	                listeners.up(event);
	            }
	        }
	    }
	    dispose() {
	        this.host.removeEventListener('keydown', this.keyDownListenerBinded);
	        this.host.removeEventListener('keyup', this.keyUpListenerBinded);
	    }
	}
	(t => __RΦ$6$1$3.t[1901] = t)(ShortcutDispatcher$1$1);
	__RΦ$6$1$3.m("rt:SP", ["instanceHolder", "instance"])(ShortcutDispatcher$1$1);
	__RΦ$6$1$3.m("rt:P", ["host", "listeners", "keyDownListenerBinded", "keyUpListenerBinded", "theKeyWasDown"])(ShortcutDispatcher$1$1);
	__RΦ$6$1$3.m("rt:Sm", [])(ShortcutDispatcher$1$1);
	__RΦ$6$1$3.m("rt:m", ["register", "keyDownListener", "keyUpListener", "dispose"])(ShortcutDispatcher$1$1);
	__RΦ$6$1$3.m("rt:p", [{ n: "host", t: () => __RΦ$6$1$3.a(709), v: function () { return document; } }])(ShortcutDispatcher$1$1);
	__RΦ$6$1$3.m("rt:i", [() => undefined])(ShortcutDispatcher$1$1);
	__RΦ$6$1$3.m("rt:f", "Ce")(ShortcutDispatcher$1$1);
	__RΦ$6$1$3.m("rt:t", () => __RΦ$6$1$3.a(4))(ShortcutDispatcher$1$1, "instanceHolder");
	__RΦ$6$1$3.m("rt:f", "P#R")(ShortcutDispatcher$1$1, "instanceHolder");
	__RΦ$6$1$3.m("rt:t", () => __RΦ$6$1$3.a(1901))(ShortcutDispatcher$1$1, "instance");
	__RΦ$6$1$3.m("rt:f", "P$")(ShortcutDispatcher$1$1, "instance");
	__RΦ$6$1$3.m("rt:t", () => __RΦ$6$1$3.a(709))(ShortcutDispatcher$1$1.prototype, "host");
	__RΦ$6$1$3.m("rt:f", "P#R")(ShortcutDispatcher$1$1.prototype, "host");
	__RΦ$6$1$3.m("rt:t", () => __RΦ$6$1$3.a(2154))(ShortcutDispatcher$1$1.prototype, "listeners");
	__RΦ$6$1$3.m("rt:f", "P#R")(ShortcutDispatcher$1$1.prototype, "listeners");
	__RΦ$6$1$3.m("rt:t", () => __RΦ$6$1$3.a(1899))(ShortcutDispatcher$1$1.prototype, "keyDownListenerBinded");
	__RΦ$6$1$3.m("rt:f", "P#R")(ShortcutDispatcher$1$1.prototype, "keyDownListenerBinded");
	__RΦ$6$1$3.m("rt:t", () => __RΦ$6$1$3.a(1899))(ShortcutDispatcher$1$1.prototype, "keyUpListenerBinded");
	__RΦ$6$1$3.m("rt:f", "P#R")(ShortcutDispatcher$1$1.prototype, "keyUpListenerBinded");
	__RΦ$6$1$3.m("rt:t", () => __RΦ$6$1$3.a(1880))(ShortcutDispatcher$1$1.prototype, "theKeyWasDown");
	__RΦ$6$1$3.m("rt:f", "P#R")(ShortcutDispatcher$1$1.prototype, "theKeyWasDown");
	__RΦ$6$1$3.m("rt:f", "M$")(ShortcutDispatcher$1$1.prototype["register"]);
	((t, p) => __RΦ$6$1$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$1$1.prototype, "register");
	__RΦ$6$1$3.m("rt:p", [{ n: "key", t: () => __RΦ$6$1$3.a(14), v: null }, { n: "listeners", t: () => __RΦ$6$1$3.a(1900), v: null }])(ShortcutDispatcher$1$1.prototype, "register");
	__RΦ$6$1$3.m("rt:f", "M$")(ShortcutDispatcher$1$1.prototype, "register");
	__RΦ$6$1$3.m("rt:t", () => __RΦ$6$1$3.a(147))(ShortcutDispatcher$1$1.prototype, "register");
	__RΦ$6$1$3.m("rt:f", "M#.")(ShortcutDispatcher$1$1.prototype["keyDownListener"]);
	((t, p) => __RΦ$6$1$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$1$1.prototype, "keyDownListener");
	__RΦ$6$1$3.m("rt:p", [{ n: "event", t: () => __RΦ$6$1$3.a(1883), v: null }])(ShortcutDispatcher$1$1.prototype, "keyDownListener");
	__RΦ$6$1$3.m("rt:f", "M#.")(ShortcutDispatcher$1$1.prototype, "keyDownListener");
	__RΦ$6$1$3.m("rt:t", () => __RΦ$6$1$3.a(23))(ShortcutDispatcher$1$1.prototype, "keyDownListener");
	__RΦ$6$1$3.m("rt:f", "M#.")(ShortcutDispatcher$1$1.prototype["keyUpListener"]);
	((t, p) => __RΦ$6$1$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$1$1.prototype, "keyUpListener");
	__RΦ$6$1$3.m("rt:p", [{ n: "event", t: () => __RΦ$6$1$3.a(1883), v: null }])(ShortcutDispatcher$1$1.prototype, "keyUpListener");
	__RΦ$6$1$3.m("rt:f", "M#.")(ShortcutDispatcher$1$1.prototype, "keyUpListener");
	__RΦ$6$1$3.m("rt:t", () => __RΦ$6$1$3.a(23))(ShortcutDispatcher$1$1.prototype, "keyUpListener");
	__RΦ$6$1$3.m("rt:f", "M$.")(ShortcutDispatcher$1$1.prototype["dispose"]);
	((t, p) => __RΦ$6$1$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$1$1.prototype, "dispose");
	__RΦ$6$1$3.m("rt:p", [])(ShortcutDispatcher$1$1.prototype, "dispose");
	__RΦ$6$1$3.m("rt:f", "M$.")(ShortcutDispatcher$1$1.prototype, "dispose");
	__RΦ$6$1$3.m("rt:t", () => __RΦ$6$1$3.a(23))(ShortcutDispatcher$1$1.prototype, "dispose");

	const __RΦ$5$1$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$5$1$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$5$1$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$5$1$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [1900]: { LΦ: t => IΦdefault$2$1$1 }, [147]: { LΦ: t => IΦdefault$3$1$1 } } };
	class Shortcut$1$1 {
	    static register(key, listeners) {
	        return ShortcutDispatcher$1$1.instance.register(key, listeners);
	    }
	}
	(t => __RΦ$5$1$3.t[2183] = t)(Shortcut$1$1);
	__RΦ$5$1$3.m("rt:SP", [])(Shortcut$1$1);
	__RΦ$5$1$3.m("rt:P", [])(Shortcut$1$1);
	__RΦ$5$1$3.m("rt:Sm", ["register"])(Shortcut$1$1);
	__RΦ$5$1$3.m("rt:m", [])(Shortcut$1$1);
	__RΦ$5$1$3.m("rt:f", "Ce")(Shortcut$1$1);
	__RΦ$5$1$3.m("rt:f", "M$S")(Shortcut$1$1["register"]);
	((t, p) => __RΦ$5$1$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Shortcut$1$1, "register");
	__RΦ$5$1$3.m("rt:p", [{ n: "key", t: () => __RΦ$5$1$3.a(14), v: null }, { n: "listeners", t: () => __RΦ$5$1$3.a(1900), v: null }])(Shortcut$1$1, "register");
	__RΦ$5$1$3.m("rt:f", "M$S")(Shortcut$1$1, "register");
	__RΦ$5$1$3.m("rt:t", () => __RΦ$5$1$3.a(147))(Shortcut$1$1, "register");

	const __RΦ$4$1$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$4$1$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$4$1$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$4$1$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [166]: { RΦ: t => ({ TΦ: "[", e: __RΦ$4$1$3.a(165) }) }, [165]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [168]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$4$1$3.a(10), __RΦ$4$1$3.a(167)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [167]: { LΦ: t => Object }, [177]: { RΦ: t => ({ TΦ: "g", t: __RΦ$4$1$3.a(77), p: [__RΦ$4$1$3.a(167)] }) }, [77]: { LΦ: t => Object } } };
	var IΦdefault$1$1$1 = { name: "IQueue", prototype: {}, identity: Symbol("IQueue (interface)") };
	(t => __RΦ$4$1$3.t[178] = t)(IΦdefault$1$1$1);
	__RΦ$4$1$3.m("rt:P", ["items"])(IΦdefault$1$1$1);
	__RΦ$4$1$3.m("rt:m", ["enqueue", "dequeue"])(IΦdefault$1$1$1);
	__RΦ$4$1$3.m("rt:f", "Ie")(IΦdefault$1$1$1);
	__RΦ$4$1$3.m("rt:p", [{ n: "items", t: () => __RΦ$4$1$3.a(166), v: null }])(IΦdefault$1$1$1.prototype, "enqueue");
	__RΦ$4$1$3.m("rt:f", "M")(IΦdefault$1$1$1.prototype, "enqueue");
	__RΦ$4$1$3.m("rt:t", () => __RΦ$4$1$3.a(23))(IΦdefault$1$1$1.prototype, "enqueue");
	__RΦ$4$1$3.m("rt:p", [])(IΦdefault$1$1$1.prototype, "dequeue");
	__RΦ$4$1$3.m("rt:f", "M")(IΦdefault$1$1$1.prototype, "dequeue");
	__RΦ$4$1$3.m("rt:t", () => __RΦ$4$1$3.a(168))(IΦdefault$1$1$1.prototype, "dequeue");
	__RΦ$4$1$3.m("rt:t", () => __RΦ$4$1$3.a(177))(IΦdefault$1$1$1.prototype, "items");
	__RΦ$4$1$3.m("rt:f", "PR")(IΦdefault$1$1$1.prototype, "items");
	__RΦ$4$1$3.m("rt:p", [{ n: "items", t: () => __RΦ$4$1$3.a(166), v: null }])(IΦdefault$1$1$1.prototype, "enqueue");
	__RΦ$4$1$3.m("rt:f", "M")(IΦdefault$1$1$1.prototype, "enqueue");
	__RΦ$4$1$3.m("rt:t", () => __RΦ$4$1$3.a(23))(IΦdefault$1$1$1.prototype, "enqueue");
	__RΦ$4$1$3.m("rt:p", [])(IΦdefault$1$1$1.prototype, "dequeue");
	__RΦ$4$1$3.m("rt:f", "M")(IΦdefault$1$1$1.prototype, "dequeue");
	__RΦ$4$1$3.m("rt:t", () => __RΦ$4$1$3.a(168))(IΦdefault$1$1$1.prototype, "dequeue");
	__RΦ$4$1$3.m("rt:t", () => __RΦ$4$1$3.a(177))(IΦdefault$1$1$1.prototype, "items");
	__RΦ$4$1$3.m("rt:f", "PR")(IΦdefault$1$1$1.prototype, "items");

	const __RΦ$3$2$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$3$2$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$3$2$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$3$2$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [185]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$2$1.a(182) }) }, [182]: { LΦ: t => Object }, [190]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$2$1.a(180) }) }, [180]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [227]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$3$2$1.a(10), __RΦ$3$2$1.a(182)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [228]: { RΦ: t => ({ TΦ: "g", t: __RΦ$3$2$1.a(77), p: [__RΦ$3$2$1.a(182)] }) }, [77]: { LΦ: t => Object } } };
	/**
	 * О́чередь — абстрактный тип данных с дисциплиной доступа к элементам «первый пришёл — первый вышел»
	 * (FIFO, англ. first in, first out).
	 *
	 * Добавление элемента (принято обозначать словом enqueue — поставить в очередь) возможно лишь
	 * в конец очереди, выборка — только из начала очереди (что принято называть словом dequeue — убрать из очереди),
	 * при этом выбранный элемент из очереди удаляется.
	 *
	 * @link https://bit.ly/3tPM13G
	 */
	class Queue$1$1 {
	    storage = [];
	    enqueue(...items) {
	        this.storage.push(...items);
	    }
	    dequeue() {
	        return this.storage.shift();
	    }
	    get items() {
	        return this.storage;
	    }
	}
	(t => __RΦ$3$2$1.t[181] = t)(Queue$1$1);
	__RΦ$3$2$1.m("rt:SP", [])(Queue$1$1);
	__RΦ$3$2$1.m("rt:P", ["storage", "items"])(Queue$1$1);
	__RΦ$3$2$1.m("rt:Sm", [])(Queue$1$1);
	__RΦ$3$2$1.m("rt:m", ["enqueue", "dequeue"])(Queue$1$1);
	__RΦ$3$2$1.m("rt:i", [() => undefined])(Queue$1$1);
	__RΦ$3$2$1.m("rt:f", "Ce")(Queue$1$1);
	__RΦ$3$2$1.m("rt:t", () => __RΦ$3$2$1.a(185))(Queue$1$1.prototype, "storage");
	__RΦ$3$2$1.m("rt:f", "P#")(Queue$1$1.prototype, "storage");
	__RΦ$3$2$1.m("rt:f", "M$")(Queue$1$1.prototype["enqueue"]);
	((t, p) => __RΦ$3$2$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue$1$1.prototype, "enqueue");
	__RΦ$3$2$1.m("rt:p", [{ n: "items", t: () => __RΦ$3$2$1.a(190), v: null }])(Queue$1$1.prototype, "enqueue");
	__RΦ$3$2$1.m("rt:f", "M$")(Queue$1$1.prototype, "enqueue");
	__RΦ$3$2$1.m("rt:t", () => __RΦ$3$2$1.a(23))(Queue$1$1.prototype, "enqueue");
	__RΦ$3$2$1.m("rt:f", "M$")(Queue$1$1.prototype["dequeue"]);
	((t, p) => __RΦ$3$2$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue$1$1.prototype, "dequeue");
	__RΦ$3$2$1.m("rt:p", [])(Queue$1$1.prototype, "dequeue");
	__RΦ$3$2$1.m("rt:f", "M$")(Queue$1$1.prototype, "dequeue");
	__RΦ$3$2$1.m("rt:t", () => __RΦ$3$2$1.a(227))(Queue$1$1.prototype, "dequeue");
	__RΦ$3$2$1.m("rt:t", () => __RΦ$3$2$1.a(228))(Queue$1$1.prototype, "items");
	__RΦ$3$2$1.m("rt:f", "P$")(Queue$1$1.prototype, "items");

	const __RΦ$2$2$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$2$2$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$2$2$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$2$2$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [407]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$2$1.a(404) }) }, [404]: { LΦ: t => Object }, [273]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$2$1.a(178), p: [__RΦ$2$2$1.a(230)] }) }, [178]: { LΦ: t => IΦdefault$1$1$1 }, [230]: { LΦ: t => Object }, [406]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$2$1.a(403), p: [__RΦ$2$2$1.a(230)] }) }, [403]: { TΦ: "5", name: "ILog" }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [622]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$2$1.a(178), p: [__RΦ$2$2$1.a(621)] }) }, [621]: { LΦ: t => Object }, [628]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$2$2$1.a(622) }, { t: __RΦ$2$2$1.a(627) }] }) }, [627]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$2$1.a(229), p: [__RΦ$2$2$1.a(621)] }) }, [229]: { TΦ: "5", name: "default" }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$2$1.a(14), __RΦ$2$2$1.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [397]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [629]: { LΦ: t => Function }, [408]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$2$1.a(230) }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [402]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [630]: { LΦ: t => Function }, [428]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$2$1.a(10), __RΦ$2$2$1.a(230)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	var IΦILog$1$1 = { name: "ILog", prototype: {}, identity: Symbol("ILog (interface)") };
	(t => __RΦ$2$2$1.t[403] = t)(IΦILog$1$1);
	__RΦ$2$2$1.m("rt:P", ["enqueue", "dequeue"])(IΦILog$1$1);
	__RΦ$2$2$1.m("rt:m", [])(IΦILog$1$1);
	__RΦ$2$2$1.m("rt:f", "I")(IΦILog$1$1);
	__RΦ$2$2$1.m("rt:t", () => __RΦ$2$2$1.a(407))(IΦILog$1$1.prototype, "enqueue");
	__RΦ$2$2$1.m("rt:f", "P")(IΦILog$1$1.prototype, "enqueue");
	__RΦ$2$2$1.m("rt:t", () => __RΦ$2$2$1.a(407))(IΦILog$1$1.prototype, "dequeue");
	__RΦ$2$2$1.m("rt:f", "P")(IΦILog$1$1.prototype, "dequeue");
	__RΦ$2$2$1.m("rt:t", () => __RΦ$2$2$1.a(407))(IΦILog$1$1.prototype, "enqueue");
	__RΦ$2$2$1.m("rt:f", "P")(IΦILog$1$1.prototype, "enqueue");
	__RΦ$2$2$1.m("rt:t", () => __RΦ$2$2$1.a(407))(IΦILog$1$1.prototype, "dequeue");
	__RΦ$2$2$1.m("rt:f", "P")(IΦILog$1$1.prototype, "dequeue");
	class QueueLog$1$1 {
	    queue;
	    queueProxy;
	    log = {
	        enqueue: [],
	        dequeue: []
	    };
	    get sourceQueue() {
	        return this.queue;
	    }
	    get loggedQueue() {
	        return this.queueProxy;
	    }
	    static create(queue) {
	        const queueLog = new QueueLog$1$1(queue);
	        return [queueLog.loggedQueue, queueLog];
	    }
	    constructor(queue) {
	        this.queue = queue;
	        this.queueProxy = (new Proxy(queue, {
	            get: this.proxyHandlerGet.bind(this)
	        }));
	    }
	    proxyHandlerGet(target, property, receiver) {
	        const origin = Reflect.get(target, property, receiver);
	        switch (property) {
	            case 'enqueue': return this.createEnqueue(target, origin);
	            case 'dequeue': return this.createDequeue(target, origin);
	            default: return origin;
	        }
	    }
	    createEnqueue(target, origin) {
	        return (__RΦ$2$2$1.f((...items) => {
	            this.log.enqueue.push(...items);
	            origin.call(target, ...items);
	        }, [__RΦ$2$2$1.m("rt:p", [{ n: "items", t: () => __RΦ$2$2$1.a(408), v: null }]), __RΦ$2$2$1.m("rt:f", "F>"), __RΦ$2$2$1.m("rt:t", () => __RΦ$2$2$1.a(23))], ""));
	    }
	    createDequeue(target, origin) {
	        return (__RΦ$2$2$1.f(() => {
	            const item = origin.call(target);
	            if (item) {
	                this.log.dequeue.push(item);
	            }
	            return item;
	        }, [__RΦ$2$2$1.m("rt:p", []), __RΦ$2$2$1.m("rt:f", "F>"), __RΦ$2$2$1.m("rt:t", () => __RΦ$2$2$1.a(428))], ""));
	    }
	}
	(t => __RΦ$2$2$1.t[229] = t)(QueueLog$1$1);
	__RΦ$2$2$1.m("rt:SP", [])(QueueLog$1$1);
	__RΦ$2$2$1.m("rt:P", ["queueProxy", "log", "sourceQueue", "loggedQueue", "queue"])(QueueLog$1$1);
	__RΦ$2$2$1.m("rt:Sm", ["create"])(QueueLog$1$1);
	__RΦ$2$2$1.m("rt:m", ["proxyHandlerGet", "createEnqueue", "createDequeue"])(QueueLog$1$1);
	__RΦ$2$2$1.m("rt:p", [{ n: "queue", t: () => __RΦ$2$2$1.a(273), v: null, f: "#" }])(QueueLog$1$1);
	__RΦ$2$2$1.m("rt:f", "Ce")(QueueLog$1$1);
	__RΦ$2$2$1.m("rt:t", () => __RΦ$2$2$1.a(273))(QueueLog$1$1.prototype, "queueProxy");
	__RΦ$2$2$1.m("rt:f", "P#R")(QueueLog$1$1.prototype, "queueProxy");
	__RΦ$2$2$1.m("rt:t", () => __RΦ$2$2$1.a(406))(QueueLog$1$1.prototype, "log");
	__RΦ$2$2$1.m("rt:f", "P#")(QueueLog$1$1.prototype, "log");
	__RΦ$2$2$1.m("rt:t", () => __RΦ$2$2$1.a(4))(QueueLog$1$1.prototype, "sourceQueue");
	__RΦ$2$2$1.m("rt:f", "P$")(QueueLog$1$1.prototype, "sourceQueue");
	__RΦ$2$2$1.m("rt:t", () => __RΦ$2$2$1.a(4))(QueueLog$1$1.prototype, "loggedQueue");
	__RΦ$2$2$1.m("rt:f", "P$")(QueueLog$1$1.prototype, "loggedQueue");
	__RΦ$2$2$1.m("rt:f", "M$S")(QueueLog$1$1["create"]);
	((t, p) => __RΦ$2$2$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$1$1, "create");
	__RΦ$2$2$1.m("rt:p", [{ n: "queue", t: () => __RΦ$2$2$1.a(622), v: null }])(QueueLog$1$1, "create");
	__RΦ$2$2$1.m("rt:f", "M$S")(QueueLog$1$1, "create");
	__RΦ$2$2$1.m("rt:t", () => __RΦ$2$2$1.a(628))(QueueLog$1$1, "create");
	__RΦ$2$2$1.m("rt:f", "M#")(QueueLog$1$1.prototype["proxyHandlerGet"]);
	((t, p) => __RΦ$2$2$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$1$1.prototype, "proxyHandlerGet");
	__RΦ$2$2$1.m("rt:p", [{ n: "target", t: () => __RΦ$2$2$1.a(273), v: null }, { n: "property", t: () => __RΦ$2$2$1.a(143), v: null }, { n: "receiver", t: () => __RΦ$2$2$1.a(1), v: null }])(QueueLog$1$1.prototype, "proxyHandlerGet");
	__RΦ$2$2$1.m("rt:f", "M#")(QueueLog$1$1.prototype, "proxyHandlerGet");
	__RΦ$2$2$1.m("rt:t", () => __RΦ$2$2$1.a(1))(QueueLog$1$1.prototype, "proxyHandlerGet");
	__RΦ$2$2$1.m("rt:f", "M#.")(QueueLog$1$1.prototype["createEnqueue"]);
	((t, p) => __RΦ$2$2$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$1$1.prototype, "createEnqueue");
	__RΦ$2$2$1.m("rt:p", [{ n: "target", t: () => __RΦ$2$2$1.a(273), v: null }, { n: "origin", t: () => __RΦ$2$2$1.a(397), v: null }])(QueueLog$1$1.prototype, "createEnqueue");
	__RΦ$2$2$1.m("rt:f", "M#.")(QueueLog$1$1.prototype, "createEnqueue");
	__RΦ$2$2$1.m("rt:t", () => __RΦ$2$2$1.a(629))(QueueLog$1$1.prototype, "createEnqueue");
	__RΦ$2$2$1.m("rt:f", "M#.")(QueueLog$1$1.prototype["createDequeue"]);
	((t, p) => __RΦ$2$2$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$1$1.prototype, "createDequeue");
	__RΦ$2$2$1.m("rt:p", [{ n: "target", t: () => __RΦ$2$2$1.a(273), v: null }, { n: "origin", t: () => __RΦ$2$2$1.a(402), v: null }])(QueueLog$1$1.prototype, "createDequeue");
	__RΦ$2$2$1.m("rt:f", "M#.")(QueueLog$1$1.prototype, "createDequeue");
	__RΦ$2$2$1.m("rt:t", () => __RΦ$2$2$1.a(630))(QueueLog$1$1.prototype, "createDequeue");

	const __RΦ$1$2$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$1$2$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$1$2$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$1$2$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$1$2$1.a(14), __RΦ$1$2$1.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [144]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$1$2$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [146]: { RΦ: t => ({ TΦ: "t" }) } } };
	var IΦdefault$b$2 = { name: "IEventEmitter", prototype: {}, identity: Symbol("IEventEmitter (interface)") };
	(t => __RΦ$1$2$1.t[145] = t)(IΦdefault$b$2);
	__RΦ$1$2$1.m("rt:P", [])(IΦdefault$b$2);
	__RΦ$1$2$1.m("rt:m", ["on"])(IΦdefault$b$2);
	__RΦ$1$2$1.m("rt:f", "Ie")(IΦdefault$b$2);
	__RΦ$1$2$1.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$2$1.a(143), v: null }, { n: "listener", t: () => __RΦ$1$2$1.a(144), v: null }])(IΦdefault$b$2.prototype, "on");
	__RΦ$1$2$1.m("rt:f", "M")(IΦdefault$b$2.prototype, "on");
	__RΦ$1$2$1.m("rt:t", () => __RΦ$1$2$1.a(146))(IΦdefault$b$2.prototype, "on");
	__RΦ$1$2$1.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$2$1.a(143), v: null }, { n: "listener", t: () => __RΦ$1$2$1.a(144), v: null }])(IΦdefault$b$2.prototype, "on");
	__RΦ$1$2$1.m("rt:f", "M")(IΦdefault$b$2.prototype, "on");
	__RΦ$1$2$1.m("rt:t", () => __RΦ$1$2$1.a(146))(IΦdefault$b$2.prototype, "on");

	const __RΦ$v$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$v$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$v$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$v$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [4]: { RΦ: t => ({ TΦ: "~" }) }, [641]: { RΦ: t => ({ TΦ: "[", e: __RΦ$v$2.a(631) }) }, [631]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [658]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$v$2.a(10), __RΦ$v$2.a(633)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [633]: { LΦ: t => Object }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$v$2.a(14), __RΦ$v$2.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [662]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$v$2.a(4) }] }) }, [634]: { RΦ: t => ({ TΦ: "t" }) } } };
	class QueueWithEventEmitter$1$1 extends Queue$1$1 {
	    eventEmitter = new EventEmitter$2$1;
	    enqueue(...items) {
	        this.eventEmitter.emit('before-enqueue', this, ...items);
	        super.enqueue(...items);
	        this.eventEmitter.emit('enqueue', this, ...items);
	    }
	    dequeue() {
	        const removed = super.dequeue();
	        this.eventEmitter.emit('dequeue', this, removed);
	        return removed;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	}
	(t => __RΦ$v$2.t[632] = t)(QueueWithEventEmitter$1$1);
	__RΦ$v$2.m("rt:SP", [])(QueueWithEventEmitter$1$1);
	__RΦ$v$2.m("rt:P", ["eventEmitter"])(QueueWithEventEmitter$1$1);
	__RΦ$v$2.m("rt:Sm", [])(QueueWithEventEmitter$1$1);
	__RΦ$v$2.m("rt:m", ["enqueue", "dequeue", "on"])(QueueWithEventEmitter$1$1);
	__RΦ$v$2.m("rt:i", [() => undefined])(QueueWithEventEmitter$1$1);
	__RΦ$v$2.m("rt:f", "Ce")(QueueWithEventEmitter$1$1);
	__RΦ$v$2.m("rt:t", () => __RΦ$v$2.a(4))(QueueWithEventEmitter$1$1.prototype, "eventEmitter");
	__RΦ$v$2.m("rt:f", "P#")(QueueWithEventEmitter$1$1.prototype, "eventEmitter");
	__RΦ$v$2.m("rt:f", "M$")(QueueWithEventEmitter$1$1.prototype["enqueue"]);
	((t, p) => __RΦ$v$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$1$1.prototype, "enqueue");
	__RΦ$v$2.m("rt:p", [{ n: "items", t: () => __RΦ$v$2.a(641), v: null }])(QueueWithEventEmitter$1$1.prototype, "enqueue");
	__RΦ$v$2.m("rt:f", "M$")(QueueWithEventEmitter$1$1.prototype, "enqueue");
	__RΦ$v$2.m("rt:t", () => __RΦ$v$2.a(23))(QueueWithEventEmitter$1$1.prototype, "enqueue");
	__RΦ$v$2.m("rt:f", "M$")(QueueWithEventEmitter$1$1.prototype["dequeue"]);
	((t, p) => __RΦ$v$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$1$1.prototype, "dequeue");
	__RΦ$v$2.m("rt:p", [])(QueueWithEventEmitter$1$1.prototype, "dequeue");
	__RΦ$v$2.m("rt:f", "M$")(QueueWithEventEmitter$1$1.prototype, "dequeue");
	__RΦ$v$2.m("rt:t", () => __RΦ$v$2.a(658))(QueueWithEventEmitter$1$1.prototype, "dequeue");
	__RΦ$v$2.m("rt:f", "M$")(QueueWithEventEmitter$1$1.prototype["on"]);
	((t, p) => __RΦ$v$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$1$1.prototype, "on");
	__RΦ$v$2.m("rt:p", [{ n: "eventName", t: () => __RΦ$v$2.a(143), v: null }, { n: "listener", t: () => __RΦ$v$2.a(662), v: null }])(QueueWithEventEmitter$1$1.prototype, "on");
	__RΦ$v$2.m("rt:f", "M$")(QueueWithEventEmitter$1$1.prototype, "on");
	__RΦ$v$2.m("rt:t", () => __RΦ$v$2.a(634))(QueueWithEventEmitter$1$1.prototype, "on");

	const __RΦ$u$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$u$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$u$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$u$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [92]: { RΦ: t => ({ TΦ: "g", t: __RΦ$u$2.a(87), p: [__RΦ$u$2.a(14), __RΦ$u$2.a(91)] }) }, [87]: { LΦ: t => Map }, [14]: { LΦ: t => String }, [91]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$u$2.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	class DependencyRegistrator {
	    dependencyMap;
	    dependencyName;
	    resolver;
	    constructor(dependencyMap, dependencyName, resolver) {
	        this.dependencyMap = dependencyMap;
	        this.dependencyName = dependencyName;
	        this.resolver = resolver;
	    }
	    register() {
	        if (this.dependencyMap.has(this.dependencyName)) {
	            throw new Error(`Зависимость '${this.dependencyName}' уже зарегистрирована`);
	        }
	        this.dependencyMap.set(this.dependencyName, this.resolver);
	    }
	}
	(t => __RΦ$u$2.t[84] = t)(DependencyRegistrator);
	__RΦ$u$2.m("rt:SP", [])(DependencyRegistrator);
	__RΦ$u$2.m("rt:P", ["dependencyMap", "dependencyName", "resolver"])(DependencyRegistrator);
	__RΦ$u$2.m("rt:Sm", [])(DependencyRegistrator);
	__RΦ$u$2.m("rt:m", ["register"])(DependencyRegistrator);
	__RΦ$u$2.m("rt:p", [{ n: "dependencyMap", t: () => __RΦ$u$2.a(92), v: null, f: "#" }, { n: "dependencyName", t: () => __RΦ$u$2.a(14), v: null, f: "#" }, { n: "resolver", t: () => __RΦ$u$2.a(91), v: null, f: "#" }])(DependencyRegistrator);
	__RΦ$u$2.m("rt:i", [() => undefined])(DependencyRegistrator);
	__RΦ$u$2.m("rt:f", "Ce")(DependencyRegistrator);
	__RΦ$u$2.m("rt:f", "M")(DependencyRegistrator.prototype["register"]);
	((t, p) => __RΦ$u$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(DependencyRegistrator.prototype, "register");
	__RΦ$u$2.m("rt:p", [])(DependencyRegistrator.prototype, "register");
	__RΦ$u$2.m("rt:f", "M")(DependencyRegistrator.prototype, "register");
	__RΦ$u$2.m("rt:t", () => __RΦ$u$2.a(23))(DependencyRegistrator.prototype, "register");

	const __RΦ$t$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$t$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$t$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$t$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [91]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$t$5.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [100]: { LΦ: t => undefined }, [101]: { RΦ: t => ({ TΦ: "g", t: __RΦ$t$5.a(87), p: [__RΦ$t$5.a(14), __RΦ$t$5.a(91)] }) }, [87]: { LΦ: t => Map } } };
	var createRegistratorResolver = (__RΦ$t$5.f(function createRegistratorResolver(dependencyMap) {
	    return (__RΦ$t$5.f((dependencyName, resolver) => (new DependencyRegistrator(dependencyMap, dependencyName, resolver)), [__RΦ$t$5.m("rt:p", [{ n: "dependencyName", t: () => __RΦ$t$5.a(14), v: null }, { n: "resolver", t: () => __RΦ$t$5.a(91), v: null }]), __RΦ$t$5.m("rt:f", "F>"), __RΦ$t$5.m("rt:t", () => __RΦ$t$5.a(100))], ""));
	}, [__RΦ$t$5.m("rt:p", [{ n: "dependencyMap", t: () => __RΦ$t$5.a(101), v: null }]), __RΦ$t$5.m("rt:f", "M"), __RΦ$t$5.m("rt:t", () => __RΦ$t$5.a(91))], ""));

	var dist$6 = {};

	Object.defineProperty(dist$6, '__esModule', { value: true });

	var EventEmitter$8 = events$5.exports;

	function _interopDefaultLegacy$6 (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var EventEmitter__default$5 = /*#__PURE__*/_interopDefaultLegacy$6(EventEmitter$8);

	const __RΦ$r$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$r$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$r$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$r$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [95]: { LΦ: t => SyntaxError }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Обработчик синтаксической ошибки в коде source.
	 * @param error
	 * @param source
	 */
	function syntaxErrorHandler$6(error, source) {
	    console.group('Синтаксическая ошибка');
	    console.log(error.message);
	    console.log(source);
	    console.log(error.stack);
	    console.groupEnd();
	}
	__RΦ$r$6.m("rt:p", [{ n: "error", t: () => __RΦ$r$6.a(95), v: null }, { n: "source", t: () => __RΦ$r$6.a(14), v: null }])(syntaxErrorHandler$6);
	__RΦ$r$6.m("rt:f", "F")(syntaxErrorHandler$6);
	__RΦ$r$6.m("rt:t", () => __RΦ$r$6.a(23))(syntaxErrorHandler$6);

	const __RΦ$q$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$q$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$q$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$q$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [112]: { LΦ: t => Object } } };
	/**
	 * Выполнить скрипт из текста, который возвращает значение типа T.
	 * @param source
	 */
	function execFunctionScript$6(source) {
	    if (!source.trim()) {
	        throw new Error('Не задано тело функции');
	    }
	    try {
	        const code = new Function('', `return (${source})`);
	        return code();
	    }
	    catch (error) {
	        if (error instanceof SyntaxError) {
	            syntaxErrorHandler$6(error, source);
	        }
	        throw error;
	    }
	}
	__RΦ$q$6.m("rt:p", [{ n: "source", t: () => __RΦ$q$6.a(14), v: null }])(execFunctionScript$6);
	__RΦ$q$6.m("rt:f", "F")(execFunctionScript$6);
	__RΦ$q$6.m("rt:t", () => __RΦ$q$6.a(112))(execFunctionScript$6);

	const __RΦ$p$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$p$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$p$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$p$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [113]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$p$6.a(10), __RΦ$p$6.a(14)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Выполнить скрипт из текста, который ничего не возвращает.
	 * @param source
	 */
	function execActionScript$6(source) {
	    if (source) {
	        try {
	            const code = new Function('', source);
	            code();
	        }
	        catch (error) {
	            if (error instanceof SyntaxError) {
	                syntaxErrorHandler$6(error, source);
	            }
	            throw error;
	        }
	    }
	}
	__RΦ$p$6.m("rt:p", [{ n: "source", t: () => __RΦ$p$6.a(113), v: null }])(execActionScript$6);
	__RΦ$p$6.m("rt:f", "F")(execActionScript$6);
	__RΦ$p$6.m("rt:t", () => __RΦ$p$6.a(23))(execActionScript$6);

	const __RΦ$o$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$o$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$o$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$o$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String } } };
	const SPACE$6 = ' ';
	const EOL$6 = '\n';
	const trim$6 = __RΦ$o$6.f((message) => message.trim()
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	, [__RΦ$o$6.m("rt:p", [{ n: "message", t: () => __RΦ$o$6.a(14), v: null }]), __RΦ$o$6.m("rt:f", "F>"), __RΦ$o$6.m("rt:t", () => __RΦ$o$6.a(14))], "trim");
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	function toOneLine$6(message) {
	    return message.trim().split(EOL$6).map(trim$6).join(SPACE$6);
	}
	__RΦ$o$6.m("rt:p", [{ n: "message", t: () => __RΦ$o$6.a(14), v: null }])(toOneLine$6);
	__RΦ$o$6.m("rt:f", "F")(toOneLine$6);
	__RΦ$o$6.m("rt:t", () => __RΦ$o$6.a(14))(toOneLine$6);

	const __RΦ$n$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$n$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$n$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$n$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1]: { RΦ: t => ({ TΦ: "~" }) } } };
	function isBrowser$6() {
	    return new Function('try { return this === window } catch (e) { return false }')();
	}
	__RΦ$n$6.m("rt:p", [])(isBrowser$6);
	__RΦ$n$6.m("rt:f", "F")(isBrowser$6);
	__RΦ$n$6.m("rt:t", () => __RΦ$n$6.a(1))(isBrowser$6);

	const __RΦ$m$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$m$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$m$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$m$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [21]: { LΦ: t => Boolean } } };
	var IΦdefault$9$6 = { name: "IStoppable", prototype: {}, identity: Symbol("IStoppable (interface)") };
	(t => __RΦ$m$6.t[150] = t)(IΦdefault$9$6);
	__RΦ$m$6.m("rt:P", [])(IΦdefault$9$6);
	__RΦ$m$6.m("rt:m", ["stop"])(IΦdefault$9$6);
	__RΦ$m$6.m("rt:f", "Ie")(IΦdefault$9$6);
	__RΦ$m$6.m("rt:p", [])(IΦdefault$9$6.prototype, "stop");
	__RΦ$m$6.m("rt:f", "M")(IΦdefault$9$6.prototype, "stop");
	__RΦ$m$6.m("rt:t", () => __RΦ$m$6.a(23))(IΦdefault$9$6.prototype, "stop");
	__RΦ$m$6.m("rt:p", [])(IΦdefault$9$6.prototype, "stop");
	__RΦ$m$6.m("rt:f", "M")(IΦdefault$9$6.prototype, "stop");
	__RΦ$m$6.m("rt:t", () => __RΦ$m$6.a(23))(IΦdefault$9$6.prototype, "stop");
	function isStoppable$6(object) {
	    return 'stop' in object && typeof object.stop === 'function';
	}
	__RΦ$m$6.m("rt:p", [{ n: "object", t: () => __RΦ$m$6.a(1), v: null }])(isStoppable$6);
	__RΦ$m$6.m("rt:f", "F")(isStoppable$6);
	__RΦ$m$6.m("rt:t", () => __RΦ$m$6.a(21))(isStoppable$6);

	const __RΦ$l$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$l$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$l$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$l$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$8$6 = { name: "IStartable", prototype: {}, identity: Symbol("IStartable (interface)") };
	(t => __RΦ$l$6.t[149] = t)(IΦdefault$8$6);
	__RΦ$l$6.m("rt:P", [])(IΦdefault$8$6);
	__RΦ$l$6.m("rt:m", ["start"])(IΦdefault$8$6);
	__RΦ$l$6.m("rt:f", "Ie")(IΦdefault$8$6);
	__RΦ$l$6.m("rt:p", [])(IΦdefault$8$6.prototype, "start");
	__RΦ$l$6.m("rt:f", "M")(IΦdefault$8$6.prototype, "start");
	__RΦ$l$6.m("rt:t", () => __RΦ$l$6.a(23))(IΦdefault$8$6.prototype, "start");
	__RΦ$l$6.m("rt:p", [])(IΦdefault$8$6.prototype, "start");
	__RΦ$l$6.m("rt:f", "M")(IΦdefault$8$6.prototype, "start");
	__RΦ$l$6.m("rt:t", () => __RΦ$l$6.a(23))(IΦdefault$8$6.prototype, "start");

	/**
	 * Состояния таймера.
	 */
	var ETimerState$6;
	(function (ETimerState) {
	    ETimerState["Started"] = "started";
	    ETimerState["Paused"] = "paused";
	    ETimerState["Stopped"] = "stopped";
	})(ETimerState$6 || (ETimerState$6 = {}));

	const __RΦ$k$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$k$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$k$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$k$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [666]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$k$6.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [667]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$k$6.a(4) }] }) }, [668]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$k$6.a(4) }] }) } } };
	var IΦdefault$7$6 = { name: "IStateHandlers", prototype: {}, identity: Symbol("IStateHandlers (interface)") };
	(t => __RΦ$k$6.t[669] = t)(IΦdefault$7$6);
	__RΦ$k$6.m("rt:P", ["started", "paused", "stopped"])(IΦdefault$7$6);
	__RΦ$k$6.m("rt:m", [])(IΦdefault$7$6);
	__RΦ$k$6.m("rt:f", "Ie")(IΦdefault$7$6);
	__RΦ$k$6.m("rt:t", () => __RΦ$k$6.a(666))(IΦdefault$7$6.prototype, "started");
	__RΦ$k$6.m("rt:f", "P?")(IΦdefault$7$6.prototype, "started");
	__RΦ$k$6.m("rt:t", () => __RΦ$k$6.a(667))(IΦdefault$7$6.prototype, "paused");
	__RΦ$k$6.m("rt:f", "P?")(IΦdefault$7$6.prototype, "paused");
	__RΦ$k$6.m("rt:t", () => __RΦ$k$6.a(668))(IΦdefault$7$6.prototype, "stopped");
	__RΦ$k$6.m("rt:f", "P?")(IΦdefault$7$6.prototype, "stopped");
	__RΦ$k$6.m("rt:t", () => __RΦ$k$6.a(666))(IΦdefault$7$6.prototype, "started");
	__RΦ$k$6.m("rt:f", "P?")(IΦdefault$7$6.prototype, "started");
	__RΦ$k$6.m("rt:t", () => __RΦ$k$6.a(667))(IΦdefault$7$6.prototype, "paused");
	__RΦ$k$6.m("rt:f", "P?")(IΦdefault$7$6.prototype, "paused");
	__RΦ$k$6.m("rt:t", () => __RΦ$k$6.a(668))(IΦdefault$7$6.prototype, "stopped");
	__RΦ$k$6.m("rt:f", "P?")(IΦdefault$7$6.prototype, "stopped");

	const __RΦ$j$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$j$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$j$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$j$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [689]: { RΦ: t => ({ TΦ: "e", e: ETimerState$6 }) }, [673]: { RΦ: t => ({ TΦ: "g", t: __RΦ$j$6.a(669), p: [__RΦ$j$6.a(672)] }) }, [669]: { LΦ: t => IΦdefault$7$6 }, [672]: { LΦ: t => Object }, [690]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$j$6.a(10), __RΦ$j$6.a(672)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	/**
	 * Запустить определенный скрипт в зависимости от состояния таймера.
	 * @param state Текущее состояние таймера.
	 * @param stateHandlers Массив скриптов (ключ - имя состояния, значение - скрипт).
	 */
	function handleByState$6(state, stateHandlers) {
	    switch (state) {
	        case ETimerState$6.Started: return stateHandlers.started ? stateHandlers.started() : undefined;
	        case ETimerState$6.Paused: return stateHandlers.paused ? stateHandlers.paused() : undefined;
	        case ETimerState$6.Stopped: return stateHandlers.stopped ? stateHandlers.stopped() : undefined;
	    }
	}
	__RΦ$j$6.m("rt:p", [{ n: "state", t: () => __RΦ$j$6.a(689), v: null }, { n: "stateHandlers", t: () => __RΦ$j$6.a(673), v: null }])(handleByState$6);
	__RΦ$j$6.m("rt:f", "F")(handleByState$6);
	__RΦ$j$6.m("rt:t", () => __RΦ$j$6.a(690))(handleByState$6);

	const __RΦ$i$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$i$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$i$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$i$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [1603]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$i$6.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1551]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$i$6.a(10), __RΦ$i$6.a(15)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [689]: { RΦ: t => ({ TΦ: "e", e: ETimerState$6 }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Простая реализация таймера.
	 */
	class Timer$6 {
	    timeout;
	    action;
	    timerId;
	    /**
	     * Время запуска таймера. В миллисекундах.
	     * @private
	     */
	    time = 0;
	    /**
	     * Время постановки на паузу. В миллисекундах.
	     * @private
	     */
	    pauseTime = 0;
	    /**
	     * Общее время остановки таймера. В миллисекундах.
	     * @private
	     */
	    pauseInterval = 0;
	    /**
	     * Текущее состояние таймера
	     * @private
	     */
	    state = ETimerState$6.Stopped;
	    /**
	     * Внимание, внутри action определена this как Timer.
	     * @param timeout
	     * @param action
	     */
	    constructor(timeout, action) {
	        this.timeout = timeout;
	        this.action = action;
	    }
	    /**
	     * Запуск таймера.
	     * Стартовать таймер сначала или продолжить с паузы.
	     */
	    start() {
	        handleByState$6(this.state, {
	            paused: __RΦ$i$6.f(() => {
	                this.state = ETimerState$6.Started;
	                this.pauseInterval += Date.now() - this.pauseTime;
	            }, [__RΦ$i$6.m("rt:p", []), __RΦ$i$6.m("rt:f", "F>"), __RΦ$i$6.m("rt:t", () => __RΦ$i$6.a(23))], "paused"),
	            stopped: __RΦ$i$6.f(() => {
	                this.state = ETimerState$6.Started;
	                this.timerId = window.setInterval(this.tick.bind(this), this.timeout);
	                this.time = Date.now();
	            }, [__RΦ$i$6.m("rt:p", []), __RΦ$i$6.m("rt:f", "F>"), __RΦ$i$6.m("rt:t", () => __RΦ$i$6.a(23))], "stopped")
	        });
	    }
	    /**
	     * Поставить на паузу таймер.
	     * Состояние сохраняется, счет приостанавливается.
	     */
	    pause() {
	        handleByState$6(this.state, {
	            started: __RΦ$i$6.f(() => {
	                this.state = ETimerState$6.Paused;
	                this.pauseTime = Date.now();
	            }, [__RΦ$i$6.m("rt:p", []), __RΦ$i$6.m("rt:f", "F>"), __RΦ$i$6.m("rt:t", () => __RΦ$i$6.a(23))], "started")
	        });
	    }
	    /**
	     * Остановить таймер.
	     * Полный сброс таймера.
	     */
	    stop() {
	        const stop = __RΦ$i$6.f(() => {
	            this.state = ETimerState$6.Stopped;
	            clearInterval(this.timerId);
	            this.timerId = undefined;
	            this.time = 0;
	        }, [__RΦ$i$6.m("rt:p", []), __RΦ$i$6.m("rt:f", "F>"), __RΦ$i$6.m("rt:t", () => __RΦ$i$6.a(23))], "stop");
	        handleByState$6(this.state, {
	            started: stop,
	            paused: stop
	        });
	    }
	    /**
	     * Количество миллисекунд с начала старта таймера.
	     * С учетом всех пауз.
	     */
	    get interval() {
	        const result = handleByState$6(this.state, {
	            started: () => Date.now() - this.time - this.pauseTime,
	            paused: () => this.time - this.pauseTime,
	            stopped: () => 0
	        });
	        return result === undefined ? 0 : result;
	    }
	    /**
	     * Выполняемая нагрузка таймера.
	     * @private
	     */
	    tick() {
	        handleByState$6(this.state, {
	            started: __RΦ$i$6.f(() => this.action.call(this), [__RΦ$i$6.m("rt:p", []), __RΦ$i$6.m("rt:f", "F>"), __RΦ$i$6.m("rt:t", () => __RΦ$i$6.a(23))], "started")
	        });
	    }
	}
	(t => __RΦ$i$6.t[692] = t)(Timer$6);
	__RΦ$i$6.m("rt:SP", [])(Timer$6);
	__RΦ$i$6.m("rt:P", ["timerId", "time", "pauseTime", "pauseInterval", "state", "timeout", "action", "interval"])(Timer$6);
	__RΦ$i$6.m("rt:Sm", [])(Timer$6);
	__RΦ$i$6.m("rt:m", ["start", "pause", "stop", "tick"])(Timer$6);
	__RΦ$i$6.m("rt:p", [{ n: "timeout", t: () => __RΦ$i$6.a(15), v: null, f: "#" }, { n: "action", t: () => __RΦ$i$6.a(1603), v: null, f: "#" }])(Timer$6);
	__RΦ$i$6.m("rt:i", [() => undefined, () => undefined])(Timer$6);
	__RΦ$i$6.m("rt:f", "Ce")(Timer$6);
	__RΦ$i$6.m("rt:t", () => __RΦ$i$6.a(1551))(Timer$6.prototype, "timerId");
	__RΦ$i$6.m("rt:f", "P#")(Timer$6.prototype, "timerId");
	__RΦ$i$6.m("rt:t", () => __RΦ$i$6.a(15))(Timer$6.prototype, "time");
	__RΦ$i$6.m("rt:f", "P#")(Timer$6.prototype, "time");
	__RΦ$i$6.m("rt:t", () => __RΦ$i$6.a(15))(Timer$6.prototype, "pauseTime");
	__RΦ$i$6.m("rt:f", "P#")(Timer$6.prototype, "pauseTime");
	__RΦ$i$6.m("rt:t", () => __RΦ$i$6.a(15))(Timer$6.prototype, "pauseInterval");
	__RΦ$i$6.m("rt:f", "P#")(Timer$6.prototype, "pauseInterval");
	__RΦ$i$6.m("rt:t", () => __RΦ$i$6.a(689))(Timer$6.prototype, "state");
	__RΦ$i$6.m("rt:f", "P#")(Timer$6.prototype, "state");
	__RΦ$i$6.m("rt:f", "M$.")(Timer$6.prototype["start"]);
	((t, p) => __RΦ$i$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$6.prototype, "start");
	__RΦ$i$6.m("rt:p", [])(Timer$6.prototype, "start");
	__RΦ$i$6.m("rt:f", "M$.")(Timer$6.prototype, "start");
	__RΦ$i$6.m("rt:t", () => __RΦ$i$6.a(23))(Timer$6.prototype, "start");
	__RΦ$i$6.m("rt:f", "M$.")(Timer$6.prototype["pause"]);
	((t, p) => __RΦ$i$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$6.prototype, "pause");
	__RΦ$i$6.m("rt:p", [])(Timer$6.prototype, "pause");
	__RΦ$i$6.m("rt:f", "M$.")(Timer$6.prototype, "pause");
	__RΦ$i$6.m("rt:t", () => __RΦ$i$6.a(23))(Timer$6.prototype, "pause");
	__RΦ$i$6.m("rt:f", "M$.")(Timer$6.prototype["stop"]);
	((t, p) => __RΦ$i$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$6.prototype, "stop");
	__RΦ$i$6.m("rt:p", [])(Timer$6.prototype, "stop");
	__RΦ$i$6.m("rt:f", "M$.")(Timer$6.prototype, "stop");
	__RΦ$i$6.m("rt:t", () => __RΦ$i$6.a(23))(Timer$6.prototype, "stop");
	__RΦ$i$6.m("rt:t", () => __RΦ$i$6.a(15))(Timer$6.prototype, "interval");
	__RΦ$i$6.m("rt:f", "P$")(Timer$6.prototype, "interval");
	__RΦ$i$6.m("rt:f", "M#.")(Timer$6.prototype["tick"]);
	((t, p) => __RΦ$i$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$6.prototype, "tick");
	__RΦ$i$6.m("rt:p", [])(Timer$6.prototype, "tick");
	__RΦ$i$6.m("rt:f", "M#.")(Timer$6.prototype, "tick");
	__RΦ$i$6.m("rt:t", () => __RΦ$i$6.a(23))(Timer$6.prototype, "tick");

	const __RΦ$h$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$h$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$h$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$h$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1607]: { LΦ: t => Object } } };
	var IΦdefault$6$6 = { name: "ICreator", prototype: {}, identity: Symbol("ICreator (interface)") };
	(t => __RΦ$h$6.t[1608] = t)(IΦdefault$6$6);
	__RΦ$h$6.m("rt:P", [])(IΦdefault$6$6);
	__RΦ$h$6.m("rt:m", ["create"])(IΦdefault$6$6);
	__RΦ$h$6.m("rt:f", "Ie")(IΦdefault$6$6);
	__RΦ$h$6.m("rt:p", [])(IΦdefault$6$6.prototype, "create");
	__RΦ$h$6.m("rt:f", "M")(IΦdefault$6$6.prototype, "create");
	__RΦ$h$6.m("rt:t", () => __RΦ$h$6.a(1607))(IΦdefault$6$6.prototype, "create");
	__RΦ$h$6.m("rt:p", [])(IΦdefault$6$6.prototype, "create");
	__RΦ$h$6.m("rt:f", "M")(IΦdefault$6$6.prototype, "create");
	__RΦ$h$6.m("rt:t", () => __RΦ$h$6.a(1607))(IΦdefault$6$6.prototype, "create");

	const __RΦ$g$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$g$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$g$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$g$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1610]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$g$6.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1618]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$g$6.a(10), __RΦ$g$6.a(1612)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1612]: { LΦ: t => Object }, [1615]: { RΦ: t => ({ TΦ: "g", t: __RΦ$g$6.a(1608), p: [__RΦ$g$6.a(1612)] }) }, [1608]: { LΦ: t => IΦdefault$6$6 } } };
	/**
	 * Отложенная инициализация.
	 * @link https://metanit.com/sharp/tutorial/20.1.php
	 * @link https://docs.microsoft.com/ru-ru/dotnet/api/system.lazy-1?view=net-5.0
	 */
	class Lazy$6 {
	    createFn;
	    #value;
	    #creator;
	    constructor(createFn) {
	        this.createFn = createFn;
	        this.#creator = {
	            create() {
	                return createFn();
	            }
	        };
	    }
	    get value() {
	        if (!this.#value) {
	            this.#value = this.#creator.create();
	        }
	        return this.#value;
	    }
	}
	(t => __RΦ$g$6.t[1611] = t)(Lazy$6);
	__RΦ$g$6.m("rt:SP", [])(Lazy$6);
	__RΦ$g$6.m("rt:P", ["#value", "#creator", "createFn", "value"])(Lazy$6);
	__RΦ$g$6.m("rt:Sm", [])(Lazy$6);
	__RΦ$g$6.m("rt:m", [])(Lazy$6);
	__RΦ$g$6.m("rt:p", [{ n: "createFn", t: () => __RΦ$g$6.a(1610), v: null, f: "#" }])(Lazy$6);
	__RΦ$g$6.m("rt:f", "Ce")(Lazy$6);
	__RΦ$g$6.m("rt:t", () => __RΦ$g$6.a(1618))(Lazy$6.prototype, "#value");
	__RΦ$g$6.m("rt:f", "P")(Lazy$6.prototype, "#value");
	__RΦ$g$6.m("rt:t", () => __RΦ$g$6.a(1615))(Lazy$6.prototype, "#creator");
	__RΦ$g$6.m("rt:f", "P")(Lazy$6.prototype, "#creator");
	__RΦ$g$6.m("rt:t", () => __RΦ$g$6.a(1612))(Lazy$6.prototype, "value");
	__RΦ$g$6.m("rt:f", "P")(Lazy$6.prototype, "value");

	const __RΦ$f$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$f$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$f$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$f$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	var IΦdefault$5$6 = { name: "IPoint", prototype: {}, identity: Symbol("IPoint (interface)") };
	(t => __RΦ$f$6.t[141] = t)(IΦdefault$5$6);
	__RΦ$f$6.m("rt:P", ["x", "y"])(IΦdefault$5$6);
	__RΦ$f$6.m("rt:m", [])(IΦdefault$5$6);
	__RΦ$f$6.m("rt:f", "Ie")(IΦdefault$5$6);
	__RΦ$f$6.m("rt:t", () => __RΦ$f$6.a(15))(IΦdefault$5$6.prototype, "x");
	__RΦ$f$6.m("rt:f", "P")(IΦdefault$5$6.prototype, "x");
	__RΦ$f$6.m("rt:t", () => __RΦ$f$6.a(15))(IΦdefault$5$6.prototype, "y");
	__RΦ$f$6.m("rt:f", "P")(IΦdefault$5$6.prototype, "y");
	__RΦ$f$6.m("rt:t", () => __RΦ$f$6.a(15))(IΦdefault$5$6.prototype, "x");
	__RΦ$f$6.m("rt:f", "P")(IΦdefault$5$6.prototype, "x");
	__RΦ$f$6.m("rt:t", () => __RΦ$f$6.a(15))(IΦdefault$5$6.prototype, "y");
	__RΦ$f$6.m("rt:f", "P")(IΦdefault$5$6.prototype, "y");

	const __RΦ$e$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$e$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$e$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$e$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [141]: { LΦ: t => IΦdefault$5$6 }, [1627]: { TΦ: "5", name: "default" }, [21]: { LΦ: t => Boolean }, [1636]: { RΦ: t => ({ TΦ: "[", e: __RΦ$e$6.a(15) }) }, [14]: { LΦ: t => String } } };
	/*
	 * Увеличить длину вектора можно так:
	 * Vector.translate(Vector.identity.scale(length))
	 *
	 */
	/**
	 * Вектор.
	 * @unmutable
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/vector/Vector.js
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/Point.js
	 */
	class Vector$6 {
	    x;
	    y;
	    /**
	     * Расстояние от начала координат до точки.
	     */
	    static distance(point) {
	        // noinspection JSSuspiciousNameCombination
	        return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
	    }
	    /**
	     * Создать вектор на основе угла и длины.
	     */
	    static create(angle, length) {
	        return new Vector$6(length * Math.cos(angle), length * Math.sin(angle));
	    }
	    /**
	     * Угол между вектором и положительной осью.
	     * Принимает значение от -Math.PI до Math.PI радиан.
	     */
	    get angle() {
	        return Math.atan2(this.y, this.x);
	    }
	    /**
	     * Модуль (длина) вектора.
	     */
	    get length() {
	        return Vector$6.distance(this);
	    }
	    /**
	     * Возвращает true, если вектор является нулевым.
	     */
	    get isNull() {
	        return this.x === 0 && this.y === 0;
	    }
	    /**
	     * Конструктор вектора.
	     * @param x
	     * @param y
	     */
	    constructor(x = 0, y = 0) {
	        this.x = x;
	        this.y = y;
	    }
	    /**
	     * Получить единичный вектор, равный по направлению исходному.
	     * Он же направляющий вектор (единичный, равный по направлению).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get identity() {
	        return (new Vector$6(Math.cos(this.angle), Math.sin(this.angle)));
	    }
	    /**
	     * Получить обратный вектор (инверсия вектора).
	     */
	    get inverse() {
	        return new Vector$6(-this.x, -this.y);
	    }
	    /**
	     * Нормаль вектора (единичный вектор, перпендикулярный исходному).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get normal() {
	        return this.clone().rotate(Math.PI / 2).identity;
	        // TODO Проверить эту формулу нахождения перпендикулярного вектора.
	        /*
	            a: 1 / parallel.x(),
	            b: -1 / parallel.y(),
	        */
	    }
	    /**
	     * Сложение векторов.
	     * @param vector
	     */
	    translate(vector) {
	        return new Vector$6(this.x + vector.x, this.y + vector.y);
	    }
	    /**
	     * Вращение вектора.
	     * @param angle
	     */
	    rotate(angle) {
	        return new Vector$6(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle));
	    }
	    /**
	     * Умножение вектора на число.
	     */
	    scale(scale) {
	        return new Vector$6(this.x * scale, this.y * scale);
	    }
	    /**
	     * Скалярное произведение векторов.
	     * @param vector
	     */
	    multiply(vector) {
	        return new Vector$6(this.x * vector.x, this.y * vector.y);
	    }
	    /**
	     * Взятие остатка от деления.
	     * @param vector
	     */
	    mod(vector) {
	        return new Vector$6(this.x % vector.x, this.y % vector.y);
	    }
	    clone() {
	        return new Vector$6(this.x, this.y);
	    }
	    toArray() {
	        return [this.x, this.y];
	    }
	    toString(digits = 2) {
	        return `[${this.x.toFixed(digits)}, ${this.y.toFixed(digits)}]`;
	    }
	}
	(t => __RΦ$e$6.t[1627] = t)(Vector$6);
	__RΦ$e$6.m("rt:SP", [])(Vector$6);
	__RΦ$e$6.m("rt:P", ["angle", "length", "isNull", "x", "y", "identity", "inverse", "normal"])(Vector$6);
	__RΦ$e$6.m("rt:Sm", ["distance", "create"])(Vector$6);
	__RΦ$e$6.m("rt:m", ["translate", "rotate", "scale", "multiply", "mod", "clone", "toArray", "toString"])(Vector$6);
	__RΦ$e$6.m("rt:p", [{ n: "x", t: () => __RΦ$e$6.a(15), v: function () { return 0; }, f: "$R" }, { n: "y", t: () => __RΦ$e$6.a(15), v: function () { return 0; }, f: "$R" }])(Vector$6);
	__RΦ$e$6.m("rt:i", [() => undefined])(Vector$6);
	__RΦ$e$6.m("rt:f", "Ce")(Vector$6);
	__RΦ$e$6.m("rt:f", "M$S")(Vector$6["distance"]);
	((t, p) => __RΦ$e$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$6, "distance");
	__RΦ$e$6.m("rt:p", [{ n: "point", t: () => __RΦ$e$6.a(141), v: null }])(Vector$6, "distance");
	__RΦ$e$6.m("rt:f", "M$S")(Vector$6, "distance");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(15))(Vector$6, "distance");
	__RΦ$e$6.m("rt:f", "M$S")(Vector$6["create"]);
	((t, p) => __RΦ$e$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$6, "create");
	__RΦ$e$6.m("rt:p", [{ n: "angle", t: () => __RΦ$e$6.a(15), v: null }, { n: "length", t: () => __RΦ$e$6.a(15), v: null }])(Vector$6, "create");
	__RΦ$e$6.m("rt:f", "M$S")(Vector$6, "create");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(1627))(Vector$6, "create");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(15))(Vector$6.prototype, "angle");
	__RΦ$e$6.m("rt:f", "P$")(Vector$6.prototype, "angle");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(15))(Vector$6.prototype, "length");
	__RΦ$e$6.m("rt:f", "P$")(Vector$6.prototype, "length");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(21))(Vector$6.prototype, "isNull");
	__RΦ$e$6.m("rt:f", "P$")(Vector$6.prototype, "isNull");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(1627))(Vector$6.prototype, "identity");
	__RΦ$e$6.m("rt:f", "P$")(Vector$6.prototype, "identity");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(1627))(Vector$6.prototype, "inverse");
	__RΦ$e$6.m("rt:f", "P$")(Vector$6.prototype, "inverse");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(1627))(Vector$6.prototype, "normal");
	__RΦ$e$6.m("rt:f", "P$")(Vector$6.prototype, "normal");
	__RΦ$e$6.m("rt:f", "M$")(Vector$6.prototype["translate"]);
	((t, p) => __RΦ$e$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$6.prototype, "translate");
	__RΦ$e$6.m("rt:p", [{ n: "vector", t: () => __RΦ$e$6.a(1627), v: null }])(Vector$6.prototype, "translate");
	__RΦ$e$6.m("rt:f", "M$")(Vector$6.prototype, "translate");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(1627))(Vector$6.prototype, "translate");
	__RΦ$e$6.m("rt:f", "M$.")(Vector$6.prototype["rotate"]);
	((t, p) => __RΦ$e$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$6.prototype, "rotate");
	__RΦ$e$6.m("rt:p", [{ n: "angle", t: () => __RΦ$e$6.a(15), v: null }])(Vector$6.prototype, "rotate");
	__RΦ$e$6.m("rt:f", "M$.")(Vector$6.prototype, "rotate");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(1627))(Vector$6.prototype, "rotate");
	__RΦ$e$6.m("rt:f", "M$.")(Vector$6.prototype["scale"]);
	((t, p) => __RΦ$e$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$6.prototype, "scale");
	__RΦ$e$6.m("rt:p", [{ n: "scale", t: () => __RΦ$e$6.a(15), v: null }])(Vector$6.prototype, "scale");
	__RΦ$e$6.m("rt:f", "M$.")(Vector$6.prototype, "scale");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(1627))(Vector$6.prototype, "scale");
	__RΦ$e$6.m("rt:f", "M$")(Vector$6.prototype["multiply"]);
	((t, p) => __RΦ$e$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$6.prototype, "multiply");
	__RΦ$e$6.m("rt:p", [{ n: "vector", t: () => __RΦ$e$6.a(1627), v: null }])(Vector$6.prototype, "multiply");
	__RΦ$e$6.m("rt:f", "M$")(Vector$6.prototype, "multiply");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(1627))(Vector$6.prototype, "multiply");
	__RΦ$e$6.m("rt:f", "M$")(Vector$6.prototype["mod"]);
	((t, p) => __RΦ$e$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$6.prototype, "mod");
	__RΦ$e$6.m("rt:p", [{ n: "vector", t: () => __RΦ$e$6.a(1627), v: null }])(Vector$6.prototype, "mod");
	__RΦ$e$6.m("rt:f", "M$")(Vector$6.prototype, "mod");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(1627))(Vector$6.prototype, "mod");
	__RΦ$e$6.m("rt:f", "M$.")(Vector$6.prototype["clone"]);
	((t, p) => __RΦ$e$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$6.prototype, "clone");
	__RΦ$e$6.m("rt:p", [])(Vector$6.prototype, "clone");
	__RΦ$e$6.m("rt:f", "M$.")(Vector$6.prototype, "clone");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(1627))(Vector$6.prototype, "clone");
	__RΦ$e$6.m("rt:f", "M$.")(Vector$6.prototype["toArray"]);
	((t, p) => __RΦ$e$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$6.prototype, "toArray");
	__RΦ$e$6.m("rt:p", [])(Vector$6.prototype, "toArray");
	__RΦ$e$6.m("rt:f", "M$.")(Vector$6.prototype, "toArray");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(1636))(Vector$6.prototype, "toArray");
	__RΦ$e$6.m("rt:f", "M$.")(Vector$6.prototype["toString"]);
	((t, p) => __RΦ$e$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$6.prototype, "toString");
	__RΦ$e$6.m("rt:p", [{ n: "digits", t: () => __RΦ$e$6.a(15), v: function () { return 2; } }])(Vector$6.prototype, "toString");
	__RΦ$e$6.m("rt:f", "M$.")(Vector$6.prototype, "toString");
	__RΦ$e$6.m("rt:t", () => __RΦ$e$6.a(14))(Vector$6.prototype, "toString");

	const __RΦ$d$7 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$d$7.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$d$7.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$d$7.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	class Angle$6 {
	    /**
	     * Конвертация угла из радиан в градусы.
	     * @param value
	     */
	    static toDegree(value) {
	        return value / Math.PI * 180;
	    }
	    /**
	     * Конвертация угла из градусов в радианы.
	     * @param value
	     */
	    static toRadian(value) {
	        return value * Math.PI / 180;
	    }
	}
	(t => __RΦ$d$7.t[1638] = t)(Angle$6);
	__RΦ$d$7.m("rt:SP", [])(Angle$6);
	__RΦ$d$7.m("rt:P", [])(Angle$6);
	__RΦ$d$7.m("rt:Sm", ["toDegree", "toRadian"])(Angle$6);
	__RΦ$d$7.m("rt:m", [])(Angle$6);
	__RΦ$d$7.m("rt:f", "Ce")(Angle$6);
	__RΦ$d$7.m("rt:f", "M$S.")(Angle$6["toDegree"]);
	((t, p) => __RΦ$d$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle$6, "toDegree");
	__RΦ$d$7.m("rt:p", [{ n: "value", t: () => __RΦ$d$7.a(15), v: null }])(Angle$6, "toDegree");
	__RΦ$d$7.m("rt:f", "M$S.")(Angle$6, "toDegree");
	__RΦ$d$7.m("rt:t", () => __RΦ$d$7.a(15))(Angle$6, "toDegree");
	__RΦ$d$7.m("rt:f", "M$S.")(Angle$6["toRadian"]);
	((t, p) => __RΦ$d$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle$6, "toRadian");
	__RΦ$d$7.m("rt:p", [{ n: "value", t: () => __RΦ$d$7.a(15), v: null }])(Angle$6, "toRadian");
	__RΦ$d$7.m("rt:f", "M$S.")(Angle$6, "toRadian");
	__RΦ$d$7.m("rt:t", () => __RΦ$d$7.a(15))(Angle$6, "toRadian");

	const __RΦ$c$7 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$c$7.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$c$7.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$c$7.t[id] = t = l;
	        }
	        return t;
	    }, t: { [151]: { LΦ: t => Object }, [152]: { LΦ: t => Object } } };
	var IΦdefault$4$6 = { name: "IKeyValueObject", prototype: {}, identity: Symbol("IKeyValueObject (interface)") };
	(t => __RΦ$c$7.t[153] = t)(IΦdefault$4$6);
	__RΦ$c$7.m("rt:P", ["key", "value"])(IΦdefault$4$6);
	__RΦ$c$7.m("rt:m", [])(IΦdefault$4$6);
	__RΦ$c$7.m("rt:f", "Ie")(IΦdefault$4$6);
	__RΦ$c$7.m("rt:t", () => __RΦ$c$7.a(151))(IΦdefault$4$6.prototype, "key");
	__RΦ$c$7.m("rt:f", "P")(IΦdefault$4$6.prototype, "key");
	__RΦ$c$7.m("rt:t", () => __RΦ$c$7.a(152))(IΦdefault$4$6.prototype, "value");
	__RΦ$c$7.m("rt:f", "P")(IΦdefault$4$6.prototype, "value");
	__RΦ$c$7.m("rt:t", () => __RΦ$c$7.a(151))(IΦdefault$4$6.prototype, "key");
	__RΦ$c$7.m("rt:f", "P")(IΦdefault$4$6.prototype, "key");
	__RΦ$c$7.m("rt:t", () => __RΦ$c$7.a(152))(IΦdefault$4$6.prototype, "value");
	__RΦ$c$7.m("rt:f", "P")(IΦdefault$4$6.prototype, "value");

	const __RΦ$b$7 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$b$7.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$b$7.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$b$7.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1828]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$7.a(156), p: [__RΦ$b$7.a(1826), __RΦ$b$7.a(1827)] }) }, [156]: { LΦ: t => Map }, [1826]: { LΦ: t => Object }, [1827]: { LΦ: t => Object }, [1832]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$7.a(1836) }) }, [1836]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$7.a(153), p: [__RΦ$b$7.a(1826), __RΦ$b$7.a(1835)] }) }, [153]: { LΦ: t => IΦdefault$4$6 }, [1835]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b$7.a(10), __RΦ$b$7.a(1827)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1839]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b$7.a(1840), p: [__RΦ$b$7.a(1837), __RΦ$b$7.a(1838)] }) }, [1840]: { LΦ: t => Object }, [1837]: { LΦ: t => Object }, [1838]: { LΦ: t => Object }, [1844]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$7.a(1846) }) }, [1846]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$7.a(153), p: [__RΦ$b$7.a(1837), __RΦ$b$7.a(1838)] }) }, [1663]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b$7.a(1656), __RΦ$b$7.a(1661)] }) }, [1656]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$7.a(156), p: [__RΦ$b$7.a(1645), __RΦ$b$7.a(1646)] }) }, [1645]: { LΦ: t => Object }, [1646]: { LΦ: t => Object }, [1661]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b$7.a(1662), p: [__RΦ$b$7.a(1645), __RΦ$b$7.a(1646)] }) }, [1662]: { LΦ: t => Object }, [1647]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$7.a(1650) }) }, [1650]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$7.a(153), p: [__RΦ$b$7.a(1645), __RΦ$b$7.a(1646)] }) }, [15]: { LΦ: t => Number } } };
	/**
	 * Конвертация разнообразных значений.
	 */
	class Convert$6 {
	    static toArray(object) {
	        const result = [];
	        if (object instanceof Map) {
	            for (const [key, value] of object) {
	                result.push({ key, value });
	            }
	        }
	        else {
	            for (const key in object) {
	                if (!object.hasOwnProperty(key))
	                    continue;
	                result.push({ key, value: Reflect.get(object, key) });
	            }
	        }
	        return result;
	    }
	    /**
	     * Конвертировать миллисекунды в секунды.
	     * @param millisecond
	     */
	    static toSecond(millisecond) {
	        return millisecond / 1000;
	    }
	}
	(t => __RΦ$b$7.t[1824] = t)(Convert$6);
	__RΦ$b$7.m("rt:SP", [])(Convert$6);
	__RΦ$b$7.m("rt:P", [])(Convert$6);
	__RΦ$b$7.m("rt:Sm", ["toArray", "toArray", "toArray", "toSecond"])(Convert$6);
	__RΦ$b$7.m("rt:m", [])(Convert$6);
	__RΦ$b$7.m("rt:f", "Ce")(Convert$6);
	__RΦ$b$7.m("rt:f", "M$S")(Convert$6["toArray"]);
	((t, p) => __RΦ$b$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$6, "toArray");
	__RΦ$b$7.m("rt:p", [{ n: "object", t: () => __RΦ$b$7.a(1828), v: null }])(Convert$6, "toArray");
	__RΦ$b$7.m("rt:f", "M$S")(Convert$6, "toArray");
	__RΦ$b$7.m("rt:t", () => __RΦ$b$7.a(1832))(Convert$6, "toArray");
	__RΦ$b$7.m("rt:f", "M$S")(Convert$6["toArray"]);
	((t, p) => __RΦ$b$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$6, "toArray");
	__RΦ$b$7.m("rt:p", [{ n: "object", t: () => __RΦ$b$7.a(1839), v: null }])(Convert$6, "toArray");
	__RΦ$b$7.m("rt:f", "M$S")(Convert$6, "toArray");
	__RΦ$b$7.m("rt:t", () => __RΦ$b$7.a(1844))(Convert$6, "toArray");
	__RΦ$b$7.m("rt:f", "M$S")(Convert$6["toArray"]);
	((t, p) => __RΦ$b$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$6, "toArray");
	__RΦ$b$7.m("rt:p", [{ n: "object", t: () => __RΦ$b$7.a(1663), v: null }])(Convert$6, "toArray");
	__RΦ$b$7.m("rt:f", "M$S")(Convert$6, "toArray");
	__RΦ$b$7.m("rt:t", () => __RΦ$b$7.a(1647))(Convert$6, "toArray");
	__RΦ$b$7.m("rt:f", "M$S.")(Convert$6["toSecond"]);
	((t, p) => __RΦ$b$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$6, "toSecond");
	__RΦ$b$7.m("rt:p", [{ n: "millisecond", t: () => __RΦ$b$7.a(15), v: null }])(Convert$6, "toSecond");
	__RΦ$b$7.m("rt:f", "M$S.")(Convert$6, "toSecond");
	__RΦ$b$7.m("rt:t", () => __RΦ$b$7.a(15))(Convert$6, "toSecond");

	const __RΦ$a$7 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$a$7.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$a$7.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$a$7.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1873]: { LΦ: t => 60 }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [15]: { LΦ: t => Number }, [1869]: { LΦ: t => "update" }, [1875]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$7.a(4) }] }) }, [1850]: { RΦ: t => ({ TΦ: "t" }) }, [1871]: { LΦ: t => "render" }, [1876]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$7.a(4) }] }) }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$a$7.a(14), __RΦ$a$7.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1852]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$7.a(4) }] }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * http://gs-studio.com/news-about-it/30703----javascript
	 * https://eatdog.com.ua/assets/gamedev-slides/
	 * https://www.youtube.com/watch?v=-gsjAz9jR3Y
	 */
	class GameLoop$6 {
	    framePerSecond;
	    eventEmitter = new EventEmitter__default$5["default"];
	    time = 0;
	    timeInterval = 0;
	    renderTime = 0;
	    renderTimeInterval = 0;
	    /**
	     * Текущий FPS отрисовки игровой сцены.
	     */
	    get renderFramePerSecond() {
	        return 1 / (this.renderTimeInterval / 1000);
	    }
	    /**
	     * Временной шаг, с которым вызывается функция update для вычисления игровой логики.
	     * Измеряется в миллисекундах.
	     */
	    get step() {
	        return (1 / this.framePerSecond) / 1000;
	    }
	    constructor(
	    /**
	     * Частота обновления игровой логики (генерации события update).
	     * @private
	     */
	    framePerSecond = 60 // TODO Переименовать в updatePerSecond?
	    ) {
	        this.framePerSecond = framePerSecond;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	    start() {
	        this.time = performance.now();
	        this.timeInterval = 0;
	        requestAnimationFrame(this.frame.bind(this));
	    }
	    stop() {
	    }
	    pause() {
	    }
	    frame() {
	        // Обработка логики игры.
	        {
	            const currentTime = performance.now();
	            // Исправление проблемы неактивных вкладок.
	            // Разрешить максимальную задержку между вызовами не более, чем 1 секунда.
	            this.timeInterval = this.timeInterval + Math.min(1000, currentTime - this.time);
	            while (this.timeInterval > this.step) {
	                this.timeInterval = this.timeInterval - this.step;
	                this.eventEmitter.emit('update', this.step);
	            }
	            this.time = currentTime;
	        }
	        // Обработка отрисовки сцены игры.
	        {
	            const renderCurrentTime = performance.now();
	            this.renderTimeInterval = renderCurrentTime - this.renderTime;
	            this.renderTime = renderCurrentTime;
	            this.eventEmitter.emit('render', this.timeInterval);
	        }
	        requestAnimationFrame(this.frame.bind(this));
	    }
	}
	(t => __RΦ$a$7.t[1849] = t)(GameLoop$6);
	__RΦ$a$7.m("rt:SP", [])(GameLoop$6);
	__RΦ$a$7.m("rt:P", ["eventEmitter", "time", "timeInterval", "renderTime", "renderTimeInterval", "renderFramePerSecond", "step", "framePerSecond"])(GameLoop$6);
	__RΦ$a$7.m("rt:Sm", [])(GameLoop$6);
	__RΦ$a$7.m("rt:m", ["on", "on", "on", "start", "stop", "pause", "frame"])(GameLoop$6);
	__RΦ$a$7.m("rt:p", [{ n: "framePerSecond", t: () => __RΦ$a$7.a(1873), v: function () { return 60 // TODO Переименовать в updatePerSecond?
	        ; }, f: "#R" }])(GameLoop$6);
	__RΦ$a$7.m("rt:i", [() => undefined, () => undefined])(GameLoop$6);
	__RΦ$a$7.m("rt:f", "Ce")(GameLoop$6);
	__RΦ$a$7.m("rt:t", () => __RΦ$a$7.a(4))(GameLoop$6.prototype, "eventEmitter");
	__RΦ$a$7.m("rt:f", "P#R")(GameLoop$6.prototype, "eventEmitter");
	__RΦ$a$7.m("rt:t", () => __RΦ$a$7.a(15))(GameLoop$6.prototype, "time");
	__RΦ$a$7.m("rt:f", "P#")(GameLoop$6.prototype, "time");
	__RΦ$a$7.m("rt:t", () => __RΦ$a$7.a(15))(GameLoop$6.prototype, "timeInterval");
	__RΦ$a$7.m("rt:f", "P#")(GameLoop$6.prototype, "timeInterval");
	__RΦ$a$7.m("rt:t", () => __RΦ$a$7.a(15))(GameLoop$6.prototype, "renderTime");
	__RΦ$a$7.m("rt:f", "P#")(GameLoop$6.prototype, "renderTime");
	__RΦ$a$7.m("rt:t", () => __RΦ$a$7.a(15))(GameLoop$6.prototype, "renderTimeInterval");
	__RΦ$a$7.m("rt:f", "P#")(GameLoop$6.prototype, "renderTimeInterval");
	__RΦ$a$7.m("rt:t", () => __RΦ$a$7.a(15))(GameLoop$6.prototype, "renderFramePerSecond");
	__RΦ$a$7.m("rt:f", "P$")(GameLoop$6.prototype, "renderFramePerSecond");
	__RΦ$a$7.m("rt:t", () => __RΦ$a$7.a(15))(GameLoop$6.prototype, "step");
	__RΦ$a$7.m("rt:f", "P$")(GameLoop$6.prototype, "step");
	__RΦ$a$7.m("rt:f", "M")(GameLoop$6.prototype["on"]);
	((t, p) => __RΦ$a$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$6.prototype, "on");
	__RΦ$a$7.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$7.a(1869), v: null }, { n: "update", t: () => __RΦ$a$7.a(1875), v: null }])(GameLoop$6.prototype, "on");
	__RΦ$a$7.m("rt:f", "M")(GameLoop$6.prototype, "on");
	__RΦ$a$7.m("rt:t", () => __RΦ$a$7.a(1850))(GameLoop$6.prototype, "on");
	__RΦ$a$7.m("rt:f", "M")(GameLoop$6.prototype["on"]);
	((t, p) => __RΦ$a$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$6.prototype, "on");
	__RΦ$a$7.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$7.a(1871), v: null }, { n: "render", t: () => __RΦ$a$7.a(1876), v: null }])(GameLoop$6.prototype, "on");
	__RΦ$a$7.m("rt:f", "M")(GameLoop$6.prototype, "on");
	__RΦ$a$7.m("rt:t", () => __RΦ$a$7.a(1850))(GameLoop$6.prototype, "on");
	__RΦ$a$7.m("rt:f", "M")(GameLoop$6.prototype["on"]);
	((t, p) => __RΦ$a$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$6.prototype, "on");
	__RΦ$a$7.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$7.a(143), v: null }, { n: "listener", t: () => __RΦ$a$7.a(1852), v: null }])(GameLoop$6.prototype, "on");
	__RΦ$a$7.m("rt:f", "M")(GameLoop$6.prototype, "on");
	__RΦ$a$7.m("rt:t", () => __RΦ$a$7.a(1850))(GameLoop$6.prototype, "on");
	__RΦ$a$7.m("rt:f", "M$")(GameLoop$6.prototype["start"]);
	((t, p) => __RΦ$a$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$6.prototype, "start");
	__RΦ$a$7.m("rt:p", [])(GameLoop$6.prototype, "start");
	__RΦ$a$7.m("rt:f", "M$")(GameLoop$6.prototype, "start");
	__RΦ$a$7.m("rt:t", () => __RΦ$a$7.a(23))(GameLoop$6.prototype, "start");
	__RΦ$a$7.m("rt:f", "M$")(GameLoop$6.prototype["stop"]);
	((t, p) => __RΦ$a$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$6.prototype, "stop");
	__RΦ$a$7.m("rt:p", [])(GameLoop$6.prototype, "stop");
	__RΦ$a$7.m("rt:f", "M$")(GameLoop$6.prototype, "stop");
	__RΦ$a$7.m("rt:t", () => __RΦ$a$7.a(23))(GameLoop$6.prototype, "stop");
	__RΦ$a$7.m("rt:f", "M$")(GameLoop$6.prototype["pause"]);
	((t, p) => __RΦ$a$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$6.prototype, "pause");
	__RΦ$a$7.m("rt:p", [])(GameLoop$6.prototype, "pause");
	__RΦ$a$7.m("rt:f", "M$")(GameLoop$6.prototype, "pause");
	__RΦ$a$7.m("rt:t", () => __RΦ$a$7.a(23))(GameLoop$6.prototype, "pause");
	__RΦ$a$7.m("rt:f", "M#.")(GameLoop$6.prototype["frame"]);
	((t, p) => __RΦ$a$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$6.prototype, "frame");
	__RΦ$a$7.m("rt:p", [])(GameLoop$6.prototype, "frame");
	__RΦ$a$7.m("rt:f", "M#.")(GameLoop$6.prototype, "frame");
	__RΦ$a$7.m("rt:t", () => __RΦ$a$7.a(23))(GameLoop$6.prototype, "frame");

	const __RΦ$9$7 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$9$7.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$9$7.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$9$7.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1880]: { RΦ: t => ({ TΦ: "g", t: __RΦ$9$7.a(156), p: [__RΦ$9$7.a(14), __RΦ$9$7.a(21)] }) }, [156]: { LΦ: t => Map }, [14]: { LΦ: t => String }, [21]: { LΦ: t => Boolean }, [1883]: { LΦ: t => KeyboardEvent }, [1890]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$7.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1893]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$7.a(4) }] }) }, [1897]: { LΦ: t => Function }, [1896]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$7.a(4) }] }) }, [1898]: { LΦ: t => Function } } };
	/**
	 * Вместо KeyUpDownProcessor используйте Shortcut.
	 * @deprecated
	 * @link http://khusamov.github.io/tutorial/csharp/key-down-up-process
	 */
	class KeyUpDownProcessor$6 {
	    /**
	     * Данный словарь хранит информацию о том, была ли нажата клавиша.
	     * В качестве ключа выступает номер клавиши,
	     * а значение это флаг (была или не была нажата клавиша).
	     * @private
	     * @link https://learn.javascript.ru/keyboard-events
	     */
	    static #theKeyWasDown = new Map;
	    static onKeyDown(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.#theKeyWasDown.has(keyCode)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.#theKeyWasDown.set(keyCode, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.#theKeyWasDown.get(keyCode)) {
	            // Помечаем что она нажата.
	            this.#theKeyWasDown.set(keyCode, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            action();
	        }
	    }
	    static onKeyUp(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Помечаем что она уже не нажата.
	        this.#theKeyWasDown.set(keyCode, false);
	        // Выполняем действие при отжатии клавиши.
	        action();
	    }
	}
	(t => __RΦ$9$7.t[1878] = t)(KeyUpDownProcessor$6);
	__RΦ$9$7.m("rt:SP", ["#theKeyWasDown"])(KeyUpDownProcessor$6);
	__RΦ$9$7.m("rt:P", [])(KeyUpDownProcessor$6);
	__RΦ$9$7.m("rt:Sm", ["onKeyDown", "onKeyUp"])(KeyUpDownProcessor$6);
	__RΦ$9$7.m("rt:m", [])(KeyUpDownProcessor$6);
	__RΦ$9$7.m("rt:f", "Ce")(KeyUpDownProcessor$6);
	__RΦ$9$7.m("rt:t", () => __RΦ$9$7.a(1880))(KeyUpDownProcessor$6, "#theKeyWasDown");
	__RΦ$9$7.m("rt:f", "P")(KeyUpDownProcessor$6, "#theKeyWasDown");
	__RΦ$9$7.m("rt:f", "M$S.")(KeyUpDownProcessor$6["onKeyDown"]);
	((t, p) => __RΦ$9$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor$6, "onKeyDown");
	__RΦ$9$7.m("rt:p", [{ n: "event", t: () => __RΦ$9$7.a(1883), v: null }, { n: "action", t: () => __RΦ$9$7.a(1890), v: null }])(KeyUpDownProcessor$6, "onKeyDown");
	__RΦ$9$7.m("rt:f", "M$S.")(KeyUpDownProcessor$6, "onKeyDown");
	__RΦ$9$7.m("rt:t", () => __RΦ$9$7.a(23))(KeyUpDownProcessor$6, "onKeyDown");
	__RΦ$9$7.m("rt:f", "M$S.")(KeyUpDownProcessor$6["onKeyUp"]);
	((t, p) => __RΦ$9$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor$6, "onKeyUp");
	__RΦ$9$7.m("rt:p", [{ n: "event", t: () => __RΦ$9$7.a(1883), v: null }, { n: "action", t: () => __RΦ$9$7.a(1890), v: null }])(KeyUpDownProcessor$6, "onKeyUp");
	__RΦ$9$7.m("rt:f", "M$S.")(KeyUpDownProcessor$6, "onKeyUp");
	__RΦ$9$7.m("rt:t", () => __RΦ$9$7.a(23))(KeyUpDownProcessor$6, "onKeyUp");
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyDown$6(listener) {
	    return __RΦ$9$7.f((event) => {
	        KeyUpDownProcessor$6.onKeyDown(event, __RΦ$9$7.f(() => {
	            listener(event);
	        }, [__RΦ$9$7.m("rt:p", []), __RΦ$9$7.m("rt:f", "F>"), __RΦ$9$7.m("rt:t", () => __RΦ$9$7.a(23))], ""));
	    }, [__RΦ$9$7.m("rt:p", [{ n: "event", t: () => __RΦ$9$7.a(1883), v: null }]), __RΦ$9$7.m("rt:f", "F>"), __RΦ$9$7.m("rt:t", () => __RΦ$9$7.a(23))], "");
	}
	__RΦ$9$7.m("rt:p", [{ n: "listener", t: () => __RΦ$9$7.a(1893), v: null }])(onKeyDown$6);
	__RΦ$9$7.m("rt:f", "F")(onKeyDown$6);
	__RΦ$9$7.m("rt:t", () => __RΦ$9$7.a(1897))(onKeyDown$6);
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyUp$6(listener) {
	    return __RΦ$9$7.f((event) => {
	        KeyUpDownProcessor$6.onKeyUp(event, __RΦ$9$7.f(() => {
	            listener(event);
	        }, [__RΦ$9$7.m("rt:p", []), __RΦ$9$7.m("rt:f", "F>"), __RΦ$9$7.m("rt:t", () => __RΦ$9$7.a(23))], ""));
	    }, [__RΦ$9$7.m("rt:p", [{ n: "event", t: () => __RΦ$9$7.a(1883), v: null }]), __RΦ$9$7.m("rt:f", "F>"), __RΦ$9$7.m("rt:t", () => __RΦ$9$7.a(23))], "");
	}
	__RΦ$9$7.m("rt:p", [{ n: "listener", t: () => __RΦ$9$7.a(1896), v: null }])(onKeyUp$6);
	__RΦ$9$7.m("rt:f", "F")(onKeyUp$6);
	__RΦ$9$7.m("rt:t", () => __RΦ$9$7.a(1898))(onKeyUp$6);

	const __RΦ$8$7 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$8$7.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$8$7.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$8$7.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$3$6 = { name: "IDisposable", prototype: {}, identity: Symbol("IDisposable (interface)") };
	(t => __RΦ$8$7.t[147] = t)(IΦdefault$3$6);
	__RΦ$8$7.m("rt:P", [])(IΦdefault$3$6);
	__RΦ$8$7.m("rt:m", ["dispose"])(IΦdefault$3$6);
	__RΦ$8$7.m("rt:f", "Ie")(IΦdefault$3$6);
	__RΦ$8$7.m("rt:p", [])(IΦdefault$3$6.prototype, "dispose");
	__RΦ$8$7.m("rt:f", "M")(IΦdefault$3$6.prototype, "dispose");
	__RΦ$8$7.m("rt:t", () => __RΦ$8$7.a(23))(IΦdefault$3$6.prototype, "dispose");
	__RΦ$8$7.m("rt:p", [])(IΦdefault$3$6.prototype, "dispose");
	__RΦ$8$7.m("rt:f", "M")(IΦdefault$3$6.prototype, "dispose");
	__RΦ$8$7.m("rt:t", () => __RΦ$8$7.a(23))(IΦdefault$3$6.prototype, "dispose");

	const __RΦ$7$7 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$7$7.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$7$7.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$7$7.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1899]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$7$7.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) } } };
	var IΦdefault$2$6 = { name: "IKeyboardListeners", prototype: {}, identity: Symbol("IKeyboardListeners (interface)") };
	(t => __RΦ$7$7.t[1900] = t)(IΦdefault$2$6);
	__RΦ$7$7.m("rt:P", ["down", "up"])(IΦdefault$2$6);
	__RΦ$7$7.m("rt:m", [])(IΦdefault$2$6);
	__RΦ$7$7.m("rt:f", "Ie")(IΦdefault$2$6);
	__RΦ$7$7.m("rt:t", () => __RΦ$7$7.a(1899))(IΦdefault$2$6.prototype, "down");
	__RΦ$7$7.m("rt:f", "P")(IΦdefault$2$6.prototype, "down");
	__RΦ$7$7.m("rt:t", () => __RΦ$7$7.a(1899))(IΦdefault$2$6.prototype, "up");
	__RΦ$7$7.m("rt:f", "P")(IΦdefault$2$6.prototype, "up");
	__RΦ$7$7.m("rt:t", () => __RΦ$7$7.a(1899))(IΦdefault$2$6.prototype, "down");
	__RΦ$7$7.m("rt:f", "P")(IΦdefault$2$6.prototype, "down");
	__RΦ$7$7.m("rt:t", () => __RΦ$7$7.a(1899))(IΦdefault$2$6.prototype, "up");
	__RΦ$7$7.m("rt:f", "P")(IΦdefault$2$6.prototype, "up");

	const __RΦ$6$7 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$6$7.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$6$7.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$6$7.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [709]: { LΦ: t => Object }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1901]: { TΦ: "5", name: "default" }, [2154]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$7.a(156), p: [__RΦ$6$7.a(14), __RΦ$6$7.a(1900)] }) }, [156]: { LΦ: t => Map }, [1900]: { LΦ: t => IΦdefault$2$6 }, [1899]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$6$7.a(4) }] }) }, [1880]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$7.a(156), p: [__RΦ$6$7.a(14), __RΦ$6$7.a(21)] }) }, [21]: { LΦ: t => Boolean }, [147]: { LΦ: t => IΦdefault$3$6 }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1883]: { LΦ: t => KeyboardEvent } } };
	const codeOf$6 = __RΦ$6$7.f((key) => 'Key' + key.toUpperCase(), [__RΦ$6$7.m("rt:p", [{ n: "key", t: () => __RΦ$6$7.a(14), v: null }]), __RΦ$6$7.m("rt:f", "F>"), __RΦ$6$7.m("rt:t", () => __RΦ$6$7.a(14))], "codeOf");
	class ShortcutDispatcher$6 {
	    static instanceHolder = new Lazy$6(() => new ShortcutDispatcher$6);
	    static get instance() {
	        return this.instanceHolder.value;
	    }
	    host;
	    listeners = new Map;
	    keyDownListenerBinded;
	    keyUpListenerBinded;
	    theKeyWasDown = new Map;
	    constructor(host = document) {
	        this.host = host;
	        this.keyDownListenerBinded = this.keyDownListener.bind(this);
	        this.keyUpListenerBinded = this.keyUpListener.bind(this);
	        this.host.addEventListener('keydown', this.keyDownListenerBinded);
	        this.host.addEventListener('keyup', this.keyUpListenerBinded);
	    }
	    register(key, listeners) {
	        this.listeners.set(key, listeners);
	        return {
	            dispose: __RΦ$6$7.f(() => {
	                this.listeners.delete(key);
	                this.theKeyWasDown.delete(codeOf$6(key));
	            }, [__RΦ$6$7.m("rt:p", []), __RΦ$6$7.m("rt:f", "F>"), __RΦ$6$7.m("rt:t", () => __RΦ$6$7.a(23))], "dispose")
	        };
	    }
	    keyDownListener(event) {
	        const code = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.theKeyWasDown.has(code)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.theKeyWasDown.set(code, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.theKeyWasDown.get(code)) {
	            // Помечаем что она нажата.
	            this.theKeyWasDown.set(code, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            for (const [key, listeners] of this.listeners.entries()) {
	                if (code === codeOf$6(key)) {
	                    listeners.down(event);
	                }
	            }
	        }
	    }
	    keyUpListener(event) {
	        // Из события извлекаем номер нажатой клавиши.
	        const code = event.code;
	        // Помечаем что она уже не нажата.
	        this.theKeyWasDown.set(code, false);
	        // Выполняем действие при отжатии клавиши.
	        for (const [key, listeners] of this.listeners.entries()) {
	            if (code === codeOf$6(key)) {
	                listeners.up(event);
	            }
	        }
	    }
	    dispose() {
	        this.host.removeEventListener('keydown', this.keyDownListenerBinded);
	        this.host.removeEventListener('keyup', this.keyUpListenerBinded);
	    }
	}
	(t => __RΦ$6$7.t[1901] = t)(ShortcutDispatcher$6);
	__RΦ$6$7.m("rt:SP", ["instanceHolder", "instance"])(ShortcutDispatcher$6);
	__RΦ$6$7.m("rt:P", ["host", "listeners", "keyDownListenerBinded", "keyUpListenerBinded", "theKeyWasDown"])(ShortcutDispatcher$6);
	__RΦ$6$7.m("rt:Sm", [])(ShortcutDispatcher$6);
	__RΦ$6$7.m("rt:m", ["register", "keyDownListener", "keyUpListener", "dispose"])(ShortcutDispatcher$6);
	__RΦ$6$7.m("rt:p", [{ n: "host", t: () => __RΦ$6$7.a(709), v: function () { return document; } }])(ShortcutDispatcher$6);
	__RΦ$6$7.m("rt:i", [() => undefined])(ShortcutDispatcher$6);
	__RΦ$6$7.m("rt:f", "Ce")(ShortcutDispatcher$6);
	__RΦ$6$7.m("rt:t", () => __RΦ$6$7.a(4))(ShortcutDispatcher$6, "instanceHolder");
	__RΦ$6$7.m("rt:f", "P#R")(ShortcutDispatcher$6, "instanceHolder");
	__RΦ$6$7.m("rt:t", () => __RΦ$6$7.a(1901))(ShortcutDispatcher$6, "instance");
	__RΦ$6$7.m("rt:f", "P$")(ShortcutDispatcher$6, "instance");
	__RΦ$6$7.m("rt:t", () => __RΦ$6$7.a(709))(ShortcutDispatcher$6.prototype, "host");
	__RΦ$6$7.m("rt:f", "P#R")(ShortcutDispatcher$6.prototype, "host");
	__RΦ$6$7.m("rt:t", () => __RΦ$6$7.a(2154))(ShortcutDispatcher$6.prototype, "listeners");
	__RΦ$6$7.m("rt:f", "P#R")(ShortcutDispatcher$6.prototype, "listeners");
	__RΦ$6$7.m("rt:t", () => __RΦ$6$7.a(1899))(ShortcutDispatcher$6.prototype, "keyDownListenerBinded");
	__RΦ$6$7.m("rt:f", "P#R")(ShortcutDispatcher$6.prototype, "keyDownListenerBinded");
	__RΦ$6$7.m("rt:t", () => __RΦ$6$7.a(1899))(ShortcutDispatcher$6.prototype, "keyUpListenerBinded");
	__RΦ$6$7.m("rt:f", "P#R")(ShortcutDispatcher$6.prototype, "keyUpListenerBinded");
	__RΦ$6$7.m("rt:t", () => __RΦ$6$7.a(1880))(ShortcutDispatcher$6.prototype, "theKeyWasDown");
	__RΦ$6$7.m("rt:f", "P#R")(ShortcutDispatcher$6.prototype, "theKeyWasDown");
	__RΦ$6$7.m("rt:f", "M$")(ShortcutDispatcher$6.prototype["register"]);
	((t, p) => __RΦ$6$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$6.prototype, "register");
	__RΦ$6$7.m("rt:p", [{ n: "key", t: () => __RΦ$6$7.a(14), v: null }, { n: "listeners", t: () => __RΦ$6$7.a(1900), v: null }])(ShortcutDispatcher$6.prototype, "register");
	__RΦ$6$7.m("rt:f", "M$")(ShortcutDispatcher$6.prototype, "register");
	__RΦ$6$7.m("rt:t", () => __RΦ$6$7.a(147))(ShortcutDispatcher$6.prototype, "register");
	__RΦ$6$7.m("rt:f", "M#.")(ShortcutDispatcher$6.prototype["keyDownListener"]);
	((t, p) => __RΦ$6$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$6.prototype, "keyDownListener");
	__RΦ$6$7.m("rt:p", [{ n: "event", t: () => __RΦ$6$7.a(1883), v: null }])(ShortcutDispatcher$6.prototype, "keyDownListener");
	__RΦ$6$7.m("rt:f", "M#.")(ShortcutDispatcher$6.prototype, "keyDownListener");
	__RΦ$6$7.m("rt:t", () => __RΦ$6$7.a(23))(ShortcutDispatcher$6.prototype, "keyDownListener");
	__RΦ$6$7.m("rt:f", "M#.")(ShortcutDispatcher$6.prototype["keyUpListener"]);
	((t, p) => __RΦ$6$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$6.prototype, "keyUpListener");
	__RΦ$6$7.m("rt:p", [{ n: "event", t: () => __RΦ$6$7.a(1883), v: null }])(ShortcutDispatcher$6.prototype, "keyUpListener");
	__RΦ$6$7.m("rt:f", "M#.")(ShortcutDispatcher$6.prototype, "keyUpListener");
	__RΦ$6$7.m("rt:t", () => __RΦ$6$7.a(23))(ShortcutDispatcher$6.prototype, "keyUpListener");
	__RΦ$6$7.m("rt:f", "M$.")(ShortcutDispatcher$6.prototype["dispose"]);
	((t, p) => __RΦ$6$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$6.prototype, "dispose");
	__RΦ$6$7.m("rt:p", [])(ShortcutDispatcher$6.prototype, "dispose");
	__RΦ$6$7.m("rt:f", "M$.")(ShortcutDispatcher$6.prototype, "dispose");
	__RΦ$6$7.m("rt:t", () => __RΦ$6$7.a(23))(ShortcutDispatcher$6.prototype, "dispose");

	const __RΦ$5$7 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$5$7.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$5$7.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$5$7.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [1900]: { LΦ: t => IΦdefault$2$6 }, [147]: { LΦ: t => IΦdefault$3$6 } } };
	class Shortcut$6 {
	    static register(key, listeners) {
	        return ShortcutDispatcher$6.instance.register(key, listeners);
	    }
	}
	(t => __RΦ$5$7.t[2183] = t)(Shortcut$6);
	__RΦ$5$7.m("rt:SP", [])(Shortcut$6);
	__RΦ$5$7.m("rt:P", [])(Shortcut$6);
	__RΦ$5$7.m("rt:Sm", ["register"])(Shortcut$6);
	__RΦ$5$7.m("rt:m", [])(Shortcut$6);
	__RΦ$5$7.m("rt:f", "Ce")(Shortcut$6);
	__RΦ$5$7.m("rt:f", "M$S")(Shortcut$6["register"]);
	((t, p) => __RΦ$5$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Shortcut$6, "register");
	__RΦ$5$7.m("rt:p", [{ n: "key", t: () => __RΦ$5$7.a(14), v: null }, { n: "listeners", t: () => __RΦ$5$7.a(1900), v: null }])(Shortcut$6, "register");
	__RΦ$5$7.m("rt:f", "M$S")(Shortcut$6, "register");
	__RΦ$5$7.m("rt:t", () => __RΦ$5$7.a(147))(Shortcut$6, "register");

	const __RΦ$4$7 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$4$7.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$4$7.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$4$7.t[id] = t = l;
	        }
	        return t;
	    }, t: { [166]: { RΦ: t => ({ TΦ: "[", e: __RΦ$4$7.a(165) }) }, [165]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [168]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$4$7.a(10), __RΦ$4$7.a(167)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [167]: { LΦ: t => Object }, [177]: { RΦ: t => ({ TΦ: "g", t: __RΦ$4$7.a(77), p: [__RΦ$4$7.a(167)] }) }, [77]: { LΦ: t => Object } } };
	var IΦdefault$1$6 = { name: "IQueue", prototype: {}, identity: Symbol("IQueue (interface)") };
	(t => __RΦ$4$7.t[178] = t)(IΦdefault$1$6);
	__RΦ$4$7.m("rt:P", ["items"])(IΦdefault$1$6);
	__RΦ$4$7.m("rt:m", ["enqueue", "dequeue"])(IΦdefault$1$6);
	__RΦ$4$7.m("rt:f", "Ie")(IΦdefault$1$6);
	__RΦ$4$7.m("rt:p", [{ n: "items", t: () => __RΦ$4$7.a(166), v: null }])(IΦdefault$1$6.prototype, "enqueue");
	__RΦ$4$7.m("rt:f", "M")(IΦdefault$1$6.prototype, "enqueue");
	__RΦ$4$7.m("rt:t", () => __RΦ$4$7.a(23))(IΦdefault$1$6.prototype, "enqueue");
	__RΦ$4$7.m("rt:p", [])(IΦdefault$1$6.prototype, "dequeue");
	__RΦ$4$7.m("rt:f", "M")(IΦdefault$1$6.prototype, "dequeue");
	__RΦ$4$7.m("rt:t", () => __RΦ$4$7.a(168))(IΦdefault$1$6.prototype, "dequeue");
	__RΦ$4$7.m("rt:t", () => __RΦ$4$7.a(177))(IΦdefault$1$6.prototype, "items");
	__RΦ$4$7.m("rt:f", "PR")(IΦdefault$1$6.prototype, "items");
	__RΦ$4$7.m("rt:p", [{ n: "items", t: () => __RΦ$4$7.a(166), v: null }])(IΦdefault$1$6.prototype, "enqueue");
	__RΦ$4$7.m("rt:f", "M")(IΦdefault$1$6.prototype, "enqueue");
	__RΦ$4$7.m("rt:t", () => __RΦ$4$7.a(23))(IΦdefault$1$6.prototype, "enqueue");
	__RΦ$4$7.m("rt:p", [])(IΦdefault$1$6.prototype, "dequeue");
	__RΦ$4$7.m("rt:f", "M")(IΦdefault$1$6.prototype, "dequeue");
	__RΦ$4$7.m("rt:t", () => __RΦ$4$7.a(168))(IΦdefault$1$6.prototype, "dequeue");
	__RΦ$4$7.m("rt:t", () => __RΦ$4$7.a(177))(IΦdefault$1$6.prototype, "items");
	__RΦ$4$7.m("rt:f", "PR")(IΦdefault$1$6.prototype, "items");

	const __RΦ$3$1$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$3$1$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$3$1$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$3$1$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [185]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$1$3.a(182) }) }, [182]: { LΦ: t => Object }, [190]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$1$3.a(180) }) }, [180]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [227]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$3$1$3.a(10), __RΦ$3$1$3.a(182)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [228]: { RΦ: t => ({ TΦ: "g", t: __RΦ$3$1$3.a(77), p: [__RΦ$3$1$3.a(182)] }) }, [77]: { LΦ: t => Object } } };
	/**
	 * О́чередь — абстрактный тип данных с дисциплиной доступа к элементам «первый пришёл — первый вышел»
	 * (FIFO, англ. first in, first out).
	 *
	 * Добавление элемента (принято обозначать словом enqueue — поставить в очередь) возможно лишь
	 * в конец очереди, выборка — только из начала очереди (что принято называть словом dequeue — убрать из очереди),
	 * при этом выбранный элемент из очереди удаляется.
	 *
	 * @link https://bit.ly/3tPM13G
	 */
	class Queue$6 {
	    storage = [];
	    enqueue(...items) {
	        this.storage.push(...items);
	    }
	    dequeue() {
	        return this.storage.shift();
	    }
	    get items() {
	        return this.storage;
	    }
	}
	(t => __RΦ$3$1$3.t[181] = t)(Queue$6);
	__RΦ$3$1$3.m("rt:SP", [])(Queue$6);
	__RΦ$3$1$3.m("rt:P", ["storage", "items"])(Queue$6);
	__RΦ$3$1$3.m("rt:Sm", [])(Queue$6);
	__RΦ$3$1$3.m("rt:m", ["enqueue", "dequeue"])(Queue$6);
	__RΦ$3$1$3.m("rt:i", [() => undefined])(Queue$6);
	__RΦ$3$1$3.m("rt:f", "Ce")(Queue$6);
	__RΦ$3$1$3.m("rt:t", () => __RΦ$3$1$3.a(185))(Queue$6.prototype, "storage");
	__RΦ$3$1$3.m("rt:f", "P#")(Queue$6.prototype, "storage");
	__RΦ$3$1$3.m("rt:f", "M$")(Queue$6.prototype["enqueue"]);
	((t, p) => __RΦ$3$1$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue$6.prototype, "enqueue");
	__RΦ$3$1$3.m("rt:p", [{ n: "items", t: () => __RΦ$3$1$3.a(190), v: null }])(Queue$6.prototype, "enqueue");
	__RΦ$3$1$3.m("rt:f", "M$")(Queue$6.prototype, "enqueue");
	__RΦ$3$1$3.m("rt:t", () => __RΦ$3$1$3.a(23))(Queue$6.prototype, "enqueue");
	__RΦ$3$1$3.m("rt:f", "M$")(Queue$6.prototype["dequeue"]);
	((t, p) => __RΦ$3$1$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue$6.prototype, "dequeue");
	__RΦ$3$1$3.m("rt:p", [])(Queue$6.prototype, "dequeue");
	__RΦ$3$1$3.m("rt:f", "M$")(Queue$6.prototype, "dequeue");
	__RΦ$3$1$3.m("rt:t", () => __RΦ$3$1$3.a(227))(Queue$6.prototype, "dequeue");
	__RΦ$3$1$3.m("rt:t", () => __RΦ$3$1$3.a(228))(Queue$6.prototype, "items");
	__RΦ$3$1$3.m("rt:f", "P$")(Queue$6.prototype, "items");

	const __RΦ$2$1$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$2$1$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$2$1$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$2$1$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [407]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$1$4.a(404) }) }, [404]: { LΦ: t => Object }, [273]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$4.a(178), p: [__RΦ$2$1$4.a(230)] }) }, [178]: { LΦ: t => IΦdefault$1$6 }, [230]: { LΦ: t => Object }, [406]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$4.a(403), p: [__RΦ$2$1$4.a(230)] }) }, [403]: { TΦ: "5", name: "ILog" }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [622]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$4.a(178), p: [__RΦ$2$1$4.a(621)] }) }, [621]: { LΦ: t => Object }, [628]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$2$1$4.a(622) }, { t: __RΦ$2$1$4.a(627) }] }) }, [627]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$4.a(229), p: [__RΦ$2$1$4.a(621)] }) }, [229]: { TΦ: "5", name: "default" }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$1$4.a(14), __RΦ$2$1$4.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [397]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [629]: { LΦ: t => Function }, [408]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$1$4.a(230) }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [402]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [630]: { LΦ: t => Function }, [428]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$1$4.a(10), __RΦ$2$1$4.a(230)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	var IΦILog$6 = { name: "ILog", prototype: {}, identity: Symbol("ILog (interface)") };
	(t => __RΦ$2$1$4.t[403] = t)(IΦILog$6);
	__RΦ$2$1$4.m("rt:P", ["enqueue", "dequeue"])(IΦILog$6);
	__RΦ$2$1$4.m("rt:m", [])(IΦILog$6);
	__RΦ$2$1$4.m("rt:f", "I")(IΦILog$6);
	__RΦ$2$1$4.m("rt:t", () => __RΦ$2$1$4.a(407))(IΦILog$6.prototype, "enqueue");
	__RΦ$2$1$4.m("rt:f", "P")(IΦILog$6.prototype, "enqueue");
	__RΦ$2$1$4.m("rt:t", () => __RΦ$2$1$4.a(407))(IΦILog$6.prototype, "dequeue");
	__RΦ$2$1$4.m("rt:f", "P")(IΦILog$6.prototype, "dequeue");
	__RΦ$2$1$4.m("rt:t", () => __RΦ$2$1$4.a(407))(IΦILog$6.prototype, "enqueue");
	__RΦ$2$1$4.m("rt:f", "P")(IΦILog$6.prototype, "enqueue");
	__RΦ$2$1$4.m("rt:t", () => __RΦ$2$1$4.a(407))(IΦILog$6.prototype, "dequeue");
	__RΦ$2$1$4.m("rt:f", "P")(IΦILog$6.prototype, "dequeue");
	class QueueLog$6 {
	    queue;
	    queueProxy;
	    log = {
	        enqueue: [],
	        dequeue: []
	    };
	    get sourceQueue() {
	        return this.queue;
	    }
	    get loggedQueue() {
	        return this.queueProxy;
	    }
	    static create(queue) {
	        const queueLog = new QueueLog$6(queue);
	        return [queueLog.loggedQueue, queueLog];
	    }
	    constructor(queue) {
	        this.queue = queue;
	        this.queueProxy = (new Proxy(queue, {
	            get: this.proxyHandlerGet.bind(this)
	        }));
	    }
	    proxyHandlerGet(target, property, receiver) {
	        const origin = Reflect.get(target, property, receiver);
	        switch (property) {
	            case 'enqueue': return this.createEnqueue(target, origin);
	            case 'dequeue': return this.createDequeue(target, origin);
	            default: return origin;
	        }
	    }
	    createEnqueue(target, origin) {
	        return (__RΦ$2$1$4.f((...items) => {
	            this.log.enqueue.push(...items);
	            origin.call(target, ...items);
	        }, [__RΦ$2$1$4.m("rt:p", [{ n: "items", t: () => __RΦ$2$1$4.a(408), v: null }]), __RΦ$2$1$4.m("rt:f", "F>"), __RΦ$2$1$4.m("rt:t", () => __RΦ$2$1$4.a(23))], ""));
	    }
	    createDequeue(target, origin) {
	        return (__RΦ$2$1$4.f(() => {
	            const item = origin.call(target);
	            if (item) {
	                this.log.dequeue.push(item);
	            }
	            return item;
	        }, [__RΦ$2$1$4.m("rt:p", []), __RΦ$2$1$4.m("rt:f", "F>"), __RΦ$2$1$4.m("rt:t", () => __RΦ$2$1$4.a(428))], ""));
	    }
	}
	(t => __RΦ$2$1$4.t[229] = t)(QueueLog$6);
	__RΦ$2$1$4.m("rt:SP", [])(QueueLog$6);
	__RΦ$2$1$4.m("rt:P", ["queueProxy", "log", "sourceQueue", "loggedQueue", "queue"])(QueueLog$6);
	__RΦ$2$1$4.m("rt:Sm", ["create"])(QueueLog$6);
	__RΦ$2$1$4.m("rt:m", ["proxyHandlerGet", "createEnqueue", "createDequeue"])(QueueLog$6);
	__RΦ$2$1$4.m("rt:p", [{ n: "queue", t: () => __RΦ$2$1$4.a(273), v: null, f: "#" }])(QueueLog$6);
	__RΦ$2$1$4.m("rt:f", "Ce")(QueueLog$6);
	__RΦ$2$1$4.m("rt:t", () => __RΦ$2$1$4.a(273))(QueueLog$6.prototype, "queueProxy");
	__RΦ$2$1$4.m("rt:f", "P#R")(QueueLog$6.prototype, "queueProxy");
	__RΦ$2$1$4.m("rt:t", () => __RΦ$2$1$4.a(406))(QueueLog$6.prototype, "log");
	__RΦ$2$1$4.m("rt:f", "P#")(QueueLog$6.prototype, "log");
	__RΦ$2$1$4.m("rt:t", () => __RΦ$2$1$4.a(4))(QueueLog$6.prototype, "sourceQueue");
	__RΦ$2$1$4.m("rt:f", "P$")(QueueLog$6.prototype, "sourceQueue");
	__RΦ$2$1$4.m("rt:t", () => __RΦ$2$1$4.a(4))(QueueLog$6.prototype, "loggedQueue");
	__RΦ$2$1$4.m("rt:f", "P$")(QueueLog$6.prototype, "loggedQueue");
	__RΦ$2$1$4.m("rt:f", "M$S")(QueueLog$6["create"]);
	((t, p) => __RΦ$2$1$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$6, "create");
	__RΦ$2$1$4.m("rt:p", [{ n: "queue", t: () => __RΦ$2$1$4.a(622), v: null }])(QueueLog$6, "create");
	__RΦ$2$1$4.m("rt:f", "M$S")(QueueLog$6, "create");
	__RΦ$2$1$4.m("rt:t", () => __RΦ$2$1$4.a(628))(QueueLog$6, "create");
	__RΦ$2$1$4.m("rt:f", "M#")(QueueLog$6.prototype["proxyHandlerGet"]);
	((t, p) => __RΦ$2$1$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$6.prototype, "proxyHandlerGet");
	__RΦ$2$1$4.m("rt:p", [{ n: "target", t: () => __RΦ$2$1$4.a(273), v: null }, { n: "property", t: () => __RΦ$2$1$4.a(143), v: null }, { n: "receiver", t: () => __RΦ$2$1$4.a(1), v: null }])(QueueLog$6.prototype, "proxyHandlerGet");
	__RΦ$2$1$4.m("rt:f", "M#")(QueueLog$6.prototype, "proxyHandlerGet");
	__RΦ$2$1$4.m("rt:t", () => __RΦ$2$1$4.a(1))(QueueLog$6.prototype, "proxyHandlerGet");
	__RΦ$2$1$4.m("rt:f", "M#.")(QueueLog$6.prototype["createEnqueue"]);
	((t, p) => __RΦ$2$1$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$6.prototype, "createEnqueue");
	__RΦ$2$1$4.m("rt:p", [{ n: "target", t: () => __RΦ$2$1$4.a(273), v: null }, { n: "origin", t: () => __RΦ$2$1$4.a(397), v: null }])(QueueLog$6.prototype, "createEnqueue");
	__RΦ$2$1$4.m("rt:f", "M#.")(QueueLog$6.prototype, "createEnqueue");
	__RΦ$2$1$4.m("rt:t", () => __RΦ$2$1$4.a(629))(QueueLog$6.prototype, "createEnqueue");
	__RΦ$2$1$4.m("rt:f", "M#.")(QueueLog$6.prototype["createDequeue"]);
	((t, p) => __RΦ$2$1$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$6.prototype, "createDequeue");
	__RΦ$2$1$4.m("rt:p", [{ n: "target", t: () => __RΦ$2$1$4.a(273), v: null }, { n: "origin", t: () => __RΦ$2$1$4.a(402), v: null }])(QueueLog$6.prototype, "createDequeue");
	__RΦ$2$1$4.m("rt:f", "M#.")(QueueLog$6.prototype, "createDequeue");
	__RΦ$2$1$4.m("rt:t", () => __RΦ$2$1$4.a(630))(QueueLog$6.prototype, "createDequeue");

	const __RΦ$1$1$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$1$1$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$1$1$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$1$1$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$1$1$4.a(14), __RΦ$1$1$4.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [144]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$1$1$4.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [146]: { RΦ: t => ({ TΦ: "t" }) } } };
	var IΦdefault$a$4 = { name: "IEventEmitter", prototype: {}, identity: Symbol("IEventEmitter (interface)") };
	(t => __RΦ$1$1$4.t[145] = t)(IΦdefault$a$4);
	__RΦ$1$1$4.m("rt:P", [])(IΦdefault$a$4);
	__RΦ$1$1$4.m("rt:m", ["on"])(IΦdefault$a$4);
	__RΦ$1$1$4.m("rt:f", "Ie")(IΦdefault$a$4);
	__RΦ$1$1$4.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$1$4.a(143), v: null }, { n: "listener", t: () => __RΦ$1$1$4.a(144), v: null }])(IΦdefault$a$4.prototype, "on");
	__RΦ$1$1$4.m("rt:f", "M")(IΦdefault$a$4.prototype, "on");
	__RΦ$1$1$4.m("rt:t", () => __RΦ$1$1$4.a(146))(IΦdefault$a$4.prototype, "on");
	__RΦ$1$1$4.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$1$4.a(143), v: null }, { n: "listener", t: () => __RΦ$1$1$4.a(144), v: null }])(IΦdefault$a$4.prototype, "on");
	__RΦ$1$1$4.m("rt:f", "M")(IΦdefault$a$4.prototype, "on");
	__RΦ$1$1$4.m("rt:t", () => __RΦ$1$1$4.a(146))(IΦdefault$a$4.prototype, "on");

	const __RΦ$s$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$s$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$s$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$s$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [4]: { RΦ: t => ({ TΦ: "~" }) }, [641]: { RΦ: t => ({ TΦ: "[", e: __RΦ$s$6.a(631) }) }, [631]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [658]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$s$6.a(10), __RΦ$s$6.a(633)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [633]: { LΦ: t => Object }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$s$6.a(14), __RΦ$s$6.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [662]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$s$6.a(4) }] }) }, [634]: { RΦ: t => ({ TΦ: "t" }) } } };
	class QueueWithEventEmitter$6 extends Queue$6 {
	    eventEmitter = new EventEmitter__default$5["default"];
	    enqueue(...items) {
	        this.eventEmitter.emit('before-enqueue', this, ...items);
	        super.enqueue(...items);
	        this.eventEmitter.emit('enqueue', this, ...items);
	    }
	    dequeue() {
	        const removed = super.dequeue();
	        this.eventEmitter.emit('dequeue', this, removed);
	        return removed;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	}
	(t => __RΦ$s$6.t[632] = t)(QueueWithEventEmitter$6);
	__RΦ$s$6.m("rt:SP", [])(QueueWithEventEmitter$6);
	__RΦ$s$6.m("rt:P", ["eventEmitter"])(QueueWithEventEmitter$6);
	__RΦ$s$6.m("rt:Sm", [])(QueueWithEventEmitter$6);
	__RΦ$s$6.m("rt:m", ["enqueue", "dequeue", "on"])(QueueWithEventEmitter$6);
	__RΦ$s$6.m("rt:i", [() => undefined])(QueueWithEventEmitter$6);
	__RΦ$s$6.m("rt:f", "Ce")(QueueWithEventEmitter$6);
	__RΦ$s$6.m("rt:t", () => __RΦ$s$6.a(4))(QueueWithEventEmitter$6.prototype, "eventEmitter");
	__RΦ$s$6.m("rt:f", "P#")(QueueWithEventEmitter$6.prototype, "eventEmitter");
	__RΦ$s$6.m("rt:f", "M$")(QueueWithEventEmitter$6.prototype["enqueue"]);
	((t, p) => __RΦ$s$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$6.prototype, "enqueue");
	__RΦ$s$6.m("rt:p", [{ n: "items", t: () => __RΦ$s$6.a(641), v: null }])(QueueWithEventEmitter$6.prototype, "enqueue");
	__RΦ$s$6.m("rt:f", "M$")(QueueWithEventEmitter$6.prototype, "enqueue");
	__RΦ$s$6.m("rt:t", () => __RΦ$s$6.a(23))(QueueWithEventEmitter$6.prototype, "enqueue");
	__RΦ$s$6.m("rt:f", "M$")(QueueWithEventEmitter$6.prototype["dequeue"]);
	((t, p) => __RΦ$s$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$6.prototype, "dequeue");
	__RΦ$s$6.m("rt:p", [])(QueueWithEventEmitter$6.prototype, "dequeue");
	__RΦ$s$6.m("rt:f", "M$")(QueueWithEventEmitter$6.prototype, "dequeue");
	__RΦ$s$6.m("rt:t", () => __RΦ$s$6.a(658))(QueueWithEventEmitter$6.prototype, "dequeue");
	__RΦ$s$6.m("rt:f", "M$")(QueueWithEventEmitter$6.prototype["on"]);
	((t, p) => __RΦ$s$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$6.prototype, "on");
	__RΦ$s$6.m("rt:p", [{ n: "eventName", t: () => __RΦ$s$6.a(143), v: null }, { n: "listener", t: () => __RΦ$s$6.a(662), v: null }])(QueueWithEventEmitter$6.prototype, "on");
	__RΦ$s$6.m("rt:f", "M$")(QueueWithEventEmitter$6.prototype, "on");
	__RΦ$s$6.m("rt:t", () => __RΦ$s$6.a(634))(QueueWithEventEmitter$6.prototype, "on");

	dist$6.Angle = Angle$6;
	dist$6.Convert = Convert$6;
	dist$6.GameLoop = GameLoop$6;
	dist$6.KeyUpDownProcessor = KeyUpDownProcessor$6;
	var Lazy_1 = dist$6.Lazy = Lazy$6;
	dist$6.Queue = Queue$6;
	dist$6.QueueLog = QueueLog$6;
	dist$6.QueueWithEventEmitter = QueueWithEventEmitter$6;
	dist$6.Shortcut = Shortcut$6;
	dist$6.ShortcutDispatcher = ShortcutDispatcher$6;
	dist$6.Timer = Timer$6;
	dist$6.Vector = Vector$6;
	dist$6.execActionScript = execActionScript$6;
	dist$6.execFunctionScript = execFunctionScript$6;
	dist$6.isBrowser = isBrowser$6;
	dist$6.isStoppable = isStoppable$6;
	dist$6.onKeyDown = onKeyDown$6;
	dist$6.onKeyUp = onKeyUp$6;
	dist$6.toOneLine = toOneLine$6;

	const __RΦ$3$7 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$3$7.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$3$7.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$3$7.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [75]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$7.a(1) }) }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [209]: { LΦ: t => Object }, [105]: { LΦ: t => IoC }, [551]: { RΦ: t => ({ TΦ: "g", t: __RΦ$3$7.a(512), p: [__RΦ$3$7.a(550)] }) }, [512]: { LΦ: t => dist$7.ReflectedTypeRef }, [550]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$3$7.a(14), __RΦ$3$7.a(15), __RΦ$3$7.a(63), __RΦ$3$7.a(534), __RΦ$3$7.a(535), __RΦ$3$7.a(536), __RΦ$3$7.a(537), __RΦ$3$7.a(538), __RΦ$3$7.a(539), __RΦ$3$7.a(540), __RΦ$3$7.a(541), __RΦ$3$7.a(542), __RΦ$3$7.a(543), __RΦ$3$7.a(544), __RΦ$3$7.a(549)] }) }, [15]: { LΦ: t => Number }, [63]: { LΦ: t => Function }, [534]: { RΦ: t => ({ TΦ: "O", m: [{ n: "T\u03A6", f: "", t: __RΦ$3$7.a(516) }] }) }, [516]: { LΦ: t => Object }, [535]: { LΦ: t => common["IΦRtObjectType"] }, [536]: { LΦ: t => common["IΦRtUnionType"] }, [537]: { LΦ: t => common["IΦRtIntersectionType"] }, [538]: { LΦ: t => common["IΦRtTupleType"] }, [539]: { LΦ: t => common["IΦRtArrayType"] }, [540]: { LΦ: t => common["IΦRtGenericType"] }, [541]: { LΦ: t => common["IΦRtMappedType"] }, [542]: { LΦ: t => common["IΦRtEnumType"] }, [543]: { LΦ: t => common["IΦRtCallSite"] }, [544]: { RΦ: t => ({ TΦ: "O", m: [{ n: "T\u03A6", f: "", t: __RΦ$3$7.a(552) }] }) }, [552]: { LΦ: t => "5" }, [549]: { RΦ: t => ({ TΦ: "g", t: __RΦ$3$7.a(546), p: [__RΦ$3$7.a(1)] }) }, [546]: { LΦ: t => dist$7["IΦInterfaceToken"] } } };
	var IΦdefault$n = { name: "IResolverContext", prototype: {}, identity: Symbol("IResolverContext (interface)") };
	(t => __RΦ$3$7.t[173] = t)(IΦdefault$n);
	__RΦ$3$7.m("rt:P", ["iocContainer", "reflectedTypeRef"])(IΦdefault$n);
	__RΦ$3$7.m("rt:m", ["resolve"])(IΦdefault$n);
	__RΦ$3$7.m("rt:f", "Ie")(IΦdefault$n);
	__RΦ$3$7.m("rt:p", [{ n: "dependencyName", t: () => __RΦ$3$7.a(14), v: null }, { n: "args", t: () => __RΦ$3$7.a(75), v: null }])(IΦdefault$n.prototype, "resolve");
	__RΦ$3$7.m("rt:f", "M")(IΦdefault$n.prototype, "resolve");
	__RΦ$3$7.m("rt:t", () => __RΦ$3$7.a(209))(IΦdefault$n.prototype, "resolve");
	__RΦ$3$7.m("rt:t", () => __RΦ$3$7.a(105))(IΦdefault$n.prototype, "iocContainer");
	__RΦ$3$7.m("rt:f", "P")(IΦdefault$n.prototype, "iocContainer");
	__RΦ$3$7.m("rt:t", () => __RΦ$3$7.a(551))(IΦdefault$n.prototype, "reflectedTypeRef");
	__RΦ$3$7.m("rt:f", "P?")(IΦdefault$n.prototype, "reflectedTypeRef");
	__RΦ$3$7.m("rt:p", [{ n: "dependencyName", t: () => __RΦ$3$7.a(14), v: null }, { n: "args", t: () => __RΦ$3$7.a(75), v: null }])(IΦdefault$n.prototype, "resolve");
	__RΦ$3$7.m("rt:f", "M")(IΦdefault$n.prototype, "resolve");
	__RΦ$3$7.m("rt:t", () => __RΦ$3$7.a(209))(IΦdefault$n.prototype, "resolve");
	__RΦ$3$7.m("rt:t", () => __RΦ$3$7.a(105))(IΦdefault$n.prototype, "iocContainer");
	__RΦ$3$7.m("rt:f", "P")(IΦdefault$n.prototype, "iocContainer");
	__RΦ$3$7.m("rt:t", () => __RΦ$3$7.a(551))(IΦdefault$n.prototype, "reflectedTypeRef");
	__RΦ$3$7.m("rt:f", "P?")(IΦdefault$n.prototype, "reflectedTypeRef");

	const __RΦ$2$8 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$2$8.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$2$8.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$2$8.t[id] = t = l;
	        }
	        return t;
	    }, t: { [4]: { RΦ: t => ({ TΦ: "~" }) }, [324]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$8.a(321), p: [__RΦ$2$8.a(105)] }) }, [321]: { LΦ: t => Lazy_1 }, [105]: { TΦ: "5", name: "default" }, [101]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$8.a(87), p: [__RΦ$2$8.a(14), __RΦ$2$8.a(91)] }) }, [87]: { LΦ: t => Map }, [14]: { LΦ: t => String }, [91]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$2$8.a(4) }] }) }, [103]: { LΦ: t => Object }, [102]: { LΦ: t => Object }, [119]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$8.a(14) }) }, [109]: { LΦ: t => Object }, [108]: { LΦ: t => Object }, [173]: { LΦ: t => IΦdefault$n } } };
	class IoC {
	    static registratorDependencyName = 'Registrator';
	    static instanceHolder = new Lazy$1$1(() => new IoC);
	    dependencyMap = new Map();
	    static get instance() {
	        return this.instanceHolder.value;
	    }
	    static resolve(dependencyName, ...params) {
	        return this.instance.resolve(dependencyName, ...params);
	    }
	    get dependencyNames() {
	        const result = [];
	        for (const key of this.dependencyMap.keys()) {
	            result.push(key);
	        }
	        return result;
	    }
	    constructor() {
	        this.dependencyMap.set(IoC.registratorDependencyName, createRegistratorResolver(this.dependencyMap));
	    }
	    resolve(dependencyName, ...params) {
	        const resolver = this.dependencyMap.get(dependencyName);
	        if (!resolver) {
	            throw new Error(`Не найдена зависимость '${dependencyName}'`);
	        }
	        return resolver(...params, this.getResolverContext());
	    }
	    getResolverContext() {
	        return {
	            resolve: this.resolve.bind(this),
	            iocContainer: this
	        };
	    }
	}
	(t => __RΦ$2$8.t[105] = t)(IoC);
	__RΦ$2$8.m("rt:SP", ["registratorDependencyName", "instanceHolder", "instance"])(IoC);
	__RΦ$2$8.m("rt:P", ["dependencyMap", "dependencyNames"])(IoC);
	__RΦ$2$8.m("rt:Sm", ["resolve"])(IoC);
	__RΦ$2$8.m("rt:m", ["resolve", "getResolverContext"])(IoC);
	__RΦ$2$8.m("rt:p", [])(IoC);
	__RΦ$2$8.m("rt:f", "Ce")(IoC);
	__RΦ$2$8.m("rt:t", () => __RΦ$2$8.a(4))(IoC, "registratorDependencyName");
	__RΦ$2$8.m("rt:f", "P#R")(IoC, "registratorDependencyName");
	__RΦ$2$8.m("rt:t", () => __RΦ$2$8.a(324))(IoC, "instanceHolder");
	__RΦ$2$8.m("rt:f", "P#R")(IoC, "instanceHolder");
	__RΦ$2$8.m("rt:t", () => __RΦ$2$8.a(101))(IoC.prototype, "dependencyMap");
	__RΦ$2$8.m("rt:f", "P#R")(IoC.prototype, "dependencyMap");
	__RΦ$2$8.m("rt:t", () => __RΦ$2$8.a(105))(IoC, "instance");
	__RΦ$2$8.m("rt:f", "P$")(IoC, "instance");
	__RΦ$2$8.m("rt:f", "M$S")(IoC["resolve"]);
	((t, p) => __RΦ$2$8.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(IoC, "resolve");
	__RΦ$2$8.m("rt:p", [{ n: "dependencyName", t: () => __RΦ$2$8.a(14), v: null }, { n: "params", t: () => __RΦ$2$8.a(103), v: null }])(IoC, "resolve");
	__RΦ$2$8.m("rt:f", "M$S")(IoC, "resolve");
	__RΦ$2$8.m("rt:t", () => __RΦ$2$8.a(102))(IoC, "resolve");
	__RΦ$2$8.m("rt:t", () => __RΦ$2$8.a(119))(IoC.prototype, "dependencyNames");
	__RΦ$2$8.m("rt:f", "P$")(IoC.prototype, "dependencyNames");
	__RΦ$2$8.m("rt:f", "M$")(IoC.prototype["resolve"]);
	((t, p) => __RΦ$2$8.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(IoC.prototype, "resolve");
	__RΦ$2$8.m("rt:p", [{ n: "dependencyName", t: () => __RΦ$2$8.a(14), v: null }, { n: "params", t: () => __RΦ$2$8.a(109), v: null }])(IoC.prototype, "resolve");
	__RΦ$2$8.m("rt:f", "M$")(IoC.prototype, "resolve");
	__RΦ$2$8.m("rt:t", () => __RΦ$2$8.a(108))(IoC.prototype, "resolve");
	__RΦ$2$8.m("rt:f", "M#")(IoC.prototype["getResolverContext"]);
	((t, p) => __RΦ$2$8.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(IoC.prototype, "getResolverContext");
	__RΦ$2$8.m("rt:p", [])(IoC.prototype, "getResolverContext");
	__RΦ$2$8.m("rt:f", "M#")(IoC.prototype, "getResolverContext");
	__RΦ$2$8.m("rt:t", () => __RΦ$2$8.a(173))(IoC.prototype, "getResolverContext");

	const __RΦ$1$8 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$1$8.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$1$8.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$1$8.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [556]: { LΦ: t => Object }, [555]: { LΦ: t => Object } } };
	function resolve(dependencyName, ...params) {
	    return IoC.resolve(dependencyName, ...params);
	}
	__RΦ$1$8.m("rt:p", [{ n: "dependencyName", t: () => __RΦ$1$8.a(14), v: null }, { n: "params", t: () => __RΦ$1$8.a(556), v: null }])(resolve);
	__RΦ$1$8.m("rt:f", "F")(resolve);
	__RΦ$1$8.m("rt:t", () => __RΦ$1$8.a(555))(resolve);

	const __RΦ$P = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$P.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$P.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$P.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [560]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	function register(dependencyName, resolver) {
	    return resolve('Registrator', dependencyName, resolver).register();
	}
	__RΦ$P.m("rt:p", [{ n: "dependencyName", t: () => __RΦ$P.a(14), v: null }, { n: "resolver", t: () => __RΦ$P.a(560), v: null }])(register);
	__RΦ$P.m("rt:f", "F")(register);
	__RΦ$P.m("rt:t", () => __RΦ$P.a(23))(register);

	const inversionOfControlPackageName = 'khusamov-inversion-of-control';
	const inversionOfControlPackageSymbol = Symbol.for(inversionOfControlPackageName);
	if (Reflect.get(window, inversionOfControlPackageSymbol) === inversionOfControlPackageName) {
	    console.warn(`Пакет '${inversionOfControlPackageName}' загружен повторно!`);
	}
	if (Reflect.get(window, inversionOfControlPackageSymbol) !== inversionOfControlPackageName) {
	    Object.defineProperty(window, inversionOfControlPackageSymbol, {
	        writable: true,
	        value: inversionOfControlPackageName
	    });
	}

	var index_es$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		register: register,
		resolve: resolve
	});

	var events$4 = {exports: {}};

	var R$4 = typeof Reflect === 'object' ? Reflect : null;
	var ReflectApply$4 = R$4 && typeof R$4.apply === 'function'
	  ? R$4.apply
	  : function ReflectApply(target, receiver, args) {
	    return Function.prototype.apply.call(target, receiver, args);
	  };

	var ReflectOwnKeys$4;
	if (R$4 && typeof R$4.ownKeys === 'function') {
	  ReflectOwnKeys$4 = R$4.ownKeys;
	} else if (Object.getOwnPropertySymbols) {
	  ReflectOwnKeys$4 = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target)
	      .concat(Object.getOwnPropertySymbols(target));
	  };
	} else {
	  ReflectOwnKeys$4 = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target);
	  };
	}

	function ProcessEmitWarning$4(warning) {
	  if (console && console.warn) console.warn(warning);
	}

	var NumberIsNaN$4 = Number.isNaN || function NumberIsNaN(value) {
	  return value !== value;
	};

	function EventEmitter$6() {
	  EventEmitter$6.init.call(this);
	}
	events$4.exports = EventEmitter$6;
	events$4.exports.once = once$4;

	// Backwards-compat with node 0.10.x
	EventEmitter$6.EventEmitter = EventEmitter$6;

	EventEmitter$6.prototype._events = undefined;
	EventEmitter$6.prototype._eventsCount = 0;
	EventEmitter$6.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	var defaultMaxListeners$4 = 10;

	function checkListener$4(listener) {
	  if (typeof listener !== 'function') {
	    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
	  }
	}

	Object.defineProperty(EventEmitter$6, 'defaultMaxListeners', {
	  enumerable: true,
	  get: function() {
	    return defaultMaxListeners$4;
	  },
	  set: function(arg) {
	    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN$4(arg)) {
	      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
	    }
	    defaultMaxListeners$4 = arg;
	  }
	});

	EventEmitter$6.init = function() {

	  if (this._events === undefined ||
	      this._events === Object.getPrototypeOf(this)._events) {
	    this._events = Object.create(null);
	    this._eventsCount = 0;
	  }

	  this._maxListeners = this._maxListeners || undefined;
	};

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter$6.prototype.setMaxListeners = function setMaxListeners(n) {
	  if (typeof n !== 'number' || n < 0 || NumberIsNaN$4(n)) {
	    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
	  }
	  this._maxListeners = n;
	  return this;
	};

	function _getMaxListeners$4(that) {
	  if (that._maxListeners === undefined)
	    return EventEmitter$6.defaultMaxListeners;
	  return that._maxListeners;
	}

	EventEmitter$6.prototype.getMaxListeners = function getMaxListeners() {
	  return _getMaxListeners$4(this);
	};

	EventEmitter$6.prototype.emit = function emit(type) {
	  var args = [];
	  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
	  var doError = (type === 'error');

	  var events = this._events;
	  if (events !== undefined)
	    doError = (doError && events.error === undefined);
	  else if (!doError)
	    return false;

	  // If there is no 'error' event listener then throw.
	  if (doError) {
	    var er;
	    if (args.length > 0)
	      er = args[0];
	    if (er instanceof Error) {
	      // Note: The comments on the `throw` lines are intentional, they show
	      // up in Node's output if this results in an unhandled exception.
	      throw er; // Unhandled 'error' event
	    }
	    // At least give some kind of context to the user
	    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
	    err.context = er;
	    throw err; // Unhandled 'error' event
	  }

	  var handler = events[type];

	  if (handler === undefined)
	    return false;

	  if (typeof handler === 'function') {
	    ReflectApply$4(handler, this, args);
	  } else {
	    var len = handler.length;
	    var listeners = arrayClone$4(handler, len);
	    for (var i = 0; i < len; ++i)
	      ReflectApply$4(listeners[i], this, args);
	  }

	  return true;
	};

	function _addListener$4(target, type, listener, prepend) {
	  var m;
	  var events;
	  var existing;

	  checkListener$4(listener);

	  events = target._events;
	  if (events === undefined) {
	    events = target._events = Object.create(null);
	    target._eventsCount = 0;
	  } else {
	    // To avoid recursion in the case that type === "newListener"! Before
	    // adding it to the listeners, first emit "newListener".
	    if (events.newListener !== undefined) {
	      target.emit('newListener', type,
	                  listener.listener ? listener.listener : listener);

	      // Re-assign `events` because a newListener handler could have caused the
	      // this._events to be assigned to a new object
	      events = target._events;
	    }
	    existing = events[type];
	  }

	  if (existing === undefined) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    existing = events[type] = listener;
	    ++target._eventsCount;
	  } else {
	    if (typeof existing === 'function') {
	      // Adding the second element, need to change to array.
	      existing = events[type] =
	        prepend ? [listener, existing] : [existing, listener];
	      // If we've already got an array, just append.
	    } else if (prepend) {
	      existing.unshift(listener);
	    } else {
	      existing.push(listener);
	    }

	    // Check for listener leak
	    m = _getMaxListeners$4(target);
	    if (m > 0 && existing.length > m && !existing.warned) {
	      existing.warned = true;
	      // No error code for this since it is a Warning
	      // eslint-disable-next-line no-restricted-syntax
	      var w = new Error('Possible EventEmitter memory leak detected. ' +
	                          existing.length + ' ' + String(type) + ' listeners ' +
	                          'added. Use emitter.setMaxListeners() to ' +
	                          'increase limit');
	      w.name = 'MaxListenersExceededWarning';
	      w.emitter = target;
	      w.type = type;
	      w.count = existing.length;
	      ProcessEmitWarning$4(w);
	    }
	  }

	  return target;
	}

	EventEmitter$6.prototype.addListener = function addListener(type, listener) {
	  return _addListener$4(this, type, listener, false);
	};

	EventEmitter$6.prototype.on = EventEmitter$6.prototype.addListener;

	EventEmitter$6.prototype.prependListener =
	    function prependListener(type, listener) {
	      return _addListener$4(this, type, listener, true);
	    };

	function onceWrapper$4() {
	  if (!this.fired) {
	    this.target.removeListener(this.type, this.wrapFn);
	    this.fired = true;
	    if (arguments.length === 0)
	      return this.listener.call(this.target);
	    return this.listener.apply(this.target, arguments);
	  }
	}

	function _onceWrap$4(target, type, listener) {
	  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
	  var wrapped = onceWrapper$4.bind(state);
	  wrapped.listener = listener;
	  state.wrapFn = wrapped;
	  return wrapped;
	}

	EventEmitter$6.prototype.once = function once(type, listener) {
	  checkListener$4(listener);
	  this.on(type, _onceWrap$4(this, type, listener));
	  return this;
	};

	EventEmitter$6.prototype.prependOnceListener =
	    function prependOnceListener(type, listener) {
	      checkListener$4(listener);
	      this.prependListener(type, _onceWrap$4(this, type, listener));
	      return this;
	    };

	// Emits a 'removeListener' event if and only if the listener was removed.
	EventEmitter$6.prototype.removeListener =
	    function removeListener(type, listener) {
	      var list, events, position, i, originalListener;

	      checkListener$4(listener);

	      events = this._events;
	      if (events === undefined)
	        return this;

	      list = events[type];
	      if (list === undefined)
	        return this;

	      if (list === listener || list.listener === listener) {
	        if (--this._eventsCount === 0)
	          this._events = Object.create(null);
	        else {
	          delete events[type];
	          if (events.removeListener)
	            this.emit('removeListener', type, list.listener || listener);
	        }
	      } else if (typeof list !== 'function') {
	        position = -1;

	        for (i = list.length - 1; i >= 0; i--) {
	          if (list[i] === listener || list[i].listener === listener) {
	            originalListener = list[i].listener;
	            position = i;
	            break;
	          }
	        }

	        if (position < 0)
	          return this;

	        if (position === 0)
	          list.shift();
	        else {
	          spliceOne$4(list, position);
	        }

	        if (list.length === 1)
	          events[type] = list[0];

	        if (events.removeListener !== undefined)
	          this.emit('removeListener', type, originalListener || listener);
	      }

	      return this;
	    };

	EventEmitter$6.prototype.off = EventEmitter$6.prototype.removeListener;

	EventEmitter$6.prototype.removeAllListeners =
	    function removeAllListeners(type) {
	      var listeners, events, i;

	      events = this._events;
	      if (events === undefined)
	        return this;

	      // not listening for removeListener, no need to emit
	      if (events.removeListener === undefined) {
	        if (arguments.length === 0) {
	          this._events = Object.create(null);
	          this._eventsCount = 0;
	        } else if (events[type] !== undefined) {
	          if (--this._eventsCount === 0)
	            this._events = Object.create(null);
	          else
	            delete events[type];
	        }
	        return this;
	      }

	      // emit removeListener for all listeners on all events
	      if (arguments.length === 0) {
	        var keys = Object.keys(events);
	        var key;
	        for (i = 0; i < keys.length; ++i) {
	          key = keys[i];
	          if (key === 'removeListener') continue;
	          this.removeAllListeners(key);
	        }
	        this.removeAllListeners('removeListener');
	        this._events = Object.create(null);
	        this._eventsCount = 0;
	        return this;
	      }

	      listeners = events[type];

	      if (typeof listeners === 'function') {
	        this.removeListener(type, listeners);
	      } else if (listeners !== undefined) {
	        // LIFO order
	        for (i = listeners.length - 1; i >= 0; i--) {
	          this.removeListener(type, listeners[i]);
	        }
	      }

	      return this;
	    };

	function _listeners$4(target, type, unwrap) {
	  var events = target._events;

	  if (events === undefined)
	    return [];

	  var evlistener = events[type];
	  if (evlistener === undefined)
	    return [];

	  if (typeof evlistener === 'function')
	    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

	  return unwrap ?
	    unwrapListeners$4(evlistener) : arrayClone$4(evlistener, evlistener.length);
	}

	EventEmitter$6.prototype.listeners = function listeners(type) {
	  return _listeners$4(this, type, true);
	};

	EventEmitter$6.prototype.rawListeners = function rawListeners(type) {
	  return _listeners$4(this, type, false);
	};

	EventEmitter$6.listenerCount = function(emitter, type) {
	  if (typeof emitter.listenerCount === 'function') {
	    return emitter.listenerCount(type);
	  } else {
	    return listenerCount$4.call(emitter, type);
	  }
	};

	EventEmitter$6.prototype.listenerCount = listenerCount$4;
	function listenerCount$4(type) {
	  var events = this._events;

	  if (events !== undefined) {
	    var evlistener = events[type];

	    if (typeof evlistener === 'function') {
	      return 1;
	    } else if (evlistener !== undefined) {
	      return evlistener.length;
	    }
	  }

	  return 0;
	}

	EventEmitter$6.prototype.eventNames = function eventNames() {
	  return this._eventsCount > 0 ? ReflectOwnKeys$4(this._events) : [];
	};

	function arrayClone$4(arr, n) {
	  var copy = new Array(n);
	  for (var i = 0; i < n; ++i)
	    copy[i] = arr[i];
	  return copy;
	}

	function spliceOne$4(list, index) {
	  for (; index + 1 < list.length; index++)
	    list[index] = list[index + 1];
	  list.pop();
	}

	function unwrapListeners$4(arr) {
	  var ret = new Array(arr.length);
	  for (var i = 0; i < ret.length; ++i) {
	    ret[i] = arr[i].listener || arr[i];
	  }
	  return ret;
	}

	function once$4(emitter, name) {
	  return new Promise(function (resolve, reject) {
	    function errorListener(err) {
	      emitter.removeListener(name, resolver);
	      reject(err);
	    }

	    function resolver() {
	      if (typeof emitter.removeListener === 'function') {
	        emitter.removeListener('error', errorListener);
	      }
	      resolve([].slice.call(arguments));
	    }
	    eventTargetAgnosticAddListener$4(emitter, name, resolver, { once: true });
	    if (name !== 'error') {
	      addErrorHandlerIfEventEmitter$4(emitter, errorListener, { once: true });
	    }
	  });
	}

	function addErrorHandlerIfEventEmitter$4(emitter, handler, flags) {
	  if (typeof emitter.on === 'function') {
	    eventTargetAgnosticAddListener$4(emitter, 'error', handler, flags);
	  }
	}

	function eventTargetAgnosticAddListener$4(emitter, name, listener, flags) {
	  if (typeof emitter.on === 'function') {
	    if (flags.once) {
	      emitter.once(name, listener);
	    } else {
	      emitter.on(name, listener);
	    }
	  } else if (typeof emitter.addEventListener === 'function') {
	    // EventTarget does not have `error` event semantics like Node
	    // EventEmitters, we do not listen for `error` events here.
	    emitter.addEventListener(name, function wrapListener(arg) {
	      // IE does not have builtin `{ once: true }` support so we
	      // have to do it manually.
	      if (flags.once) {
	        emitter.removeEventListener(name, wrapListener);
	      }
	      listener(arg);
	    });
	  } else {
	    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
	  }
	}

	var EventEmitter$7 = events$4.exports;

	const __RΦ$t$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$t$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$t$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$t$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [95]: { LΦ: t => SyntaxError }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Обработчик синтаксической ошибки в коде source.
	 * @param error
	 * @param source
	 */
	function syntaxErrorHandler$5(error, source) {
	    console.group('Синтаксическая ошибка');
	    console.log(error.message);
	    console.log(source);
	    console.log(error.stack);
	    console.groupEnd();
	}
	__RΦ$t$4.m("rt:p", [{ n: "error", t: () => __RΦ$t$4.a(95), v: null }, { n: "source", t: () => __RΦ$t$4.a(14), v: null }])(syntaxErrorHandler$5);
	__RΦ$t$4.m("rt:f", "F")(syntaxErrorHandler$5);
	__RΦ$t$4.m("rt:t", () => __RΦ$t$4.a(23))(syntaxErrorHandler$5);

	const __RΦ$s$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$s$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$s$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$s$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [112]: { LΦ: t => Object } } };
	/**
	 * Выполнить скрипт из текста, который возвращает значение типа T.
	 * @param source
	 */
	function execFunctionScript$5(source) {
	    if (!source.trim()) {
	        throw new Error('Не задано тело функции');
	    }
	    try {
	        const code = new Function('', `return (${source})`);
	        return code();
	    }
	    catch (error) {
	        if (error instanceof SyntaxError) {
	            syntaxErrorHandler$5(error, source);
	        }
	        throw error;
	    }
	}
	__RΦ$s$5.m("rt:p", [{ n: "source", t: () => __RΦ$s$5.a(14), v: null }])(execFunctionScript$5);
	__RΦ$s$5.m("rt:f", "F")(execFunctionScript$5);
	__RΦ$s$5.m("rt:t", () => __RΦ$s$5.a(112))(execFunctionScript$5);

	const __RΦ$r$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$r$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$r$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$r$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [113]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$r$5.a(10), __RΦ$r$5.a(14)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Выполнить скрипт из текста, который ничего не возвращает.
	 * @param source
	 */
	function execActionScript$5(source) {
	    if (source) {
	        try {
	            const code = new Function('', source);
	            code();
	        }
	        catch (error) {
	            if (error instanceof SyntaxError) {
	                syntaxErrorHandler$5(error, source);
	            }
	            throw error;
	        }
	    }
	}
	__RΦ$r$5.m("rt:p", [{ n: "source", t: () => __RΦ$r$5.a(113), v: null }])(execActionScript$5);
	__RΦ$r$5.m("rt:f", "F")(execActionScript$5);
	__RΦ$r$5.m("rt:t", () => __RΦ$r$5.a(23))(execActionScript$5);

	const __RΦ$q$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$q$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$q$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$q$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String } } };
	const SPACE$5 = ' ';
	const EOL$5 = '\n';
	const trim$5 = __RΦ$q$5.f((message) => message.trim()
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	, [__RΦ$q$5.m("rt:p", [{ n: "message", t: () => __RΦ$q$5.a(14), v: null }]), __RΦ$q$5.m("rt:f", "F>"), __RΦ$q$5.m("rt:t", () => __RΦ$q$5.a(14))], "trim");
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	function toOneLine$5(message) {
	    return message.trim().split(EOL$5).map(trim$5).join(SPACE$5);
	}
	__RΦ$q$5.m("rt:p", [{ n: "message", t: () => __RΦ$q$5.a(14), v: null }])(toOneLine$5);
	__RΦ$q$5.m("rt:f", "F")(toOneLine$5);
	__RΦ$q$5.m("rt:t", () => __RΦ$q$5.a(14))(toOneLine$5);

	const __RΦ$p$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$p$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$p$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$p$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1]: { RΦ: t => ({ TΦ: "~" }) } } };
	function isBrowser$5() {
	    return new Function('try { return this === window } catch (e) { return false }')();
	}
	__RΦ$p$5.m("rt:p", [])(isBrowser$5);
	__RΦ$p$5.m("rt:f", "F")(isBrowser$5);
	__RΦ$p$5.m("rt:t", () => __RΦ$p$5.a(1))(isBrowser$5);

	const __RΦ$o$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$o$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$o$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$o$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [246]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$o$5.a(15) }, { t: __RΦ$o$5.a(15) }] }) }, [15]: { LΦ: t => Number }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [234]: { LΦ: t => Function } } };
	/**
	 * Бесконечный запрос кадров анимации для текущего компонента.
	 * Если компонент уничтожается, то запрос автоматически отменяется.
	 * Возвращает мгновенный FPS и время с начала анимации в миллисекундах.
	 */
	function useRequestAnimationFrame$1() {
	    const frame = react$1.exports.useRef(0);
	    const previousTime = react$1.exports.useRef(0);
	    const [time, setTime] = react$1.exports.useState(0);
	    const [framesPerSecond, setFramesPerSecond] = react$1.exports.useState(0);
	    const render = __RΦ$o$5.f((time) => {
	        setFramesPerSecond(1000 / (time - previousTime.current));
	        setTime(time);
	        previousTime.current = time;
	        frame.current = requestAnimationFrame(render);
	    }, [__RΦ$o$5.m("rt:p", [{ n: "time", t: () => __RΦ$o$5.a(15), v: null }]), __RΦ$o$5.m("rt:f", "F>"), __RΦ$o$5.m("rt:t", () => __RΦ$o$5.a(23))], "render");
	    react$1.exports.useEffect(__RΦ$o$5.f(() => {
	        frame.current = requestAnimationFrame(render);
	        return __RΦ$o$5.f(() => cancelAnimationFrame(frame.current), [__RΦ$o$5.m("rt:p", []), __RΦ$o$5.m("rt:f", "F>"), __RΦ$o$5.m("rt:t", () => __RΦ$o$5.a(23))], "");
	    }, [__RΦ$o$5.m("rt:p", []), __RΦ$o$5.m("rt:f", "F>"), __RΦ$o$5.m("rt:t", () => __RΦ$o$5.a(234))], ""), []);
	    return [framesPerSecond, time];
	}
	__RΦ$o$5.m("rt:p", [])(useRequestAnimationFrame$1);
	__RΦ$o$5.m("rt:f", "F")(useRequestAnimationFrame$1);
	__RΦ$o$5.m("rt:t", () => __RΦ$o$5.a(246))(useRequestAnimationFrame$1);

	const __RΦ$n$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$n$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$n$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$n$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [21]: { LΦ: t => Boolean } } };
	var IΦdefault$9$5 = { name: "IStoppable", prototype: {}, identity: Symbol("IStoppable (interface)") };
	(t => __RΦ$n$5.t[256] = t)(IΦdefault$9$5);
	__RΦ$n$5.m("rt:P", [])(IΦdefault$9$5);
	__RΦ$n$5.m("rt:m", ["stop"])(IΦdefault$9$5);
	__RΦ$n$5.m("rt:f", "Ie")(IΦdefault$9$5);
	__RΦ$n$5.m("rt:p", [])(IΦdefault$9$5.prototype, "stop");
	__RΦ$n$5.m("rt:f", "M")(IΦdefault$9$5.prototype, "stop");
	__RΦ$n$5.m("rt:t", () => __RΦ$n$5.a(23))(IΦdefault$9$5.prototype, "stop");
	__RΦ$n$5.m("rt:p", [])(IΦdefault$9$5.prototype, "stop");
	__RΦ$n$5.m("rt:f", "M")(IΦdefault$9$5.prototype, "stop");
	__RΦ$n$5.m("rt:t", () => __RΦ$n$5.a(23))(IΦdefault$9$5.prototype, "stop");
	function isStoppable$5(object) {
	    return 'stop' in object && typeof object.stop === 'function';
	}
	__RΦ$n$5.m("rt:p", [{ n: "object", t: () => __RΦ$n$5.a(1), v: null }])(isStoppable$5);
	__RΦ$n$5.m("rt:f", "F")(isStoppable$5);
	__RΦ$n$5.m("rt:t", () => __RΦ$n$5.a(21))(isStoppable$5);

	const __RΦ$m$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$m$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$m$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$m$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	class Angle$5 {
	    /**
	     * Конвертация угла из радиан в градусы.
	     * @param value
	     */
	    static toDegree(value) {
	        return value / Math.PI * 180;
	    }
	    /**
	     * Конвертация угла из градусов в радианы.
	     * @param value
	     */
	    static toRadian(value) {
	        return value * Math.PI / 180;
	    }
	}
	(t => __RΦ$m$5.t[771] = t)(Angle$5);
	__RΦ$m$5.m("rt:SP", [])(Angle$5);
	__RΦ$m$5.m("rt:P", [])(Angle$5);
	__RΦ$m$5.m("rt:Sm", ["toDegree", "toRadian"])(Angle$5);
	__RΦ$m$5.m("rt:m", [])(Angle$5);
	__RΦ$m$5.m("rt:f", "Ce")(Angle$5);
	__RΦ$m$5.m("rt:f", "M$S.")(Angle$5["toDegree"]);
	((t, p) => __RΦ$m$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle$5, "toDegree");
	__RΦ$m$5.m("rt:p", [{ n: "value", t: () => __RΦ$m$5.a(15), v: null }])(Angle$5, "toDegree");
	__RΦ$m$5.m("rt:f", "M$S.")(Angle$5, "toDegree");
	__RΦ$m$5.m("rt:t", () => __RΦ$m$5.a(15))(Angle$5, "toDegree");
	__RΦ$m$5.m("rt:f", "M$S.")(Angle$5["toRadian"]);
	((t, p) => __RΦ$m$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle$5, "toRadian");
	__RΦ$m$5.m("rt:p", [{ n: "value", t: () => __RΦ$m$5.a(15), v: null }])(Angle$5, "toRadian");
	__RΦ$m$5.m("rt:f", "M$S.")(Angle$5, "toRadian");
	__RΦ$m$5.m("rt:t", () => __RΦ$m$5.a(15))(Angle$5, "toRadian");

	const __RΦ$l$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$l$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$l$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$l$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	var IΦdefault$8$5 = { name: "IPoint", prototype: {}, identity: Symbol("IPoint (interface)") };
	(t => __RΦ$l$5.t[247] = t)(IΦdefault$8$5);
	__RΦ$l$5.m("rt:P", ["x", "y"])(IΦdefault$8$5);
	__RΦ$l$5.m("rt:m", [])(IΦdefault$8$5);
	__RΦ$l$5.m("rt:f", "Ie")(IΦdefault$8$5);
	__RΦ$l$5.m("rt:t", () => __RΦ$l$5.a(15))(IΦdefault$8$5.prototype, "x");
	__RΦ$l$5.m("rt:f", "P")(IΦdefault$8$5.prototype, "x");
	__RΦ$l$5.m("rt:t", () => __RΦ$l$5.a(15))(IΦdefault$8$5.prototype, "y");
	__RΦ$l$5.m("rt:f", "P")(IΦdefault$8$5.prototype, "y");
	__RΦ$l$5.m("rt:t", () => __RΦ$l$5.a(15))(IΦdefault$8$5.prototype, "x");
	__RΦ$l$5.m("rt:f", "P")(IΦdefault$8$5.prototype, "x");
	__RΦ$l$5.m("rt:t", () => __RΦ$l$5.a(15))(IΦdefault$8$5.prototype, "y");
	__RΦ$l$5.m("rt:f", "P")(IΦdefault$8$5.prototype, "y");

	const __RΦ$k$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$k$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$k$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$k$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [247]: { LΦ: t => IΦdefault$8$5 }, [745]: { TΦ: "5", name: "default" }, [21]: { LΦ: t => Boolean }, [768]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$k$5.a(15), __RΦ$k$5.a(745)] }) }, [769]: { RΦ: t => ({ TΦ: "[", e: __RΦ$k$5.a(15) }) }, [14]: { LΦ: t => String } } };
	/*
	 * Увеличить длину вектора можно так:
	 * Vector.translate(Vector.identity.scale(length))
	 *
	 */
	/**
	 * Вектор.
	 * @unmutable
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/vector/Vector.js
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/Point.js
	 */
	class Vector$5 {
	    x;
	    y;
	    /**
	     * Расстояние от начала координат до точки.
	     */
	    static distance(point) {
	        // noinspection JSSuspiciousNameCombination
	        return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
	    }
	    /**
	     * Создать вектор на основе угла и длины.
	     */
	    static create(angle, length) {
	        return new Vector$5(length * Math.cos(angle), length * Math.sin(angle));
	    }
	    /**
	     * Угол между вектором и положительной осью.
	     * Принимает значение от -Math.PI до Math.PI радиан.
	     */
	    get angle() {
	        return Math.atan2(this.y, this.x);
	    }
	    /**
	     * Модуль (длина) вектора.
	     */
	    get length() {
	        return Vector$5.distance(this);
	    }
	    /**
	     * Возвращает true, если вектор является нулевым.
	     */
	    get isNull() {
	        return this.x === 0 && this.y === 0;
	    }
	    /**
	     * Конструктор вектора.
	     * @param x
	     * @param y
	     */
	    constructor(x = 0, y = 0) {
	        this.x = x;
	        this.y = y;
	    }
	    /**
	     * Получить единичный вектор, равный по направлению исходному.
	     * Он же направляющий вектор (единичный, равный по направлению).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get identity() {
	        return (new Vector$5(Math.cos(this.angle), Math.sin(this.angle)));
	    }
	    /**
	     * Получить обратный вектор (инверсия вектора).
	     */
	    get inverse() {
	        return new Vector$5(-this.x, -this.y);
	    }
	    /**
	     * Нормаль вектора (единичный вектор, перпендикулярный исходному).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get normal() {
	        return this.clone().rotate(Math.PI / 2).identity;
	        // TODO Проверить эту формулу нахождения перпендикулярного вектора.
	        /*
	            a: 1 / parallel.x(),
	            b: -1 / parallel.y(),
	        */
	    }
	    /**
	     * Сложение векторов.
	     * @param vector
	     */
	    translate(vector) {
	        return new Vector$5(this.x + vector.x, this.y + vector.y);
	    }
	    /**
	     * Вращение вектора.
	     * @param angle
	     */
	    rotate(angle) {
	        return new Vector$5(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle));
	    }
	    /**
	     * Умножение на число или масштабирование вектором.
	     * @param scale
	     */
	    scale(scale) {
	        return (scale instanceof Vector$5
	            ? new Vector$5(this.x * scale.x, this.y * scale.y)
	            : new Vector$5(this.x * scale, this.y * scale));
	    }
	    /**
	     * Скалярное произведение векторов.
	     *
	     * Скалярным произведением двух векторов называется число (скаляр),
	     * равное произведению длин этих векторов на косинус угла между ними.
	     * Длина вектора является его модулем.
	     * @param vector
	     */
	    multiply(vector) {
	        Object.defineProperty(this, 'Эту строку удалить после реализации метода', { value: vector });
	        throw new Error('Метод не реализован Vector.multiply()');
	    }
	    /**
	     * Взятие остатка от деления.
	     * @param vector
	     */
	    mod(vector) {
	        return new Vector$5(this.x % vector.x, this.y % vector.y);
	    }
	    clone() {
	        return new Vector$5(this.x, this.y);
	    }
	    toArray() {
	        return [this.x, this.y];
	    }
	    toString(digits = 2) {
	        return `[${this.x.toFixed(digits)}, ${this.y.toFixed(digits)}]`;
	    }
	}
	(t => __RΦ$k$5.t[745] = t)(Vector$5);
	__RΦ$k$5.m("rt:SP", [])(Vector$5);
	__RΦ$k$5.m("rt:P", ["angle", "length", "isNull", "x", "y", "identity", "inverse", "normal"])(Vector$5);
	__RΦ$k$5.m("rt:Sm", ["distance", "create"])(Vector$5);
	__RΦ$k$5.m("rt:m", ["translate", "rotate", "scale", "scale", "scale", "multiply", "mod", "clone", "toArray", "toString"])(Vector$5);
	__RΦ$k$5.m("rt:p", [{ n: "x", t: () => __RΦ$k$5.a(15), v: function () { return 0; }, f: "$R" }, { n: "y", t: () => __RΦ$k$5.a(15), v: function () { return 0; }, f: "$R" }])(Vector$5);
	__RΦ$k$5.m("rt:i", [() => undefined])(Vector$5);
	__RΦ$k$5.m("rt:f", "Ce")(Vector$5);
	__RΦ$k$5.m("rt:f", "M$S")(Vector$5["distance"]);
	((t, p) => __RΦ$k$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$5, "distance");
	__RΦ$k$5.m("rt:p", [{ n: "point", t: () => __RΦ$k$5.a(247), v: null }])(Vector$5, "distance");
	__RΦ$k$5.m("rt:f", "M$S")(Vector$5, "distance");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(15))(Vector$5, "distance");
	__RΦ$k$5.m("rt:f", "M$S")(Vector$5["create"]);
	((t, p) => __RΦ$k$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$5, "create");
	__RΦ$k$5.m("rt:p", [{ n: "angle", t: () => __RΦ$k$5.a(15), v: null }, { n: "length", t: () => __RΦ$k$5.a(15), v: null }])(Vector$5, "create");
	__RΦ$k$5.m("rt:f", "M$S")(Vector$5, "create");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(745))(Vector$5, "create");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(15))(Vector$5.prototype, "angle");
	__RΦ$k$5.m("rt:f", "P$")(Vector$5.prototype, "angle");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(15))(Vector$5.prototype, "length");
	__RΦ$k$5.m("rt:f", "P$")(Vector$5.prototype, "length");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(21))(Vector$5.prototype, "isNull");
	__RΦ$k$5.m("rt:f", "P$")(Vector$5.prototype, "isNull");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(745))(Vector$5.prototype, "identity");
	__RΦ$k$5.m("rt:f", "P$")(Vector$5.prototype, "identity");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(745))(Vector$5.prototype, "inverse");
	__RΦ$k$5.m("rt:f", "P$")(Vector$5.prototype, "inverse");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(745))(Vector$5.prototype, "normal");
	__RΦ$k$5.m("rt:f", "P$")(Vector$5.prototype, "normal");
	__RΦ$k$5.m("rt:f", "M$")(Vector$5.prototype["translate"]);
	((t, p) => __RΦ$k$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$5.prototype, "translate");
	__RΦ$k$5.m("rt:p", [{ n: "vector", t: () => __RΦ$k$5.a(745), v: null }])(Vector$5.prototype, "translate");
	__RΦ$k$5.m("rt:f", "M$")(Vector$5.prototype, "translate");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(745))(Vector$5.prototype, "translate");
	__RΦ$k$5.m("rt:f", "M$.")(Vector$5.prototype["rotate"]);
	((t, p) => __RΦ$k$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$5.prototype, "rotate");
	__RΦ$k$5.m("rt:p", [{ n: "angle", t: () => __RΦ$k$5.a(15), v: null }])(Vector$5.prototype, "rotate");
	__RΦ$k$5.m("rt:f", "M$.")(Vector$5.prototype, "rotate");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(745))(Vector$5.prototype, "rotate");
	__RΦ$k$5.m("rt:f", "M$")(Vector$5.prototype["scale"]);
	((t, p) => __RΦ$k$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$5.prototype, "scale");
	__RΦ$k$5.m("rt:p", [{ n: "scale", t: () => __RΦ$k$5.a(15), v: null }])(Vector$5.prototype, "scale");
	__RΦ$k$5.m("rt:f", "M$")(Vector$5.prototype, "scale");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(745))(Vector$5.prototype, "scale");
	__RΦ$k$5.m("rt:f", "M$")(Vector$5.prototype["scale"]);
	((t, p) => __RΦ$k$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$5.prototype, "scale");
	__RΦ$k$5.m("rt:p", [{ n: "scale", t: () => __RΦ$k$5.a(745), v: null }])(Vector$5.prototype, "scale");
	__RΦ$k$5.m("rt:f", "M$")(Vector$5.prototype, "scale");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(745))(Vector$5.prototype, "scale");
	__RΦ$k$5.m("rt:f", "M$")(Vector$5.prototype["scale"]);
	((t, p) => __RΦ$k$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$5.prototype, "scale");
	__RΦ$k$5.m("rt:p", [{ n: "scale", t: () => __RΦ$k$5.a(768), v: null }])(Vector$5.prototype, "scale");
	__RΦ$k$5.m("rt:f", "M$")(Vector$5.prototype, "scale");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(745))(Vector$5.prototype, "scale");
	__RΦ$k$5.m("rt:f", "M$")(Vector$5.prototype["multiply"]);
	((t, p) => __RΦ$k$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$5.prototype, "multiply");
	__RΦ$k$5.m("rt:p", [{ n: "vector", t: () => __RΦ$k$5.a(745), v: null }])(Vector$5.prototype, "multiply");
	__RΦ$k$5.m("rt:f", "M$")(Vector$5.prototype, "multiply");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(15))(Vector$5.prototype, "multiply");
	__RΦ$k$5.m("rt:f", "M$")(Vector$5.prototype["mod"]);
	((t, p) => __RΦ$k$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$5.prototype, "mod");
	__RΦ$k$5.m("rt:p", [{ n: "vector", t: () => __RΦ$k$5.a(745), v: null }])(Vector$5.prototype, "mod");
	__RΦ$k$5.m("rt:f", "M$")(Vector$5.prototype, "mod");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(745))(Vector$5.prototype, "mod");
	__RΦ$k$5.m("rt:f", "M$.")(Vector$5.prototype["clone"]);
	((t, p) => __RΦ$k$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$5.prototype, "clone");
	__RΦ$k$5.m("rt:p", [])(Vector$5.prototype, "clone");
	__RΦ$k$5.m("rt:f", "M$.")(Vector$5.prototype, "clone");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(745))(Vector$5.prototype, "clone");
	__RΦ$k$5.m("rt:f", "M$.")(Vector$5.prototype["toArray"]);
	((t, p) => __RΦ$k$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$5.prototype, "toArray");
	__RΦ$k$5.m("rt:p", [])(Vector$5.prototype, "toArray");
	__RΦ$k$5.m("rt:f", "M$.")(Vector$5.prototype, "toArray");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(769))(Vector$5.prototype, "toArray");
	__RΦ$k$5.m("rt:f", "M$.")(Vector$5.prototype["toString"]);
	((t, p) => __RΦ$k$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$5.prototype, "toString");
	__RΦ$k$5.m("rt:p", [{ n: "digits", t: () => __RΦ$k$5.a(15), v: function () { return 2; } }])(Vector$5.prototype, "toString");
	__RΦ$k$5.m("rt:f", "M$.")(Vector$5.prototype, "toString");
	__RΦ$k$5.m("rt:t", () => __RΦ$k$5.a(14))(Vector$5.prototype, "toString");

	const __RΦ$j$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$j$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$j$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$j$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [103]: { RΦ: t => ({ TΦ: "[", e: __RΦ$j$5.a(14) }) }, [14]: { LΦ: t => String }, [745]: { LΦ: t => Vector$5 }, [776]: { RΦ: t => ({ TΦ: "t" }) }, [15]: { LΦ: t => Number } } };
	class Transform$2 {
	    transforms = [];
	    scale({ x, y }) {
	        this.transforms.push(`scale(${x}, ${y})`);
	        return this;
	    }
	    rotate(angle) {
	        this.transforms.push(`rotate(${Angle$5.toDegree(angle)})`);
	        return this;
	    }
	    translate({ x, y }) {
	        this.transforms.push(`translate(${x}, ${y})`);
	        return this;
	    }
	    toString() {
	        return this.transforms.join(', ');
	    }
	}
	(t => __RΦ$j$5.t[775] = t)(Transform$2);
	__RΦ$j$5.m("rt:SP", [])(Transform$2);
	__RΦ$j$5.m("rt:P", ["transforms"])(Transform$2);
	__RΦ$j$5.m("rt:Sm", [])(Transform$2);
	__RΦ$j$5.m("rt:m", ["scale", "rotate", "translate", "toString"])(Transform$2);
	__RΦ$j$5.m("rt:f", "Ce")(Transform$2);
	__RΦ$j$5.m("rt:t", () => __RΦ$j$5.a(103))(Transform$2.prototype, "transforms");
	__RΦ$j$5.m("rt:f", "P#")(Transform$2.prototype, "transforms");
	__RΦ$j$5.m("rt:f", "M$")(Transform$2.prototype["scale"]);
	((t, p) => __RΦ$j$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Transform$2.prototype, "scale");
	__RΦ$j$5.m("rt:p", [{ n: "{x, y}", t: () => __RΦ$j$5.a(745), v: null }])(Transform$2.prototype, "scale");
	__RΦ$j$5.m("rt:f", "M$")(Transform$2.prototype, "scale");
	__RΦ$j$5.m("rt:t", () => __RΦ$j$5.a(776))(Transform$2.prototype, "scale");
	__RΦ$j$5.m("rt:f", "M$")(Transform$2.prototype["rotate"]);
	((t, p) => __RΦ$j$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Transform$2.prototype, "rotate");
	__RΦ$j$5.m("rt:p", [{ n: "angle", t: () => __RΦ$j$5.a(15), v: null }])(Transform$2.prototype, "rotate");
	__RΦ$j$5.m("rt:f", "M$")(Transform$2.prototype, "rotate");
	__RΦ$j$5.m("rt:t", () => __RΦ$j$5.a(776))(Transform$2.prototype, "rotate");
	__RΦ$j$5.m("rt:f", "M$")(Transform$2.prototype["translate"]);
	((t, p) => __RΦ$j$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Transform$2.prototype, "translate");
	__RΦ$j$5.m("rt:p", [{ n: "{x, y}", t: () => __RΦ$j$5.a(745), v: null }])(Transform$2.prototype, "translate");
	__RΦ$j$5.m("rt:f", "M$")(Transform$2.prototype, "translate");
	__RΦ$j$5.m("rt:t", () => __RΦ$j$5.a(776))(Transform$2.prototype, "translate");
	__RΦ$j$5.m("rt:f", "M$")(Transform$2.prototype["toString"]);
	((t, p) => __RΦ$j$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Transform$2.prototype, "toString");
	__RΦ$j$5.m("rt:p", [])(Transform$2.prototype, "toString");
	__RΦ$j$5.m("rt:f", "M$")(Transform$2.prototype, "toString");
	__RΦ$j$5.m("rt:t", () => __RΦ$j$5.a(14))(Transform$2.prototype, "toString");

	const __RΦ$i$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$i$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$i$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$i$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$7$5 = { name: "IStartable", prototype: {}, identity: Symbol("IStartable (interface)") };
	(t => __RΦ$i$5.t[255] = t)(IΦdefault$7$5);
	__RΦ$i$5.m("rt:P", [])(IΦdefault$7$5);
	__RΦ$i$5.m("rt:m", ["start"])(IΦdefault$7$5);
	__RΦ$i$5.m("rt:f", "Ie")(IΦdefault$7$5);
	__RΦ$i$5.m("rt:p", [])(IΦdefault$7$5.prototype, "start");
	__RΦ$i$5.m("rt:f", "M")(IΦdefault$7$5.prototype, "start");
	__RΦ$i$5.m("rt:t", () => __RΦ$i$5.a(23))(IΦdefault$7$5.prototype, "start");
	__RΦ$i$5.m("rt:p", [])(IΦdefault$7$5.prototype, "start");
	__RΦ$i$5.m("rt:f", "M")(IΦdefault$7$5.prototype, "start");
	__RΦ$i$5.m("rt:t", () => __RΦ$i$5.a(23))(IΦdefault$7$5.prototype, "start");

	/**
	 * Состояния таймера.
	 */
	var ETimerState$5;
	(function (ETimerState) {
	    ETimerState["Started"] = "started";
	    ETimerState["Paused"] = "paused";
	    ETimerState["Stopped"] = "stopped";
	})(ETimerState$5 || (ETimerState$5 = {}));

	const __RΦ$h$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$h$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$h$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$h$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [785]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$h$5.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [786]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$h$5.a(4) }] }) }, [787]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$h$5.a(4) }] }) } } };
	var IΦdefault$6$5 = { name: "IStateHandlers", prototype: {}, identity: Symbol("IStateHandlers (interface)") };
	(t => __RΦ$h$5.t[788] = t)(IΦdefault$6$5);
	__RΦ$h$5.m("rt:P", ["started", "paused", "stopped"])(IΦdefault$6$5);
	__RΦ$h$5.m("rt:m", [])(IΦdefault$6$5);
	__RΦ$h$5.m("rt:f", "Ie")(IΦdefault$6$5);
	__RΦ$h$5.m("rt:t", () => __RΦ$h$5.a(785))(IΦdefault$6$5.prototype, "started");
	__RΦ$h$5.m("rt:f", "P?")(IΦdefault$6$5.prototype, "started");
	__RΦ$h$5.m("rt:t", () => __RΦ$h$5.a(786))(IΦdefault$6$5.prototype, "paused");
	__RΦ$h$5.m("rt:f", "P?")(IΦdefault$6$5.prototype, "paused");
	__RΦ$h$5.m("rt:t", () => __RΦ$h$5.a(787))(IΦdefault$6$5.prototype, "stopped");
	__RΦ$h$5.m("rt:f", "P?")(IΦdefault$6$5.prototype, "stopped");
	__RΦ$h$5.m("rt:t", () => __RΦ$h$5.a(785))(IΦdefault$6$5.prototype, "started");
	__RΦ$h$5.m("rt:f", "P?")(IΦdefault$6$5.prototype, "started");
	__RΦ$h$5.m("rt:t", () => __RΦ$h$5.a(786))(IΦdefault$6$5.prototype, "paused");
	__RΦ$h$5.m("rt:f", "P?")(IΦdefault$6$5.prototype, "paused");
	__RΦ$h$5.m("rt:t", () => __RΦ$h$5.a(787))(IΦdefault$6$5.prototype, "stopped");
	__RΦ$h$5.m("rt:f", "P?")(IΦdefault$6$5.prototype, "stopped");

	const __RΦ$g$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$g$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$g$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$g$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [808]: { RΦ: t => ({ TΦ: "e", e: ETimerState$5 }) }, [792]: { RΦ: t => ({ TΦ: "g", t: __RΦ$g$5.a(788), p: [__RΦ$g$5.a(791)] }) }, [788]: { LΦ: t => IΦdefault$6$5 }, [791]: { LΦ: t => Object }, [809]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$g$5.a(10), __RΦ$g$5.a(791)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	/**
	 * Запустить определенный скрипт в зависимости от состояния таймера.
	 * @param state Текущее состояние таймера.
	 * @param stateHandlers Массив скриптов (ключ - имя состояния, значение - скрипт).
	 */
	function handleByState$5(state, stateHandlers) {
	    switch (state) {
	        case ETimerState$5.Started: return stateHandlers.started ? stateHandlers.started() : undefined;
	        case ETimerState$5.Paused: return stateHandlers.paused ? stateHandlers.paused() : undefined;
	        case ETimerState$5.Stopped: return stateHandlers.stopped ? stateHandlers.stopped() : undefined;
	    }
	}
	__RΦ$g$5.m("rt:p", [{ n: "state", t: () => __RΦ$g$5.a(808), v: null }, { n: "stateHandlers", t: () => __RΦ$g$5.a(792), v: null }])(handleByState$5);
	__RΦ$g$5.m("rt:f", "F")(handleByState$5);
	__RΦ$g$5.m("rt:t", () => __RΦ$g$5.a(809))(handleByState$5);

	const __RΦ$f$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$f$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$f$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$f$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [1718]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$f$5.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [751]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$f$5.a(10), __RΦ$f$5.a(15)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [808]: { RΦ: t => ({ TΦ: "e", e: ETimerState$5 }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Простая реализация таймера.
	 */
	class Timer$5 {
	    timeout;
	    action;
	    timerId;
	    /**
	     * Время запуска таймера. В миллисекундах.
	     * @private
	     */
	    time = 0;
	    /**
	     * Время постановки на паузу. В миллисекундах.
	     * @private
	     */
	    pauseTime = 0;
	    /**
	     * Общее время остановки таймера. В миллисекундах.
	     * @private
	     */
	    _pauseInterval = 0;
	    get pauseInterval() {
	        return this._pauseInterval;
	    }
	    /**
	     * Текущее состояние таймера
	     * @private
	     */
	    state = ETimerState$5.Stopped;
	    /**
	     * Внимание, внутри action определена this как Timer.
	     * @param timeout
	     * @param action
	     */
	    constructor(timeout, action) {
	        this.timeout = timeout;
	        this.action = action;
	    }
	    /**
	     * Запуск таймера.
	     * Стартовать таймер сначала или продолжить с паузы.
	     */
	    start() {
	        handleByState$5(this.state, {
	            paused: __RΦ$f$5.f(() => {
	                this.state = ETimerState$5.Started;
	                this._pauseInterval += Date.now() - this.pauseTime;
	            }, [__RΦ$f$5.m("rt:p", []), __RΦ$f$5.m("rt:f", "F>"), __RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(23))], "paused"),
	            stopped: __RΦ$f$5.f(() => {
	                this.state = ETimerState$5.Started;
	                this.timerId = window.setInterval(this.tick.bind(this), this.timeout);
	                this.time = Date.now();
	            }, [__RΦ$f$5.m("rt:p", []), __RΦ$f$5.m("rt:f", "F>"), __RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(23))], "stopped")
	        });
	    }
	    /**
	     * Поставить на паузу таймер.
	     * Состояние сохраняется, счет приостанавливается.
	     */
	    pause() {
	        handleByState$5(this.state, {
	            started: __RΦ$f$5.f(() => {
	                this.state = ETimerState$5.Paused;
	                this.pauseTime = Date.now();
	            }, [__RΦ$f$5.m("rt:p", []), __RΦ$f$5.m("rt:f", "F>"), __RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(23))], "started")
	        });
	    }
	    /**
	     * Остановить таймер.
	     * Полный сброс таймера.
	     */
	    stop() {
	        const stop = __RΦ$f$5.f(() => {
	            this.state = ETimerState$5.Stopped;
	            clearInterval(this.timerId);
	            this.timerId = undefined;
	            this.time = 0;
	        }, [__RΦ$f$5.m("rt:p", []), __RΦ$f$5.m("rt:f", "F>"), __RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(23))], "stop");
	        handleByState$5(this.state, {
	            started: stop,
	            paused: stop
	        });
	    }
	    /**
	     * Количество миллисекунд с начала старта таймера.
	     * С учетом всех пауз.
	     */
	    get interval() {
	        const result = handleByState$5(this.state, {
	            started: () => Date.now() - this.time - this.pauseTime,
	            paused: () => this.time - this.pauseTime,
	            stopped: () => 0
	        });
	        return result === undefined ? 0 : result;
	    }
	    /**
	     * Выполняемая нагрузка таймера.
	     * @private
	     */
	    tick() {
	        handleByState$5(this.state, {
	            started: __RΦ$f$5.f(() => this.action.call(this), [__RΦ$f$5.m("rt:p", []), __RΦ$f$5.m("rt:f", "F>"), __RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(23))], "started")
	        });
	    }
	}
	(t => __RΦ$f$5.t[811] = t)(Timer$5);
	__RΦ$f$5.m("rt:SP", [])(Timer$5);
	__RΦ$f$5.m("rt:P", ["timerId", "time", "pauseTime", "_pauseInterval", "pauseInterval", "state", "timeout", "action", "interval"])(Timer$5);
	__RΦ$f$5.m("rt:Sm", [])(Timer$5);
	__RΦ$f$5.m("rt:m", ["start", "pause", "stop", "tick"])(Timer$5);
	__RΦ$f$5.m("rt:p", [{ n: "timeout", t: () => __RΦ$f$5.a(15), v: null, f: "#" }, { n: "action", t: () => __RΦ$f$5.a(1718), v: null, f: "#" }])(Timer$5);
	__RΦ$f$5.m("rt:i", [() => undefined, () => undefined])(Timer$5);
	__RΦ$f$5.m("rt:f", "Ce")(Timer$5);
	__RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(751))(Timer$5.prototype, "timerId");
	__RΦ$f$5.m("rt:f", "P#")(Timer$5.prototype, "timerId");
	__RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(15))(Timer$5.prototype, "time");
	__RΦ$f$5.m("rt:f", "P#")(Timer$5.prototype, "time");
	__RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(15))(Timer$5.prototype, "pauseTime");
	__RΦ$f$5.m("rt:f", "P#")(Timer$5.prototype, "pauseTime");
	__RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(15))(Timer$5.prototype, "_pauseInterval");
	__RΦ$f$5.m("rt:f", "P#")(Timer$5.prototype, "_pauseInterval");
	__RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(15))(Timer$5.prototype, "pauseInterval");
	__RΦ$f$5.m("rt:f", "P$")(Timer$5.prototype, "pauseInterval");
	__RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(808))(Timer$5.prototype, "state");
	__RΦ$f$5.m("rt:f", "P#")(Timer$5.prototype, "state");
	__RΦ$f$5.m("rt:f", "M$.")(Timer$5.prototype["start"]);
	((t, p) => __RΦ$f$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$5.prototype, "start");
	__RΦ$f$5.m("rt:p", [])(Timer$5.prototype, "start");
	__RΦ$f$5.m("rt:f", "M$.")(Timer$5.prototype, "start");
	__RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(23))(Timer$5.prototype, "start");
	__RΦ$f$5.m("rt:f", "M$.")(Timer$5.prototype["pause"]);
	((t, p) => __RΦ$f$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$5.prototype, "pause");
	__RΦ$f$5.m("rt:p", [])(Timer$5.prototype, "pause");
	__RΦ$f$5.m("rt:f", "M$.")(Timer$5.prototype, "pause");
	__RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(23))(Timer$5.prototype, "pause");
	__RΦ$f$5.m("rt:f", "M$.")(Timer$5.prototype["stop"]);
	((t, p) => __RΦ$f$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$5.prototype, "stop");
	__RΦ$f$5.m("rt:p", [])(Timer$5.prototype, "stop");
	__RΦ$f$5.m("rt:f", "M$.")(Timer$5.prototype, "stop");
	__RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(23))(Timer$5.prototype, "stop");
	__RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(15))(Timer$5.prototype, "interval");
	__RΦ$f$5.m("rt:f", "P$")(Timer$5.prototype, "interval");
	__RΦ$f$5.m("rt:f", "M#.")(Timer$5.prototype["tick"]);
	((t, p) => __RΦ$f$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$5.prototype, "tick");
	__RΦ$f$5.m("rt:p", [])(Timer$5.prototype, "tick");
	__RΦ$f$5.m("rt:f", "M#.")(Timer$5.prototype, "tick");
	__RΦ$f$5.m("rt:t", () => __RΦ$f$5.a(23))(Timer$5.prototype, "tick");

	const __RΦ$e$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$e$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$e$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$e$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1722]: { LΦ: t => Object } } };
	var IΦdefault$5$5 = { name: "ICreator", prototype: {}, identity: Symbol("ICreator (interface)") };
	(t => __RΦ$e$5.t[1723] = t)(IΦdefault$5$5);
	__RΦ$e$5.m("rt:P", [])(IΦdefault$5$5);
	__RΦ$e$5.m("rt:m", ["create"])(IΦdefault$5$5);
	__RΦ$e$5.m("rt:f", "Ie")(IΦdefault$5$5);
	__RΦ$e$5.m("rt:p", [])(IΦdefault$5$5.prototype, "create");
	__RΦ$e$5.m("rt:f", "M")(IΦdefault$5$5.prototype, "create");
	__RΦ$e$5.m("rt:t", () => __RΦ$e$5.a(1722))(IΦdefault$5$5.prototype, "create");
	__RΦ$e$5.m("rt:p", [])(IΦdefault$5$5.prototype, "create");
	__RΦ$e$5.m("rt:f", "M")(IΦdefault$5$5.prototype, "create");
	__RΦ$e$5.m("rt:t", () => __RΦ$e$5.a(1722))(IΦdefault$5$5.prototype, "create");

	const __RΦ$d$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$d$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$d$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$d$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1725]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$d$6.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1733]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$d$6.a(10), __RΦ$d$6.a(1727)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1727]: { LΦ: t => Object }, [1730]: { RΦ: t => ({ TΦ: "g", t: __RΦ$d$6.a(1723), p: [__RΦ$d$6.a(1727)] }) }, [1723]: { LΦ: t => IΦdefault$5$5 } } };
	/**
	 * Отложенная инициализация.
	 * @link https://metanit.com/sharp/tutorial/20.1.php
	 * @link https://docs.microsoft.com/ru-ru/dotnet/api/system.lazy-1?view=net-5.0
	 */
	class Lazy$5 {
	    #value;
	    #creator;
	    constructor(createFn) {
	        this.#creator = {
	            create() {
	                return createFn();
	            }
	        };
	    }
	    get value() {
	        if (!this.#value) {
	            this.#value = this.#creator.create();
	        }
	        return this.#value;
	    }
	}
	(t => __RΦ$d$6.t[1726] = t)(Lazy$5);
	__RΦ$d$6.m("rt:SP", [])(Lazy$5);
	__RΦ$d$6.m("rt:P", ["#value", "#creator", "value"])(Lazy$5);
	__RΦ$d$6.m("rt:Sm", [])(Lazy$5);
	__RΦ$d$6.m("rt:m", [])(Lazy$5);
	__RΦ$d$6.m("rt:p", [{ n: "createFn", t: () => __RΦ$d$6.a(1725), v: null }])(Lazy$5);
	__RΦ$d$6.m("rt:f", "Ce")(Lazy$5);
	__RΦ$d$6.m("rt:t", () => __RΦ$d$6.a(1733))(Lazy$5.prototype, "#value");
	__RΦ$d$6.m("rt:f", "P")(Lazy$5.prototype, "#value");
	__RΦ$d$6.m("rt:t", () => __RΦ$d$6.a(1730))(Lazy$5.prototype, "#creator");
	__RΦ$d$6.m("rt:f", "P")(Lazy$5.prototype, "#creator");
	__RΦ$d$6.m("rt:t", () => __RΦ$d$6.a(1727))(Lazy$5.prototype, "value");
	__RΦ$d$6.m("rt:f", "P")(Lazy$5.prototype, "value");

	const __RΦ$c$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$c$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$c$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$c$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [257]: { LΦ: t => Object }, [258]: { LΦ: t => Object } } };
	var IΦdefault$4$5 = { name: "IKeyValueObject", prototype: {}, identity: Symbol("IKeyValueObject (interface)") };
	(t => __RΦ$c$6.t[259] = t)(IΦdefault$4$5);
	__RΦ$c$6.m("rt:P", ["key", "value"])(IΦdefault$4$5);
	__RΦ$c$6.m("rt:m", [])(IΦdefault$4$5);
	__RΦ$c$6.m("rt:f", "Ie")(IΦdefault$4$5);
	__RΦ$c$6.m("rt:t", () => __RΦ$c$6.a(257))(IΦdefault$4$5.prototype, "key");
	__RΦ$c$6.m("rt:f", "P")(IΦdefault$4$5.prototype, "key");
	__RΦ$c$6.m("rt:t", () => __RΦ$c$6.a(258))(IΦdefault$4$5.prototype, "value");
	__RΦ$c$6.m("rt:f", "P")(IΦdefault$4$5.prototype, "value");
	__RΦ$c$6.m("rt:t", () => __RΦ$c$6.a(257))(IΦdefault$4$5.prototype, "key");
	__RΦ$c$6.m("rt:f", "P")(IΦdefault$4$5.prototype, "key");
	__RΦ$c$6.m("rt:t", () => __RΦ$c$6.a(258))(IΦdefault$4$5.prototype, "value");
	__RΦ$c$6.m("rt:f", "P")(IΦdefault$4$5.prototype, "value");

	const __RΦ$b$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$b$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$b$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$b$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1918]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$6.a(262), p: [__RΦ$b$6.a(1916), __RΦ$b$6.a(1917)] }) }, [262]: { LΦ: t => Map }, [1916]: { LΦ: t => Object }, [1917]: { LΦ: t => Object }, [1922]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$6.a(1926) }) }, [1926]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$6.a(259), p: [__RΦ$b$6.a(1916), __RΦ$b$6.a(1925)] }) }, [259]: { LΦ: t => IΦdefault$4$5 }, [1925]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b$6.a(10), __RΦ$b$6.a(1917)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1929]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b$6.a(1930), p: [__RΦ$b$6.a(1927), __RΦ$b$6.a(1928)] }) }, [1930]: { LΦ: t => Object }, [1927]: { LΦ: t => Object }, [1928]: { LΦ: t => Object }, [1934]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$6.a(1936) }) }, [1936]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$6.a(259), p: [__RΦ$b$6.a(1927), __RΦ$b$6.a(1928)] }) }, [1755]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b$6.a(1748), __RΦ$b$6.a(1753)] }) }, [1748]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$6.a(262), p: [__RΦ$b$6.a(1737), __RΦ$b$6.a(1738)] }) }, [1737]: { LΦ: t => Object }, [1738]: { LΦ: t => Object }, [1753]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b$6.a(1754), p: [__RΦ$b$6.a(1737), __RΦ$b$6.a(1738)] }) }, [1754]: { LΦ: t => Object }, [1739]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$6.a(1742) }) }, [1742]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$6.a(259), p: [__RΦ$b$6.a(1737), __RΦ$b$6.a(1738)] }) }, [15]: { LΦ: t => Number } } };
	/**
	 * Конвертация разнообразных значений.
	 */
	class Convert$5 {
	    static toArray(object) {
	        const result = [];
	        if (object instanceof Map) {
	            for (const [key, value] of object) {
	                result.push({ key, value });
	            }
	        }
	        else {
	            for (const key in object) {
	                if (!object.hasOwnProperty(key))
	                    continue;
	                result.push({ key, value: Reflect.get(object, key) });
	            }
	        }
	        return result;
	    }
	    /**
	     * Конвертировать миллисекунды в секунды.
	     * @param millisecond
	     */
	    static toSecond(millisecond) {
	        return millisecond / 1000;
	    }
	}
	(t => __RΦ$b$6.t[1914] = t)(Convert$5);
	__RΦ$b$6.m("rt:SP", [])(Convert$5);
	__RΦ$b$6.m("rt:P", [])(Convert$5);
	__RΦ$b$6.m("rt:Sm", ["toArray", "toArray", "toArray", "toSecond"])(Convert$5);
	__RΦ$b$6.m("rt:m", [])(Convert$5);
	__RΦ$b$6.m("rt:f", "Ce")(Convert$5);
	__RΦ$b$6.m("rt:f", "M$S")(Convert$5["toArray"]);
	((t, p) => __RΦ$b$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$5, "toArray");
	__RΦ$b$6.m("rt:p", [{ n: "object", t: () => __RΦ$b$6.a(1918), v: null }])(Convert$5, "toArray");
	__RΦ$b$6.m("rt:f", "M$S")(Convert$5, "toArray");
	__RΦ$b$6.m("rt:t", () => __RΦ$b$6.a(1922))(Convert$5, "toArray");
	__RΦ$b$6.m("rt:f", "M$S")(Convert$5["toArray"]);
	((t, p) => __RΦ$b$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$5, "toArray");
	__RΦ$b$6.m("rt:p", [{ n: "object", t: () => __RΦ$b$6.a(1929), v: null }])(Convert$5, "toArray");
	__RΦ$b$6.m("rt:f", "M$S")(Convert$5, "toArray");
	__RΦ$b$6.m("rt:t", () => __RΦ$b$6.a(1934))(Convert$5, "toArray");
	__RΦ$b$6.m("rt:f", "M$S")(Convert$5["toArray"]);
	((t, p) => __RΦ$b$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$5, "toArray");
	__RΦ$b$6.m("rt:p", [{ n: "object", t: () => __RΦ$b$6.a(1755), v: null }])(Convert$5, "toArray");
	__RΦ$b$6.m("rt:f", "M$S")(Convert$5, "toArray");
	__RΦ$b$6.m("rt:t", () => __RΦ$b$6.a(1739))(Convert$5, "toArray");
	__RΦ$b$6.m("rt:f", "M$S.")(Convert$5["toSecond"]);
	((t, p) => __RΦ$b$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$5, "toSecond");
	__RΦ$b$6.m("rt:p", [{ n: "millisecond", t: () => __RΦ$b$6.a(15), v: null }])(Convert$5, "toSecond");
	__RΦ$b$6.m("rt:f", "M$S.")(Convert$5, "toSecond");
	__RΦ$b$6.m("rt:t", () => __RΦ$b$6.a(15))(Convert$5, "toSecond");

	const __RΦ$a$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$a$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$a$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$a$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1960]: { LΦ: t => 60 }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [15]: { LΦ: t => Number }, [1956]: { LΦ: t => "update" }, [1962]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$6.a(4) }] }) }, [1938]: { RΦ: t => ({ TΦ: "t" }) }, [1958]: { LΦ: t => "render" }, [1963]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$6.a(4) }] }) }, [249]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$a$6.a(14), __RΦ$a$6.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1940]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$6.a(4) }] }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * http://gs-studio.com/news-about-it/30703----javascript
	 * https://eatdog.com.ua/assets/gamedev-slides/
	 * https://www.youtube.com/watch?v=-gsjAz9jR3Y
	 */
	class GameLoop$5 {
	    framePerSecond;
	    eventEmitter = new EventEmitter$7;
	    time = 0;
	    timeInterval = 0;
	    renderTime = 0;
	    renderTimeInterval = 0;
	    /**
	     * Текущий FPS отрисовки игровой сцены.
	     */
	    get renderFramePerSecond() {
	        return 1 / (this.renderTimeInterval / 1000);
	    }
	    /**
	     * Временной шаг, с которым вызывается функция update для вычисления игровой логики.
	     * Измеряется в миллисекундах.
	     */
	    get step() {
	        return (1 / this.framePerSecond) / 1000;
	    }
	    constructor(
	    /**
	     * Частота обновления игровой логики (генерации события update).
	     * @private
	     */
	    framePerSecond = 60 // TODO Переименовать в updatePerSecond?
	    ) {
	        this.framePerSecond = framePerSecond;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	    start() {
	        this.time = performance.now();
	        this.timeInterval = 0;
	        requestAnimationFrame(this.frame.bind(this));
	    }
	    stop() {
	    }
	    pause() {
	    }
	    frame() {
	        // Обработка логики игры.
	        {
	            const currentTime = performance.now();
	            // Исправление проблемы неактивных вкладок.
	            // Разрешить максимальную задержку между вызовами не более, чем 1 секунда.
	            this.timeInterval = this.timeInterval + Math.min(1000, currentTime - this.time);
	            while (this.timeInterval > this.step) {
	                this.timeInterval = this.timeInterval - this.step;
	                this.eventEmitter.emit('update', this.step);
	            }
	            this.time = currentTime;
	        }
	        // Обработка отрисовки сцены игры.
	        {
	            const renderCurrentTime = performance.now();
	            this.renderTimeInterval = renderCurrentTime - this.renderTime;
	            this.renderTime = renderCurrentTime;
	            this.eventEmitter.emit('render', this.timeInterval);
	        }
	        requestAnimationFrame(this.frame.bind(this));
	    }
	}
	(t => __RΦ$a$6.t[1937] = t)(GameLoop$5);
	__RΦ$a$6.m("rt:SP", [])(GameLoop$5);
	__RΦ$a$6.m("rt:P", ["eventEmitter", "time", "timeInterval", "renderTime", "renderTimeInterval", "renderFramePerSecond", "step", "framePerSecond"])(GameLoop$5);
	__RΦ$a$6.m("rt:Sm", [])(GameLoop$5);
	__RΦ$a$6.m("rt:m", ["on", "on", "on", "start", "stop", "pause", "frame"])(GameLoop$5);
	__RΦ$a$6.m("rt:p", [{ n: "framePerSecond", t: () => __RΦ$a$6.a(1960), v: function () { return 60 // TODO Переименовать в updatePerSecond?
	        ; }, f: "#R" }])(GameLoop$5);
	__RΦ$a$6.m("rt:i", [() => undefined, () => undefined])(GameLoop$5);
	__RΦ$a$6.m("rt:f", "Ce")(GameLoop$5);
	__RΦ$a$6.m("rt:t", () => __RΦ$a$6.a(4))(GameLoop$5.prototype, "eventEmitter");
	__RΦ$a$6.m("rt:f", "P#R")(GameLoop$5.prototype, "eventEmitter");
	__RΦ$a$6.m("rt:t", () => __RΦ$a$6.a(15))(GameLoop$5.prototype, "time");
	__RΦ$a$6.m("rt:f", "P#")(GameLoop$5.prototype, "time");
	__RΦ$a$6.m("rt:t", () => __RΦ$a$6.a(15))(GameLoop$5.prototype, "timeInterval");
	__RΦ$a$6.m("rt:f", "P#")(GameLoop$5.prototype, "timeInterval");
	__RΦ$a$6.m("rt:t", () => __RΦ$a$6.a(15))(GameLoop$5.prototype, "renderTime");
	__RΦ$a$6.m("rt:f", "P#")(GameLoop$5.prototype, "renderTime");
	__RΦ$a$6.m("rt:t", () => __RΦ$a$6.a(15))(GameLoop$5.prototype, "renderTimeInterval");
	__RΦ$a$6.m("rt:f", "P#")(GameLoop$5.prototype, "renderTimeInterval");
	__RΦ$a$6.m("rt:t", () => __RΦ$a$6.a(15))(GameLoop$5.prototype, "renderFramePerSecond");
	__RΦ$a$6.m("rt:f", "P$")(GameLoop$5.prototype, "renderFramePerSecond");
	__RΦ$a$6.m("rt:t", () => __RΦ$a$6.a(15))(GameLoop$5.prototype, "step");
	__RΦ$a$6.m("rt:f", "P$")(GameLoop$5.prototype, "step");
	__RΦ$a$6.m("rt:f", "M")(GameLoop$5.prototype["on"]);
	((t, p) => __RΦ$a$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$5.prototype, "on");
	__RΦ$a$6.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$6.a(1956), v: null }, { n: "update", t: () => __RΦ$a$6.a(1962), v: null }])(GameLoop$5.prototype, "on");
	__RΦ$a$6.m("rt:f", "M")(GameLoop$5.prototype, "on");
	__RΦ$a$6.m("rt:t", () => __RΦ$a$6.a(1938))(GameLoop$5.prototype, "on");
	__RΦ$a$6.m("rt:f", "M")(GameLoop$5.prototype["on"]);
	((t, p) => __RΦ$a$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$5.prototype, "on");
	__RΦ$a$6.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$6.a(1958), v: null }, { n: "render", t: () => __RΦ$a$6.a(1963), v: null }])(GameLoop$5.prototype, "on");
	__RΦ$a$6.m("rt:f", "M")(GameLoop$5.prototype, "on");
	__RΦ$a$6.m("rt:t", () => __RΦ$a$6.a(1938))(GameLoop$5.prototype, "on");
	__RΦ$a$6.m("rt:f", "M")(GameLoop$5.prototype["on"]);
	((t, p) => __RΦ$a$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$5.prototype, "on");
	__RΦ$a$6.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$6.a(249), v: null }, { n: "listener", t: () => __RΦ$a$6.a(1940), v: null }])(GameLoop$5.prototype, "on");
	__RΦ$a$6.m("rt:f", "M")(GameLoop$5.prototype, "on");
	__RΦ$a$6.m("rt:t", () => __RΦ$a$6.a(1938))(GameLoop$5.prototype, "on");
	__RΦ$a$6.m("rt:f", "M$")(GameLoop$5.prototype["start"]);
	((t, p) => __RΦ$a$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$5.prototype, "start");
	__RΦ$a$6.m("rt:p", [])(GameLoop$5.prototype, "start");
	__RΦ$a$6.m("rt:f", "M$")(GameLoop$5.prototype, "start");
	__RΦ$a$6.m("rt:t", () => __RΦ$a$6.a(23))(GameLoop$5.prototype, "start");
	__RΦ$a$6.m("rt:f", "M$")(GameLoop$5.prototype["stop"]);
	((t, p) => __RΦ$a$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$5.prototype, "stop");
	__RΦ$a$6.m("rt:p", [])(GameLoop$5.prototype, "stop");
	__RΦ$a$6.m("rt:f", "M$")(GameLoop$5.prototype, "stop");
	__RΦ$a$6.m("rt:t", () => __RΦ$a$6.a(23))(GameLoop$5.prototype, "stop");
	__RΦ$a$6.m("rt:f", "M$")(GameLoop$5.prototype["pause"]);
	((t, p) => __RΦ$a$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$5.prototype, "pause");
	__RΦ$a$6.m("rt:p", [])(GameLoop$5.prototype, "pause");
	__RΦ$a$6.m("rt:f", "M$")(GameLoop$5.prototype, "pause");
	__RΦ$a$6.m("rt:t", () => __RΦ$a$6.a(23))(GameLoop$5.prototype, "pause");
	__RΦ$a$6.m("rt:f", "M#.")(GameLoop$5.prototype["frame"]);
	((t, p) => __RΦ$a$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$5.prototype, "frame");
	__RΦ$a$6.m("rt:p", [])(GameLoop$5.prototype, "frame");
	__RΦ$a$6.m("rt:f", "M#.")(GameLoop$5.prototype, "frame");
	__RΦ$a$6.m("rt:t", () => __RΦ$a$6.a(23))(GameLoop$5.prototype, "frame");

	const __RΦ$9$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$9$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$9$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$9$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1967]: { RΦ: t => ({ TΦ: "g", t: __RΦ$9$6.a(262), p: [__RΦ$9$6.a(14), __RΦ$9$6.a(21)] }) }, [262]: { LΦ: t => Map }, [14]: { LΦ: t => String }, [21]: { LΦ: t => Boolean }, [1970]: { LΦ: t => KeyboardEvent }, [1977]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$6.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1980]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$6.a(4) }] }) }, [1984]: { LΦ: t => Function }, [1983]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$6.a(4) }] }) }, [1985]: { LΦ: t => Function } } };
	/**
	 * Вместо KeyUpDownProcessor используйте Shortcut.
	 * @deprecated
	 * @link http://khusamov.github.io/tutorial/csharp/key-down-up-process
	 */
	class KeyUpDownProcessor$5 {
	    /**
	     * Данный словарь хранит информацию о том, была ли нажата клавиша.
	     * В качестве ключа выступает номер клавиши,
	     * а значение это флаг (была или не была нажата клавиша).
	     * @private
	     * @link https://learn.javascript.ru/keyboard-events
	     */
	    static #theKeyWasDown = new Map;
	    static onKeyDown(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.#theKeyWasDown.has(keyCode)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.#theKeyWasDown.set(keyCode, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.#theKeyWasDown.get(keyCode)) {
	            // Помечаем что она нажата.
	            this.#theKeyWasDown.set(keyCode, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            action();
	        }
	    }
	    static onKeyUp(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Помечаем что она уже не нажата.
	        this.#theKeyWasDown.set(keyCode, false);
	        // Выполняем действие при отжатии клавиши.
	        action();
	    }
	}
	(t => __RΦ$9$6.t[1965] = t)(KeyUpDownProcessor$5);
	__RΦ$9$6.m("rt:SP", ["#theKeyWasDown"])(KeyUpDownProcessor$5);
	__RΦ$9$6.m("rt:P", [])(KeyUpDownProcessor$5);
	__RΦ$9$6.m("rt:Sm", ["onKeyDown", "onKeyUp"])(KeyUpDownProcessor$5);
	__RΦ$9$6.m("rt:m", [])(KeyUpDownProcessor$5);
	__RΦ$9$6.m("rt:f", "Ce")(KeyUpDownProcessor$5);
	__RΦ$9$6.m("rt:t", () => __RΦ$9$6.a(1967))(KeyUpDownProcessor$5, "#theKeyWasDown");
	__RΦ$9$6.m("rt:f", "P")(KeyUpDownProcessor$5, "#theKeyWasDown");
	__RΦ$9$6.m("rt:f", "M$S.")(KeyUpDownProcessor$5["onKeyDown"]);
	((t, p) => __RΦ$9$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor$5, "onKeyDown");
	__RΦ$9$6.m("rt:p", [{ n: "event", t: () => __RΦ$9$6.a(1970), v: null }, { n: "action", t: () => __RΦ$9$6.a(1977), v: null }])(KeyUpDownProcessor$5, "onKeyDown");
	__RΦ$9$6.m("rt:f", "M$S.")(KeyUpDownProcessor$5, "onKeyDown");
	__RΦ$9$6.m("rt:t", () => __RΦ$9$6.a(23))(KeyUpDownProcessor$5, "onKeyDown");
	__RΦ$9$6.m("rt:f", "M$S.")(KeyUpDownProcessor$5["onKeyUp"]);
	((t, p) => __RΦ$9$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor$5, "onKeyUp");
	__RΦ$9$6.m("rt:p", [{ n: "event", t: () => __RΦ$9$6.a(1970), v: null }, { n: "action", t: () => __RΦ$9$6.a(1977), v: null }])(KeyUpDownProcessor$5, "onKeyUp");
	__RΦ$9$6.m("rt:f", "M$S.")(KeyUpDownProcessor$5, "onKeyUp");
	__RΦ$9$6.m("rt:t", () => __RΦ$9$6.a(23))(KeyUpDownProcessor$5, "onKeyUp");
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyDown$5(listener) {
	    return __RΦ$9$6.f((event) => {
	        KeyUpDownProcessor$5.onKeyDown(event, __RΦ$9$6.f(() => {
	            listener(event);
	        }, [__RΦ$9$6.m("rt:p", []), __RΦ$9$6.m("rt:f", "F>"), __RΦ$9$6.m("rt:t", () => __RΦ$9$6.a(23))], ""));
	    }, [__RΦ$9$6.m("rt:p", [{ n: "event", t: () => __RΦ$9$6.a(1970), v: null }]), __RΦ$9$6.m("rt:f", "F>"), __RΦ$9$6.m("rt:t", () => __RΦ$9$6.a(23))], "");
	}
	__RΦ$9$6.m("rt:p", [{ n: "listener", t: () => __RΦ$9$6.a(1980), v: null }])(onKeyDown$5);
	__RΦ$9$6.m("rt:f", "F")(onKeyDown$5);
	__RΦ$9$6.m("rt:t", () => __RΦ$9$6.a(1984))(onKeyDown$5);
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyUp$5(listener) {
	    return __RΦ$9$6.f((event) => {
	        KeyUpDownProcessor$5.onKeyUp(event, __RΦ$9$6.f(() => {
	            listener(event);
	        }, [__RΦ$9$6.m("rt:p", []), __RΦ$9$6.m("rt:f", "F>"), __RΦ$9$6.m("rt:t", () => __RΦ$9$6.a(23))], ""));
	    }, [__RΦ$9$6.m("rt:p", [{ n: "event", t: () => __RΦ$9$6.a(1970), v: null }]), __RΦ$9$6.m("rt:f", "F>"), __RΦ$9$6.m("rt:t", () => __RΦ$9$6.a(23))], "");
	}
	__RΦ$9$6.m("rt:p", [{ n: "listener", t: () => __RΦ$9$6.a(1983), v: null }])(onKeyUp$5);
	__RΦ$9$6.m("rt:f", "F")(onKeyUp$5);
	__RΦ$9$6.m("rt:t", () => __RΦ$9$6.a(1985))(onKeyUp$5);

	const __RΦ$8$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$8$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$8$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$8$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$3$5 = { name: "IDisposable", prototype: {}, identity: Symbol("IDisposable (interface)") };
	(t => __RΦ$8$6.t[253] = t)(IΦdefault$3$5);
	__RΦ$8$6.m("rt:P", [])(IΦdefault$3$5);
	__RΦ$8$6.m("rt:m", ["dispose"])(IΦdefault$3$5);
	__RΦ$8$6.m("rt:f", "Ie")(IΦdefault$3$5);
	__RΦ$8$6.m("rt:p", [])(IΦdefault$3$5.prototype, "dispose");
	__RΦ$8$6.m("rt:f", "M")(IΦdefault$3$5.prototype, "dispose");
	__RΦ$8$6.m("rt:t", () => __RΦ$8$6.a(23))(IΦdefault$3$5.prototype, "dispose");
	__RΦ$8$6.m("rt:p", [])(IΦdefault$3$5.prototype, "dispose");
	__RΦ$8$6.m("rt:f", "M")(IΦdefault$3$5.prototype, "dispose");
	__RΦ$8$6.m("rt:t", () => __RΦ$8$6.a(23))(IΦdefault$3$5.prototype, "dispose");

	const __RΦ$7$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$7$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$7$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$7$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1986]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$7$6.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) } } };
	var IΦdefault$2$5 = { name: "IKeyboardListeners", prototype: {}, identity: Symbol("IKeyboardListeners (interface)") };
	(t => __RΦ$7$6.t[1987] = t)(IΦdefault$2$5);
	__RΦ$7$6.m("rt:P", ["down", "up"])(IΦdefault$2$5);
	__RΦ$7$6.m("rt:m", [])(IΦdefault$2$5);
	__RΦ$7$6.m("rt:f", "Ie")(IΦdefault$2$5);
	__RΦ$7$6.m("rt:t", () => __RΦ$7$6.a(1986))(IΦdefault$2$5.prototype, "down");
	__RΦ$7$6.m("rt:f", "P")(IΦdefault$2$5.prototype, "down");
	__RΦ$7$6.m("rt:t", () => __RΦ$7$6.a(1986))(IΦdefault$2$5.prototype, "up");
	__RΦ$7$6.m("rt:f", "P")(IΦdefault$2$5.prototype, "up");
	__RΦ$7$6.m("rt:t", () => __RΦ$7$6.a(1986))(IΦdefault$2$5.prototype, "down");
	__RΦ$7$6.m("rt:f", "P")(IΦdefault$2$5.prototype, "down");
	__RΦ$7$6.m("rt:t", () => __RΦ$7$6.a(1986))(IΦdefault$2$5.prototype, "up");
	__RΦ$7$6.m("rt:f", "P")(IΦdefault$2$5.prototype, "up");

	const __RΦ$6$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$6$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$6$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$6$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [828]: { LΦ: t => Object }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1988]: { TΦ: "5", name: "default" }, [2241]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$6.a(262), p: [__RΦ$6$6.a(14), __RΦ$6$6.a(1987)] }) }, [262]: { LΦ: t => Map }, [1987]: { LΦ: t => IΦdefault$2$5 }, [1986]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$6$6.a(4) }] }) }, [1967]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$6.a(262), p: [__RΦ$6$6.a(14), __RΦ$6$6.a(21)] }) }, [21]: { LΦ: t => Boolean }, [253]: { LΦ: t => IΦdefault$3$5 }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1970]: { LΦ: t => KeyboardEvent } } };
	const codeOf$5 = __RΦ$6$6.f((key) => 'Key' + key.toUpperCase(), [__RΦ$6$6.m("rt:p", [{ n: "key", t: () => __RΦ$6$6.a(14), v: null }]), __RΦ$6$6.m("rt:f", "F>"), __RΦ$6$6.m("rt:t", () => __RΦ$6$6.a(14))], "codeOf");
	class ShortcutDispatcher$5 {
	    static instanceHolder = new Lazy$5(() => new ShortcutDispatcher$5);
	    static get instance() {
	        return this.instanceHolder.value;
	    }
	    host;
	    listeners = new Map;
	    keyDownListenerBinded;
	    keyUpListenerBinded;
	    theKeyWasDown = new Map;
	    constructor(host = document) {
	        this.host = host;
	        this.keyDownListenerBinded = this.keyDownListener.bind(this);
	        this.keyUpListenerBinded = this.keyUpListener.bind(this);
	        this.host.addEventListener('keydown', this.keyDownListenerBinded);
	        this.host.addEventListener('keyup', this.keyUpListenerBinded);
	    }
	    register(key, listeners) {
	        this.listeners.set(key, listeners);
	        return {
	            dispose: __RΦ$6$6.f(() => {
	                this.listeners.delete(key);
	                this.theKeyWasDown.delete(codeOf$5(key));
	            }, [__RΦ$6$6.m("rt:p", []), __RΦ$6$6.m("rt:f", "F>"), __RΦ$6$6.m("rt:t", () => __RΦ$6$6.a(23))], "dispose")
	        };
	    }
	    keyDownListener(event) {
	        const code = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.theKeyWasDown.has(code)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.theKeyWasDown.set(code, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.theKeyWasDown.get(code)) {
	            // Помечаем что она нажата.
	            this.theKeyWasDown.set(code, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            for (const [key, listeners] of this.listeners.entries()) {
	                if (code === codeOf$5(key)) {
	                    listeners.down(event);
	                }
	            }
	        }
	    }
	    keyUpListener(event) {
	        // Из события извлекаем номер нажатой клавиши.
	        const code = event.code;
	        // Помечаем что она уже не нажата.
	        this.theKeyWasDown.set(code, false);
	        // Выполняем действие при отжатии клавиши.
	        for (const [key, listeners] of this.listeners.entries()) {
	            if (code === codeOf$5(key)) {
	                listeners.up(event);
	            }
	        }
	    }
	    dispose() {
	        this.host.removeEventListener('keydown', this.keyDownListenerBinded);
	        this.host.removeEventListener('keyup', this.keyUpListenerBinded);
	    }
	}
	(t => __RΦ$6$6.t[1988] = t)(ShortcutDispatcher$5);
	__RΦ$6$6.m("rt:SP", ["instanceHolder", "instance"])(ShortcutDispatcher$5);
	__RΦ$6$6.m("rt:P", ["host", "listeners", "keyDownListenerBinded", "keyUpListenerBinded", "theKeyWasDown"])(ShortcutDispatcher$5);
	__RΦ$6$6.m("rt:Sm", [])(ShortcutDispatcher$5);
	__RΦ$6$6.m("rt:m", ["register", "keyDownListener", "keyUpListener", "dispose"])(ShortcutDispatcher$5);
	__RΦ$6$6.m("rt:p", [{ n: "host", t: () => __RΦ$6$6.a(828), v: function () { return document; } }])(ShortcutDispatcher$5);
	__RΦ$6$6.m("rt:i", [() => undefined])(ShortcutDispatcher$5);
	__RΦ$6$6.m("rt:f", "Ce")(ShortcutDispatcher$5);
	__RΦ$6$6.m("rt:t", () => __RΦ$6$6.a(4))(ShortcutDispatcher$5, "instanceHolder");
	__RΦ$6$6.m("rt:f", "P#R")(ShortcutDispatcher$5, "instanceHolder");
	__RΦ$6$6.m("rt:t", () => __RΦ$6$6.a(1988))(ShortcutDispatcher$5, "instance");
	__RΦ$6$6.m("rt:f", "P$")(ShortcutDispatcher$5, "instance");
	__RΦ$6$6.m("rt:t", () => __RΦ$6$6.a(828))(ShortcutDispatcher$5.prototype, "host");
	__RΦ$6$6.m("rt:f", "P#R")(ShortcutDispatcher$5.prototype, "host");
	__RΦ$6$6.m("rt:t", () => __RΦ$6$6.a(2241))(ShortcutDispatcher$5.prototype, "listeners");
	__RΦ$6$6.m("rt:f", "P#R")(ShortcutDispatcher$5.prototype, "listeners");
	__RΦ$6$6.m("rt:t", () => __RΦ$6$6.a(1986))(ShortcutDispatcher$5.prototype, "keyDownListenerBinded");
	__RΦ$6$6.m("rt:f", "P#R")(ShortcutDispatcher$5.prototype, "keyDownListenerBinded");
	__RΦ$6$6.m("rt:t", () => __RΦ$6$6.a(1986))(ShortcutDispatcher$5.prototype, "keyUpListenerBinded");
	__RΦ$6$6.m("rt:f", "P#R")(ShortcutDispatcher$5.prototype, "keyUpListenerBinded");
	__RΦ$6$6.m("rt:t", () => __RΦ$6$6.a(1967))(ShortcutDispatcher$5.prototype, "theKeyWasDown");
	__RΦ$6$6.m("rt:f", "P#R")(ShortcutDispatcher$5.prototype, "theKeyWasDown");
	__RΦ$6$6.m("rt:f", "M$")(ShortcutDispatcher$5.prototype["register"]);
	((t, p) => __RΦ$6$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$5.prototype, "register");
	__RΦ$6$6.m("rt:p", [{ n: "key", t: () => __RΦ$6$6.a(14), v: null }, { n: "listeners", t: () => __RΦ$6$6.a(1987), v: null }])(ShortcutDispatcher$5.prototype, "register");
	__RΦ$6$6.m("rt:f", "M$")(ShortcutDispatcher$5.prototype, "register");
	__RΦ$6$6.m("rt:t", () => __RΦ$6$6.a(253))(ShortcutDispatcher$5.prototype, "register");
	__RΦ$6$6.m("rt:f", "M#.")(ShortcutDispatcher$5.prototype["keyDownListener"]);
	((t, p) => __RΦ$6$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$5.prototype, "keyDownListener");
	__RΦ$6$6.m("rt:p", [{ n: "event", t: () => __RΦ$6$6.a(1970), v: null }])(ShortcutDispatcher$5.prototype, "keyDownListener");
	__RΦ$6$6.m("rt:f", "M#.")(ShortcutDispatcher$5.prototype, "keyDownListener");
	__RΦ$6$6.m("rt:t", () => __RΦ$6$6.a(23))(ShortcutDispatcher$5.prototype, "keyDownListener");
	__RΦ$6$6.m("rt:f", "M#.")(ShortcutDispatcher$5.prototype["keyUpListener"]);
	((t, p) => __RΦ$6$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$5.prototype, "keyUpListener");
	__RΦ$6$6.m("rt:p", [{ n: "event", t: () => __RΦ$6$6.a(1970), v: null }])(ShortcutDispatcher$5.prototype, "keyUpListener");
	__RΦ$6$6.m("rt:f", "M#.")(ShortcutDispatcher$5.prototype, "keyUpListener");
	__RΦ$6$6.m("rt:t", () => __RΦ$6$6.a(23))(ShortcutDispatcher$5.prototype, "keyUpListener");
	__RΦ$6$6.m("rt:f", "M$.")(ShortcutDispatcher$5.prototype["dispose"]);
	((t, p) => __RΦ$6$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$5.prototype, "dispose");
	__RΦ$6$6.m("rt:p", [])(ShortcutDispatcher$5.prototype, "dispose");
	__RΦ$6$6.m("rt:f", "M$.")(ShortcutDispatcher$5.prototype, "dispose");
	__RΦ$6$6.m("rt:t", () => __RΦ$6$6.a(23))(ShortcutDispatcher$5.prototype, "dispose");

	const __RΦ$5$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$5$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$5$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$5$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [1987]: { LΦ: t => IΦdefault$2$5 }, [253]: { LΦ: t => IΦdefault$3$5 } } };
	class Shortcut$5 {
	    static register(key, listeners) {
	        return ShortcutDispatcher$5.instance.register(key, listeners);
	    }
	}
	(t => __RΦ$5$6.t[2270] = t)(Shortcut$5);
	__RΦ$5$6.m("rt:SP", [])(Shortcut$5);
	__RΦ$5$6.m("rt:P", [])(Shortcut$5);
	__RΦ$5$6.m("rt:Sm", ["register"])(Shortcut$5);
	__RΦ$5$6.m("rt:m", [])(Shortcut$5);
	__RΦ$5$6.m("rt:f", "Ce")(Shortcut$5);
	__RΦ$5$6.m("rt:f", "M$S")(Shortcut$5["register"]);
	((t, p) => __RΦ$5$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Shortcut$5, "register");
	__RΦ$5$6.m("rt:p", [{ n: "key", t: () => __RΦ$5$6.a(14), v: null }, { n: "listeners", t: () => __RΦ$5$6.a(1987), v: null }])(Shortcut$5, "register");
	__RΦ$5$6.m("rt:f", "M$S")(Shortcut$5, "register");
	__RΦ$5$6.m("rt:t", () => __RΦ$5$6.a(253))(Shortcut$5, "register");

	const __RΦ$4$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$4$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$4$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$4$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [272]: { RΦ: t => ({ TΦ: "[", e: __RΦ$4$6.a(271) }) }, [271]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [274]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$4$6.a(10), __RΦ$4$6.a(273)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [273]: { LΦ: t => Object }, [283]: { RΦ: t => ({ TΦ: "g", t: __RΦ$4$6.a(77), p: [__RΦ$4$6.a(273)] }) }, [77]: { LΦ: t => Object } } };
	var IΦdefault$1$5 = { name: "IQueue", prototype: {}, identity: Symbol("IQueue (interface)") };
	(t => __RΦ$4$6.t[284] = t)(IΦdefault$1$5);
	__RΦ$4$6.m("rt:P", ["items"])(IΦdefault$1$5);
	__RΦ$4$6.m("rt:m", ["enqueue", "dequeue"])(IΦdefault$1$5);
	__RΦ$4$6.m("rt:f", "Ie")(IΦdefault$1$5);
	__RΦ$4$6.m("rt:p", [{ n: "items", t: () => __RΦ$4$6.a(272), v: null }])(IΦdefault$1$5.prototype, "enqueue");
	__RΦ$4$6.m("rt:f", "M")(IΦdefault$1$5.prototype, "enqueue");
	__RΦ$4$6.m("rt:t", () => __RΦ$4$6.a(23))(IΦdefault$1$5.prototype, "enqueue");
	__RΦ$4$6.m("rt:p", [])(IΦdefault$1$5.prototype, "dequeue");
	__RΦ$4$6.m("rt:f", "M")(IΦdefault$1$5.prototype, "dequeue");
	__RΦ$4$6.m("rt:t", () => __RΦ$4$6.a(274))(IΦdefault$1$5.prototype, "dequeue");
	__RΦ$4$6.m("rt:t", () => __RΦ$4$6.a(283))(IΦdefault$1$5.prototype, "items");
	__RΦ$4$6.m("rt:f", "PR")(IΦdefault$1$5.prototype, "items");
	__RΦ$4$6.m("rt:p", [{ n: "items", t: () => __RΦ$4$6.a(272), v: null }])(IΦdefault$1$5.prototype, "enqueue");
	__RΦ$4$6.m("rt:f", "M")(IΦdefault$1$5.prototype, "enqueue");
	__RΦ$4$6.m("rt:t", () => __RΦ$4$6.a(23))(IΦdefault$1$5.prototype, "enqueue");
	__RΦ$4$6.m("rt:p", [])(IΦdefault$1$5.prototype, "dequeue");
	__RΦ$4$6.m("rt:f", "M")(IΦdefault$1$5.prototype, "dequeue");
	__RΦ$4$6.m("rt:t", () => __RΦ$4$6.a(274))(IΦdefault$1$5.prototype, "dequeue");
	__RΦ$4$6.m("rt:t", () => __RΦ$4$6.a(283))(IΦdefault$1$5.prototype, "items");
	__RΦ$4$6.m("rt:f", "PR")(IΦdefault$1$5.prototype, "items");

	const __RΦ$3$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$3$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$3$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$3$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [291]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$6.a(288) }) }, [288]: { LΦ: t => Object }, [296]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$6.a(286) }) }, [286]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [303]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$3$6.a(10), __RΦ$3$6.a(288)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [304]: { RΦ: t => ({ TΦ: "g", t: __RΦ$3$6.a(77), p: [__RΦ$3$6.a(288)] }) }, [77]: { LΦ: t => Object } } };
	/**
	 * О́чередь — абстрактный тип данных с дисциплиной доступа к элементам «первый пришёл — первый вышел»
	 * (FIFO, англ. first in, first out).
	 *
	 * Добавление элемента (принято обозначать словом enqueue — поставить в очередь) возможно лишь
	 * в конец очереди, выборка — только из начала очереди (что принято называть словом dequeue — убрать из очереди),
	 * при этом выбранный элемент из очереди удаляется.
	 *
	 * @link https://bit.ly/3tPM13G
	 */
	class Queue$5 {
	    storage = [];
	    enqueue(...items) {
	        this.storage.push(...items);
	    }
	    dequeue() {
	        return this.storage.shift();
	    }
	    get items() {
	        return this.storage;
	    }
	}
	(t => __RΦ$3$6.t[287] = t)(Queue$5);
	__RΦ$3$6.m("rt:SP", [])(Queue$5);
	__RΦ$3$6.m("rt:P", ["storage", "items"])(Queue$5);
	__RΦ$3$6.m("rt:Sm", [])(Queue$5);
	__RΦ$3$6.m("rt:m", ["enqueue", "dequeue"])(Queue$5);
	__RΦ$3$6.m("rt:i", [() => undefined])(Queue$5);
	__RΦ$3$6.m("rt:f", "Ce")(Queue$5);
	__RΦ$3$6.m("rt:t", () => __RΦ$3$6.a(291))(Queue$5.prototype, "storage");
	__RΦ$3$6.m("rt:f", "P#")(Queue$5.prototype, "storage");
	__RΦ$3$6.m("rt:f", "M$")(Queue$5.prototype["enqueue"]);
	((t, p) => __RΦ$3$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue$5.prototype, "enqueue");
	__RΦ$3$6.m("rt:p", [{ n: "items", t: () => __RΦ$3$6.a(296), v: null }])(Queue$5.prototype, "enqueue");
	__RΦ$3$6.m("rt:f", "M$")(Queue$5.prototype, "enqueue");
	__RΦ$3$6.m("rt:t", () => __RΦ$3$6.a(23))(Queue$5.prototype, "enqueue");
	__RΦ$3$6.m("rt:f", "M$")(Queue$5.prototype["dequeue"]);
	((t, p) => __RΦ$3$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue$5.prototype, "dequeue");
	__RΦ$3$6.m("rt:p", [])(Queue$5.prototype, "dequeue");
	__RΦ$3$6.m("rt:f", "M$")(Queue$5.prototype, "dequeue");
	__RΦ$3$6.m("rt:t", () => __RΦ$3$6.a(303))(Queue$5.prototype, "dequeue");
	__RΦ$3$6.m("rt:t", () => __RΦ$3$6.a(304))(Queue$5.prototype, "items");
	__RΦ$3$6.m("rt:f", "P$")(Queue$5.prototype, "items");

	const __RΦ$2$7 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$2$7.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$2$7.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$2$7.t[id] = t = l;
	        }
	        return t;
	    }, t: { [482]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$7.a(479) }) }, [479]: { LΦ: t => Object }, [349]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$7.a(284), p: [__RΦ$2$7.a(306)] }) }, [284]: { LΦ: t => IΦdefault$1$5 }, [306]: { LΦ: t => Object }, [481]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$7.a(478), p: [__RΦ$2$7.a(306)] }) }, [478]: { TΦ: "5", name: "ILog" }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [697]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$7.a(284), p: [__RΦ$2$7.a(696)] }) }, [696]: { LΦ: t => Object }, [699]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$2$7.a(697) }, { t: __RΦ$2$7.a(698) }] }) }, [698]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$7.a(305), p: [__RΦ$2$7.a(696)] }) }, [305]: { TΦ: "5", name: "default" }, [249]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$7.a(14), __RΦ$2$7.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [472]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [700]: { LΦ: t => Function }, [483]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$7.a(306) }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [477]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [701]: { LΦ: t => Function }, [503]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$7.a(10), __RΦ$2$7.a(306)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	var IΦILog$5 = { name: "ILog", prototype: {}, identity: Symbol("ILog (interface)") };
	(t => __RΦ$2$7.t[478] = t)(IΦILog$5);
	__RΦ$2$7.m("rt:P", ["enqueue", "dequeue"])(IΦILog$5);
	__RΦ$2$7.m("rt:m", [])(IΦILog$5);
	__RΦ$2$7.m("rt:f", "I")(IΦILog$5);
	__RΦ$2$7.m("rt:t", () => __RΦ$2$7.a(482))(IΦILog$5.prototype, "enqueue");
	__RΦ$2$7.m("rt:f", "P")(IΦILog$5.prototype, "enqueue");
	__RΦ$2$7.m("rt:t", () => __RΦ$2$7.a(482))(IΦILog$5.prototype, "dequeue");
	__RΦ$2$7.m("rt:f", "P")(IΦILog$5.prototype, "dequeue");
	__RΦ$2$7.m("rt:t", () => __RΦ$2$7.a(482))(IΦILog$5.prototype, "enqueue");
	__RΦ$2$7.m("rt:f", "P")(IΦILog$5.prototype, "enqueue");
	__RΦ$2$7.m("rt:t", () => __RΦ$2$7.a(482))(IΦILog$5.prototype, "dequeue");
	__RΦ$2$7.m("rt:f", "P")(IΦILog$5.prototype, "dequeue");
	class QueueLog$5 {
	    queue;
	    queueProxy;
	    log = {
	        enqueue: [],
	        dequeue: []
	    };
	    get sourceQueue() {
	        return this.queue;
	    }
	    get loggedQueue() {
	        return this.queueProxy;
	    }
	    static create(queue) {
	        const queueLog = new QueueLog$5(queue);
	        return [queueLog.loggedQueue, queueLog];
	    }
	    constructor(queue) {
	        this.queue = queue;
	        this.queueProxy = (new Proxy(queue, {
	            get: this.proxyHandlerGet.bind(this)
	        }));
	    }
	    proxyHandlerGet(target, property, receiver) {
	        const origin = Reflect.get(target, property, receiver);
	        switch (property) {
	            case 'enqueue': return this.createEnqueue(target, origin);
	            case 'dequeue': return this.createDequeue(target, origin);
	            default: return origin;
	        }
	    }
	    createEnqueue(target, origin) {
	        return (__RΦ$2$7.f((...items) => {
	            this.log.enqueue.push(...items);
	            origin.call(target, ...items);
	        }, [__RΦ$2$7.m("rt:p", [{ n: "items", t: () => __RΦ$2$7.a(483), v: null }]), __RΦ$2$7.m("rt:f", "F>"), __RΦ$2$7.m("rt:t", () => __RΦ$2$7.a(23))], ""));
	    }
	    createDequeue(target, origin) {
	        return (__RΦ$2$7.f(() => {
	            const item = origin.call(target);
	            if (item) {
	                this.log.dequeue.push(item);
	            }
	            return item;
	        }, [__RΦ$2$7.m("rt:p", []), __RΦ$2$7.m("rt:f", "F>"), __RΦ$2$7.m("rt:t", () => __RΦ$2$7.a(503))], ""));
	    }
	}
	(t => __RΦ$2$7.t[305] = t)(QueueLog$5);
	__RΦ$2$7.m("rt:SP", [])(QueueLog$5);
	__RΦ$2$7.m("rt:P", ["queueProxy", "log", "sourceQueue", "loggedQueue", "queue"])(QueueLog$5);
	__RΦ$2$7.m("rt:Sm", ["create"])(QueueLog$5);
	__RΦ$2$7.m("rt:m", ["proxyHandlerGet", "createEnqueue", "createDequeue"])(QueueLog$5);
	__RΦ$2$7.m("rt:p", [{ n: "queue", t: () => __RΦ$2$7.a(349), v: null, f: "#" }])(QueueLog$5);
	__RΦ$2$7.m("rt:f", "Ce")(QueueLog$5);
	__RΦ$2$7.m("rt:t", () => __RΦ$2$7.a(349))(QueueLog$5.prototype, "queueProxy");
	__RΦ$2$7.m("rt:f", "P#R")(QueueLog$5.prototype, "queueProxy");
	__RΦ$2$7.m("rt:t", () => __RΦ$2$7.a(481))(QueueLog$5.prototype, "log");
	__RΦ$2$7.m("rt:f", "P#")(QueueLog$5.prototype, "log");
	__RΦ$2$7.m("rt:t", () => __RΦ$2$7.a(4))(QueueLog$5.prototype, "sourceQueue");
	__RΦ$2$7.m("rt:f", "P$")(QueueLog$5.prototype, "sourceQueue");
	__RΦ$2$7.m("rt:t", () => __RΦ$2$7.a(4))(QueueLog$5.prototype, "loggedQueue");
	__RΦ$2$7.m("rt:f", "P$")(QueueLog$5.prototype, "loggedQueue");
	__RΦ$2$7.m("rt:f", "M$S")(QueueLog$5["create"]);
	((t, p) => __RΦ$2$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$5, "create");
	__RΦ$2$7.m("rt:p", [{ n: "queue", t: () => __RΦ$2$7.a(697), v: null }])(QueueLog$5, "create");
	__RΦ$2$7.m("rt:f", "M$S")(QueueLog$5, "create");
	__RΦ$2$7.m("rt:t", () => __RΦ$2$7.a(699))(QueueLog$5, "create");
	__RΦ$2$7.m("rt:f", "M#")(QueueLog$5.prototype["proxyHandlerGet"]);
	((t, p) => __RΦ$2$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$5.prototype, "proxyHandlerGet");
	__RΦ$2$7.m("rt:p", [{ n: "target", t: () => __RΦ$2$7.a(349), v: null }, { n: "property", t: () => __RΦ$2$7.a(249), v: null }, { n: "receiver", t: () => __RΦ$2$7.a(1), v: null }])(QueueLog$5.prototype, "proxyHandlerGet");
	__RΦ$2$7.m("rt:f", "M#")(QueueLog$5.prototype, "proxyHandlerGet");
	__RΦ$2$7.m("rt:t", () => __RΦ$2$7.a(1))(QueueLog$5.prototype, "proxyHandlerGet");
	__RΦ$2$7.m("rt:f", "M#.")(QueueLog$5.prototype["createEnqueue"]);
	((t, p) => __RΦ$2$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$5.prototype, "createEnqueue");
	__RΦ$2$7.m("rt:p", [{ n: "target", t: () => __RΦ$2$7.a(349), v: null }, { n: "origin", t: () => __RΦ$2$7.a(472), v: null }])(QueueLog$5.prototype, "createEnqueue");
	__RΦ$2$7.m("rt:f", "M#.")(QueueLog$5.prototype, "createEnqueue");
	__RΦ$2$7.m("rt:t", () => __RΦ$2$7.a(700))(QueueLog$5.prototype, "createEnqueue");
	__RΦ$2$7.m("rt:f", "M#.")(QueueLog$5.prototype["createDequeue"]);
	((t, p) => __RΦ$2$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$5.prototype, "createDequeue");
	__RΦ$2$7.m("rt:p", [{ n: "target", t: () => __RΦ$2$7.a(349), v: null }, { n: "origin", t: () => __RΦ$2$7.a(477), v: null }])(QueueLog$5.prototype, "createDequeue");
	__RΦ$2$7.m("rt:f", "M#.")(QueueLog$5.prototype, "createDequeue");
	__RΦ$2$7.m("rt:t", () => __RΦ$2$7.a(701))(QueueLog$5.prototype, "createDequeue");

	const __RΦ$1$7 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$1$7.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$1$7.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$1$7.t[id] = t = l;
	        }
	        return t;
	    }, t: { [249]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$1$7.a(14), __RΦ$1$7.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [250]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$1$7.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [252]: { RΦ: t => ({ TΦ: "t" }) } } };
	var IΦdefault$m = { name: "IEventEmitter", prototype: {}, identity: Symbol("IEventEmitter (interface)") };
	(t => __RΦ$1$7.t[251] = t)(IΦdefault$m);
	__RΦ$1$7.m("rt:P", [])(IΦdefault$m);
	__RΦ$1$7.m("rt:m", ["on"])(IΦdefault$m);
	__RΦ$1$7.m("rt:f", "Ie")(IΦdefault$m);
	__RΦ$1$7.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$7.a(249), v: null }, { n: "listener", t: () => __RΦ$1$7.a(250), v: null }])(IΦdefault$m.prototype, "on");
	__RΦ$1$7.m("rt:f", "M")(IΦdefault$m.prototype, "on");
	__RΦ$1$7.m("rt:t", () => __RΦ$1$7.a(252))(IΦdefault$m.prototype, "on");
	__RΦ$1$7.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$7.a(249), v: null }, { n: "listener", t: () => __RΦ$1$7.a(250), v: null }])(IΦdefault$m.prototype, "on");
	__RΦ$1$7.m("rt:f", "M")(IΦdefault$m.prototype, "on");
	__RΦ$1$7.m("rt:t", () => __RΦ$1$7.a(252))(IΦdefault$m.prototype, "on");

	const __RΦ$O = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$O.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$O.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$O.t[id] = t = l;
	        }
	        return t;
	    }, t: { [4]: { RΦ: t => ({ TΦ: "~" }) }, [712]: { RΦ: t => ({ TΦ: "[", e: __RΦ$O.a(702) }) }, [702]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [729]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$O.a(10), __RΦ$O.a(704)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [704]: { LΦ: t => Object }, [249]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$O.a(14), __RΦ$O.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [733]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$O.a(4) }] }) }, [705]: { RΦ: t => ({ TΦ: "t" }) } } };
	class QueueWithEventEmitter$5 extends Queue$5 {
	    eventEmitter = new EventEmitter$7;
	    enqueue(...items) {
	        this.eventEmitter.emit('before-enqueue', this, ...items);
	        super.enqueue(...items);
	        this.eventEmitter.emit('enqueue', this, ...items);
	    }
	    dequeue() {
	        const removed = super.dequeue();
	        this.eventEmitter.emit('dequeue', this, removed);
	        return removed;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	}
	(t => __RΦ$O.t[703] = t)(QueueWithEventEmitter$5);
	__RΦ$O.m("rt:SP", [])(QueueWithEventEmitter$5);
	__RΦ$O.m("rt:P", ["eventEmitter"])(QueueWithEventEmitter$5);
	__RΦ$O.m("rt:Sm", [])(QueueWithEventEmitter$5);
	__RΦ$O.m("rt:m", ["enqueue", "dequeue", "on"])(QueueWithEventEmitter$5);
	__RΦ$O.m("rt:i", [() => undefined])(QueueWithEventEmitter$5);
	__RΦ$O.m("rt:f", "Ce")(QueueWithEventEmitter$5);
	__RΦ$O.m("rt:t", () => __RΦ$O.a(4))(QueueWithEventEmitter$5.prototype, "eventEmitter");
	__RΦ$O.m("rt:f", "P#")(QueueWithEventEmitter$5.prototype, "eventEmitter");
	__RΦ$O.m("rt:f", "M$")(QueueWithEventEmitter$5.prototype["enqueue"]);
	((t, p) => __RΦ$O.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$5.prototype, "enqueue");
	__RΦ$O.m("rt:p", [{ n: "items", t: () => __RΦ$O.a(712), v: null }])(QueueWithEventEmitter$5.prototype, "enqueue");
	__RΦ$O.m("rt:f", "M$")(QueueWithEventEmitter$5.prototype, "enqueue");
	__RΦ$O.m("rt:t", () => __RΦ$O.a(23))(QueueWithEventEmitter$5.prototype, "enqueue");
	__RΦ$O.m("rt:f", "M$")(QueueWithEventEmitter$5.prototype["dequeue"]);
	((t, p) => __RΦ$O.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$5.prototype, "dequeue");
	__RΦ$O.m("rt:p", [])(QueueWithEventEmitter$5.prototype, "dequeue");
	__RΦ$O.m("rt:f", "M$")(QueueWithEventEmitter$5.prototype, "dequeue");
	__RΦ$O.m("rt:t", () => __RΦ$O.a(729))(QueueWithEventEmitter$5.prototype, "dequeue");
	__RΦ$O.m("rt:f", "M$")(QueueWithEventEmitter$5.prototype["on"]);
	((t, p) => __RΦ$O.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$5.prototype, "on");
	__RΦ$O.m("rt:p", [{ n: "eventName", t: () => __RΦ$O.a(249), v: null }, { n: "listener", t: () => __RΦ$O.a(733), v: null }])(QueueWithEventEmitter$5.prototype, "on");
	__RΦ$O.m("rt:f", "M$")(QueueWithEventEmitter$5.prototype, "on");
	__RΦ$O.m("rt:t", () => __RΦ$O.a(705))(QueueWithEventEmitter$5.prototype, "on");

	var index_es = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Angle: Angle$5,
		Convert: Convert$5,
		GameLoop: GameLoop$5,
		KeyUpDownProcessor: KeyUpDownProcessor$5,
		Lazy: Lazy$5,
		Queue: Queue$5,
		QueueLog: QueueLog$5,
		QueueWithEventEmitter: QueueWithEventEmitter$5,
		Shortcut: Shortcut$5,
		ShortcutDispatcher: ShortcutDispatcher$5,
		Timer: Timer$5,
		Transform: Transform$2,
		Vector: Vector$5,
		execActionScript: execActionScript$5,
		execFunctionScript: execFunctionScript$5,
		isBrowser: isBrowser$5,
		isStoppable: isStoppable$5,
		onKeyDown: onKeyDown$5,
		onKeyUp: onKeyUp$5,
		toOneLine: toOneLine$5,
		useRequestAnimationFrame: useRequestAnimationFrame$1
	});

	var dist$5 = {};

	var events$3 = {exports: {}};

	var R$3 = typeof Reflect === 'object' ? Reflect : null;
	var ReflectApply$3 = R$3 && typeof R$3.apply === 'function'
	  ? R$3.apply
	  : function ReflectApply(target, receiver, args) {
	    return Function.prototype.apply.call(target, receiver, args);
	  };

	var ReflectOwnKeys$3;
	if (R$3 && typeof R$3.ownKeys === 'function') {
	  ReflectOwnKeys$3 = R$3.ownKeys;
	} else if (Object.getOwnPropertySymbols) {
	  ReflectOwnKeys$3 = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target)
	      .concat(Object.getOwnPropertySymbols(target));
	  };
	} else {
	  ReflectOwnKeys$3 = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target);
	  };
	}

	function ProcessEmitWarning$3(warning) {
	  if (console && console.warn) console.warn(warning);
	}

	var NumberIsNaN$3 = Number.isNaN || function NumberIsNaN(value) {
	  return value !== value;
	};

	function EventEmitter$1$3() {
	  EventEmitter$1$3.init.call(this);
	}
	events$3.exports = EventEmitter$1$3;
	events$3.exports.once = once$3;

	// Backwards-compat with node 0.10.x
	EventEmitter$1$3.EventEmitter = EventEmitter$1$3;

	EventEmitter$1$3.prototype._events = undefined;
	EventEmitter$1$3.prototype._eventsCount = 0;
	EventEmitter$1$3.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	var defaultMaxListeners$3 = 10;

	function checkListener$3(listener) {
	  if (typeof listener !== 'function') {
	    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
	  }
	}

	Object.defineProperty(EventEmitter$1$3, 'defaultMaxListeners', {
	  enumerable: true,
	  get: function() {
	    return defaultMaxListeners$3;
	  },
	  set: function(arg) {
	    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN$3(arg)) {
	      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
	    }
	    defaultMaxListeners$3 = arg;
	  }
	});

	EventEmitter$1$3.init = function() {

	  if (this._events === undefined ||
	      this._events === Object.getPrototypeOf(this)._events) {
	    this._events = Object.create(null);
	    this._eventsCount = 0;
	  }

	  this._maxListeners = this._maxListeners || undefined;
	};

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter$1$3.prototype.setMaxListeners = function setMaxListeners(n) {
	  if (typeof n !== 'number' || n < 0 || NumberIsNaN$3(n)) {
	    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
	  }
	  this._maxListeners = n;
	  return this;
	};

	function _getMaxListeners$3(that) {
	  if (that._maxListeners === undefined)
	    return EventEmitter$1$3.defaultMaxListeners;
	  return that._maxListeners;
	}

	EventEmitter$1$3.prototype.getMaxListeners = function getMaxListeners() {
	  return _getMaxListeners$3(this);
	};

	EventEmitter$1$3.prototype.emit = function emit(type) {
	  var args = [];
	  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
	  var doError = (type === 'error');

	  var events = this._events;
	  if (events !== undefined)
	    doError = (doError && events.error === undefined);
	  else if (!doError)
	    return false;

	  // If there is no 'error' event listener then throw.
	  if (doError) {
	    var er;
	    if (args.length > 0)
	      er = args[0];
	    if (er instanceof Error) {
	      // Note: The comments on the `throw` lines are intentional, they show
	      // up in Node's output if this results in an unhandled exception.
	      throw er; // Unhandled 'error' event
	    }
	    // At least give some kind of context to the user
	    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
	    err.context = er;
	    throw err; // Unhandled 'error' event
	  }

	  var handler = events[type];

	  if (handler === undefined)
	    return false;

	  if (typeof handler === 'function') {
	    ReflectApply$3(handler, this, args);
	  } else {
	    var len = handler.length;
	    var listeners = arrayClone$3(handler, len);
	    for (var i = 0; i < len; ++i)
	      ReflectApply$3(listeners[i], this, args);
	  }

	  return true;
	};

	function _addListener$3(target, type, listener, prepend) {
	  var m;
	  var events;
	  var existing;

	  checkListener$3(listener);

	  events = target._events;
	  if (events === undefined) {
	    events = target._events = Object.create(null);
	    target._eventsCount = 0;
	  } else {
	    // To avoid recursion in the case that type === "newListener"! Before
	    // adding it to the listeners, first emit "newListener".
	    if (events.newListener !== undefined) {
	      target.emit('newListener', type,
	                  listener.listener ? listener.listener : listener);

	      // Re-assign `events` because a newListener handler could have caused the
	      // this._events to be assigned to a new object
	      events = target._events;
	    }
	    existing = events[type];
	  }

	  if (existing === undefined) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    existing = events[type] = listener;
	    ++target._eventsCount;
	  } else {
	    if (typeof existing === 'function') {
	      // Adding the second element, need to change to array.
	      existing = events[type] =
	        prepend ? [listener, existing] : [existing, listener];
	      // If we've already got an array, just append.
	    } else if (prepend) {
	      existing.unshift(listener);
	    } else {
	      existing.push(listener);
	    }

	    // Check for listener leak
	    m = _getMaxListeners$3(target);
	    if (m > 0 && existing.length > m && !existing.warned) {
	      existing.warned = true;
	      // No error code for this since it is a Warning
	      // eslint-disable-next-line no-restricted-syntax
	      var w = new Error('Possible EventEmitter memory leak detected. ' +
	                          existing.length + ' ' + String(type) + ' listeners ' +
	                          'added. Use emitter.setMaxListeners() to ' +
	                          'increase limit');
	      w.name = 'MaxListenersExceededWarning';
	      w.emitter = target;
	      w.type = type;
	      w.count = existing.length;
	      ProcessEmitWarning$3(w);
	    }
	  }

	  return target;
	}

	EventEmitter$1$3.prototype.addListener = function addListener(type, listener) {
	  return _addListener$3(this, type, listener, false);
	};

	EventEmitter$1$3.prototype.on = EventEmitter$1$3.prototype.addListener;

	EventEmitter$1$3.prototype.prependListener =
	    function prependListener(type, listener) {
	      return _addListener$3(this, type, listener, true);
	    };

	function onceWrapper$3() {
	  if (!this.fired) {
	    this.target.removeListener(this.type, this.wrapFn);
	    this.fired = true;
	    if (arguments.length === 0)
	      return this.listener.call(this.target);
	    return this.listener.apply(this.target, arguments);
	  }
	}

	function _onceWrap$3(target, type, listener) {
	  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
	  var wrapped = onceWrapper$3.bind(state);
	  wrapped.listener = listener;
	  state.wrapFn = wrapped;
	  return wrapped;
	}

	EventEmitter$1$3.prototype.once = function once(type, listener) {
	  checkListener$3(listener);
	  this.on(type, _onceWrap$3(this, type, listener));
	  return this;
	};

	EventEmitter$1$3.prototype.prependOnceListener =
	    function prependOnceListener(type, listener) {
	      checkListener$3(listener);
	      this.prependListener(type, _onceWrap$3(this, type, listener));
	      return this;
	    };

	// Emits a 'removeListener' event if and only if the listener was removed.
	EventEmitter$1$3.prototype.removeListener =
	    function removeListener(type, listener) {
	      var list, events, position, i, originalListener;

	      checkListener$3(listener);

	      events = this._events;
	      if (events === undefined)
	        return this;

	      list = events[type];
	      if (list === undefined)
	        return this;

	      if (list === listener || list.listener === listener) {
	        if (--this._eventsCount === 0)
	          this._events = Object.create(null);
	        else {
	          delete events[type];
	          if (events.removeListener)
	            this.emit('removeListener', type, list.listener || listener);
	        }
	      } else if (typeof list !== 'function') {
	        position = -1;

	        for (i = list.length - 1; i >= 0; i--) {
	          if (list[i] === listener || list[i].listener === listener) {
	            originalListener = list[i].listener;
	            position = i;
	            break;
	          }
	        }

	        if (position < 0)
	          return this;

	        if (position === 0)
	          list.shift();
	        else {
	          spliceOne$3(list, position);
	        }

	        if (list.length === 1)
	          events[type] = list[0];

	        if (events.removeListener !== undefined)
	          this.emit('removeListener', type, originalListener || listener);
	      }

	      return this;
	    };

	EventEmitter$1$3.prototype.off = EventEmitter$1$3.prototype.removeListener;

	EventEmitter$1$3.prototype.removeAllListeners =
	    function removeAllListeners(type) {
	      var listeners, events, i;

	      events = this._events;
	      if (events === undefined)
	        return this;

	      // not listening for removeListener, no need to emit
	      if (events.removeListener === undefined) {
	        if (arguments.length === 0) {
	          this._events = Object.create(null);
	          this._eventsCount = 0;
	        } else if (events[type] !== undefined) {
	          if (--this._eventsCount === 0)
	            this._events = Object.create(null);
	          else
	            delete events[type];
	        }
	        return this;
	      }

	      // emit removeListener for all listeners on all events
	      if (arguments.length === 0) {
	        var keys = Object.keys(events);
	        var key;
	        for (i = 0; i < keys.length; ++i) {
	          key = keys[i];
	          if (key === 'removeListener') continue;
	          this.removeAllListeners(key);
	        }
	        this.removeAllListeners('removeListener');
	        this._events = Object.create(null);
	        this._eventsCount = 0;
	        return this;
	      }

	      listeners = events[type];

	      if (typeof listeners === 'function') {
	        this.removeListener(type, listeners);
	      } else if (listeners !== undefined) {
	        // LIFO order
	        for (i = listeners.length - 1; i >= 0; i--) {
	          this.removeListener(type, listeners[i]);
	        }
	      }

	      return this;
	    };

	function _listeners$3(target, type, unwrap) {
	  var events = target._events;

	  if (events === undefined)
	    return [];

	  var evlistener = events[type];
	  if (evlistener === undefined)
	    return [];

	  if (typeof evlistener === 'function')
	    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

	  return unwrap ?
	    unwrapListeners$3(evlistener) : arrayClone$3(evlistener, evlistener.length);
	}

	EventEmitter$1$3.prototype.listeners = function listeners(type) {
	  return _listeners$3(this, type, true);
	};

	EventEmitter$1$3.prototype.rawListeners = function rawListeners(type) {
	  return _listeners$3(this, type, false);
	};

	EventEmitter$1$3.listenerCount = function(emitter, type) {
	  if (typeof emitter.listenerCount === 'function') {
	    return emitter.listenerCount(type);
	  } else {
	    return listenerCount$3.call(emitter, type);
	  }
	};

	EventEmitter$1$3.prototype.listenerCount = listenerCount$3;
	function listenerCount$3(type) {
	  var events = this._events;

	  if (events !== undefined) {
	    var evlistener = events[type];

	    if (typeof evlistener === 'function') {
	      return 1;
	    } else if (evlistener !== undefined) {
	      return evlistener.length;
	    }
	  }

	  return 0;
	}

	EventEmitter$1$3.prototype.eventNames = function eventNames() {
	  return this._eventsCount > 0 ? ReflectOwnKeys$3(this._events) : [];
	};

	function arrayClone$3(arr, n) {
	  var copy = new Array(n);
	  for (var i = 0; i < n; ++i)
	    copy[i] = arr[i];
	  return copy;
	}

	function spliceOne$3(list, index) {
	  for (; index + 1 < list.length; index++)
	    list[index] = list[index + 1];
	  list.pop();
	}

	function unwrapListeners$3(arr) {
	  var ret = new Array(arr.length);
	  for (var i = 0; i < ret.length; ++i) {
	    ret[i] = arr[i].listener || arr[i];
	  }
	  return ret;
	}

	function once$3(emitter, name) {
	  return new Promise(function (resolve, reject) {
	    function errorListener(err) {
	      emitter.removeListener(name, resolver);
	      reject(err);
	    }

	    function resolver() {
	      if (typeof emitter.removeListener === 'function') {
	        emitter.removeListener('error', errorListener);
	      }
	      resolve([].slice.call(arguments));
	    }
	    eventTargetAgnosticAddListener$3(emitter, name, resolver, { once: true });
	    if (name !== 'error') {
	      addErrorHandlerIfEventEmitter$3(emitter, errorListener, { once: true });
	    }
	  });
	}

	function addErrorHandlerIfEventEmitter$3(emitter, handler, flags) {
	  if (typeof emitter.on === 'function') {
	    eventTargetAgnosticAddListener$3(emitter, 'error', handler, flags);
	  }
	}

	function eventTargetAgnosticAddListener$3(emitter, name, listener, flags) {
	  if (typeof emitter.on === 'function') {
	    if (flags.once) {
	      emitter.once(name, listener);
	    } else {
	      emitter.on(name, listener);
	    }
	  } else if (typeof emitter.addEventListener === 'function') {
	    // EventTarget does not have `error` event semantics like Node
	    // EventEmitters, we do not listen for `error` events here.
	    emitter.addEventListener(name, function wrapListener(arg) {
	      // IE does not have builtin `{ once: true }` support so we
	      // have to do it manually.
	      if (flags.once) {
	        emitter.removeEventListener(name, wrapListener);
	      }
	      listener(arg);
	    });
	  } else {
	    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
	  }
	}

	Object.defineProperty(dist$5, '__esModule', { value: true });

	var EventEmitter$5 = events$3.exports;

	function _interopDefaultLegacy$5 (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var EventEmitter__default$4 = /*#__PURE__*/_interopDefaultLegacy$5(EventEmitter$5);

	const __RΦ$r$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$r$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$r$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$r$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [95]: { LΦ: t => SyntaxError }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Обработчик синтаксической ошибки в коде source.
	 * @param error
	 * @param source
	 */
	function syntaxErrorHandler$4(error, source) {
	    console.group('Синтаксическая ошибка');
	    console.log(error.message);
	    console.log(source);
	    console.log(error.stack);
	    console.groupEnd();
	}
	__RΦ$r$4.m("rt:p", [{ n: "error", t: () => __RΦ$r$4.a(95), v: null }, { n: "source", t: () => __RΦ$r$4.a(14), v: null }])(syntaxErrorHandler$4);
	__RΦ$r$4.m("rt:f", "F")(syntaxErrorHandler$4);
	__RΦ$r$4.m("rt:t", () => __RΦ$r$4.a(23))(syntaxErrorHandler$4);

	const __RΦ$q$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$q$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$q$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$q$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [112]: { LΦ: t => Object } } };
	/**
	 * Выполнить скрипт из текста, который возвращает значение типа T.
	 * @param source
	 */
	function execFunctionScript$4(source) {
	    if (!source.trim()) {
	        throw new Error('Не задано тело функции');
	    }
	    try {
	        const code = new Function('', `return (${source})`);
	        return code();
	    }
	    catch (error) {
	        if (error instanceof SyntaxError) {
	            syntaxErrorHandler$4(error, source);
	        }
	        throw error;
	    }
	}
	__RΦ$q$4.m("rt:p", [{ n: "source", t: () => __RΦ$q$4.a(14), v: null }])(execFunctionScript$4);
	__RΦ$q$4.m("rt:f", "F")(execFunctionScript$4);
	__RΦ$q$4.m("rt:t", () => __RΦ$q$4.a(112))(execFunctionScript$4);

	const __RΦ$p$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$p$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$p$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$p$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [113]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$p$4.a(10), __RΦ$p$4.a(14)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Выполнить скрипт из текста, который ничего не возвращает.
	 * @param source
	 */
	function execActionScript$4(source) {
	    if (source) {
	        try {
	            const code = new Function('', source);
	            code();
	        }
	        catch (error) {
	            if (error instanceof SyntaxError) {
	                syntaxErrorHandler$4(error, source);
	            }
	            throw error;
	        }
	    }
	}
	__RΦ$p$4.m("rt:p", [{ n: "source", t: () => __RΦ$p$4.a(113), v: null }])(execActionScript$4);
	__RΦ$p$4.m("rt:f", "F")(execActionScript$4);
	__RΦ$p$4.m("rt:t", () => __RΦ$p$4.a(23))(execActionScript$4);

	const __RΦ$o$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$o$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$o$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$o$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String } } };
	const SPACE$4 = ' ';
	const EOL$4 = '\n';
	const trim$4 = __RΦ$o$4.f((message) => message.trim()
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	, [__RΦ$o$4.m("rt:p", [{ n: "message", t: () => __RΦ$o$4.a(14), v: null }]), __RΦ$o$4.m("rt:f", "F>"), __RΦ$o$4.m("rt:t", () => __RΦ$o$4.a(14))], "trim");
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	function toOneLine$4(message) {
	    return message.trim().split(EOL$4).map(trim$4).join(SPACE$4);
	}
	__RΦ$o$4.m("rt:p", [{ n: "message", t: () => __RΦ$o$4.a(14), v: null }])(toOneLine$4);
	__RΦ$o$4.m("rt:f", "F")(toOneLine$4);
	__RΦ$o$4.m("rt:t", () => __RΦ$o$4.a(14))(toOneLine$4);

	const __RΦ$n$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$n$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$n$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$n$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1]: { RΦ: t => ({ TΦ: "~" }) } } };
	function isBrowser$4() {
	    return new Function('try { return this === window } catch (e) { return false }')();
	}
	__RΦ$n$4.m("rt:p", [])(isBrowser$4);
	__RΦ$n$4.m("rt:f", "F")(isBrowser$4);
	__RΦ$n$4.m("rt:t", () => __RΦ$n$4.a(1))(isBrowser$4);

	const __RΦ$m$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$m$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$m$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$m$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [21]: { LΦ: t => Boolean } } };
	var IΦdefault$9$4 = { name: "IStoppable", prototype: {}, identity: Symbol("IStoppable (interface)") };
	(t => __RΦ$m$4.t[150] = t)(IΦdefault$9$4);
	__RΦ$m$4.m("rt:P", [])(IΦdefault$9$4);
	__RΦ$m$4.m("rt:m", ["stop"])(IΦdefault$9$4);
	__RΦ$m$4.m("rt:f", "Ie")(IΦdefault$9$4);
	__RΦ$m$4.m("rt:p", [])(IΦdefault$9$4.prototype, "stop");
	__RΦ$m$4.m("rt:f", "M")(IΦdefault$9$4.prototype, "stop");
	__RΦ$m$4.m("rt:t", () => __RΦ$m$4.a(23))(IΦdefault$9$4.prototype, "stop");
	__RΦ$m$4.m("rt:p", [])(IΦdefault$9$4.prototype, "stop");
	__RΦ$m$4.m("rt:f", "M")(IΦdefault$9$4.prototype, "stop");
	__RΦ$m$4.m("rt:t", () => __RΦ$m$4.a(23))(IΦdefault$9$4.prototype, "stop");
	function isStoppable$4(object) {
	    return 'stop' in object && typeof object.stop === 'function';
	}
	__RΦ$m$4.m("rt:p", [{ n: "object", t: () => __RΦ$m$4.a(1), v: null }])(isStoppable$4);
	__RΦ$m$4.m("rt:f", "F")(isStoppable$4);
	__RΦ$m$4.m("rt:t", () => __RΦ$m$4.a(21))(isStoppable$4);

	const __RΦ$l$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$l$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$l$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$l$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$8$4 = { name: "IStartable", prototype: {}, identity: Symbol("IStartable (interface)") };
	(t => __RΦ$l$4.t[149] = t)(IΦdefault$8$4);
	__RΦ$l$4.m("rt:P", [])(IΦdefault$8$4);
	__RΦ$l$4.m("rt:m", ["start"])(IΦdefault$8$4);
	__RΦ$l$4.m("rt:f", "Ie")(IΦdefault$8$4);
	__RΦ$l$4.m("rt:p", [])(IΦdefault$8$4.prototype, "start");
	__RΦ$l$4.m("rt:f", "M")(IΦdefault$8$4.prototype, "start");
	__RΦ$l$4.m("rt:t", () => __RΦ$l$4.a(23))(IΦdefault$8$4.prototype, "start");
	__RΦ$l$4.m("rt:p", [])(IΦdefault$8$4.prototype, "start");
	__RΦ$l$4.m("rt:f", "M")(IΦdefault$8$4.prototype, "start");
	__RΦ$l$4.m("rt:t", () => __RΦ$l$4.a(23))(IΦdefault$8$4.prototype, "start");

	/**
	 * Состояния таймера.
	 */
	var ETimerState$4;
	(function (ETimerState) {
	    ETimerState["Started"] = "started";
	    ETimerState["Paused"] = "paused";
	    ETimerState["Stopped"] = "stopped";
	})(ETimerState$4 || (ETimerState$4 = {}));

	const __RΦ$k$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$k$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$k$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$k$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [666]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$k$4.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [667]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$k$4.a(4) }] }) }, [668]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$k$4.a(4) }] }) } } };
	var IΦdefault$7$4 = { name: "IStateHandlers", prototype: {}, identity: Symbol("IStateHandlers (interface)") };
	(t => __RΦ$k$4.t[669] = t)(IΦdefault$7$4);
	__RΦ$k$4.m("rt:P", ["started", "paused", "stopped"])(IΦdefault$7$4);
	__RΦ$k$4.m("rt:m", [])(IΦdefault$7$4);
	__RΦ$k$4.m("rt:f", "Ie")(IΦdefault$7$4);
	__RΦ$k$4.m("rt:t", () => __RΦ$k$4.a(666))(IΦdefault$7$4.prototype, "started");
	__RΦ$k$4.m("rt:f", "P?")(IΦdefault$7$4.prototype, "started");
	__RΦ$k$4.m("rt:t", () => __RΦ$k$4.a(667))(IΦdefault$7$4.prototype, "paused");
	__RΦ$k$4.m("rt:f", "P?")(IΦdefault$7$4.prototype, "paused");
	__RΦ$k$4.m("rt:t", () => __RΦ$k$4.a(668))(IΦdefault$7$4.prototype, "stopped");
	__RΦ$k$4.m("rt:f", "P?")(IΦdefault$7$4.prototype, "stopped");
	__RΦ$k$4.m("rt:t", () => __RΦ$k$4.a(666))(IΦdefault$7$4.prototype, "started");
	__RΦ$k$4.m("rt:f", "P?")(IΦdefault$7$4.prototype, "started");
	__RΦ$k$4.m("rt:t", () => __RΦ$k$4.a(667))(IΦdefault$7$4.prototype, "paused");
	__RΦ$k$4.m("rt:f", "P?")(IΦdefault$7$4.prototype, "paused");
	__RΦ$k$4.m("rt:t", () => __RΦ$k$4.a(668))(IΦdefault$7$4.prototype, "stopped");
	__RΦ$k$4.m("rt:f", "P?")(IΦdefault$7$4.prototype, "stopped");

	const __RΦ$j$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$j$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$j$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$j$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [689]: { RΦ: t => ({ TΦ: "e", e: ETimerState$4 }) }, [673]: { RΦ: t => ({ TΦ: "g", t: __RΦ$j$4.a(669), p: [__RΦ$j$4.a(672)] }) }, [669]: { LΦ: t => IΦdefault$7$4 }, [672]: { LΦ: t => Object }, [690]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$j$4.a(10), __RΦ$j$4.a(672)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	/**
	 * Запустить определенный скрипт в зависимости от состояния таймера.
	 * @param state Текущее состояние таймера.
	 * @param stateHandlers Массив скриптов (ключ - имя состояния, значение - скрипт).
	 */
	function handleByState$4(state, stateHandlers) {
	    switch (state) {
	        case ETimerState$4.Started: return stateHandlers.started ? stateHandlers.started() : undefined;
	        case ETimerState$4.Paused: return stateHandlers.paused ? stateHandlers.paused() : undefined;
	        case ETimerState$4.Stopped: return stateHandlers.stopped ? stateHandlers.stopped() : undefined;
	    }
	}
	__RΦ$j$4.m("rt:p", [{ n: "state", t: () => __RΦ$j$4.a(689), v: null }, { n: "stateHandlers", t: () => __RΦ$j$4.a(673), v: null }])(handleByState$4);
	__RΦ$j$4.m("rt:f", "F")(handleByState$4);
	__RΦ$j$4.m("rt:t", () => __RΦ$j$4.a(690))(handleByState$4);

	const __RΦ$i$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$i$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$i$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$i$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [1603]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$i$4.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1551]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$i$4.a(10), __RΦ$i$4.a(15)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [689]: { RΦ: t => ({ TΦ: "e", e: ETimerState$4 }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Простая реализация таймера.
	 */
	class Timer$4 {
	    timeout;
	    action;
	    timerId;
	    /**
	     * Время запуска таймера. В миллисекундах.
	     * @private
	     */
	    time = 0;
	    /**
	     * Время постановки на паузу. В миллисекундах.
	     * @private
	     */
	    pauseTime = 0;
	    /**
	     * Общее время остановки таймера. В миллисекундах.
	     * @private
	     */
	    pauseInterval = 0;
	    /**
	     * Текущее состояние таймера
	     * @private
	     */
	    state = ETimerState$4.Stopped;
	    /**
	     * Внимание, внутри action определена this как Timer.
	     * @param timeout
	     * @param action
	     */
	    constructor(timeout, action) {
	        this.timeout = timeout;
	        this.action = action;
	    }
	    /**
	     * Запуск таймера.
	     * Стартовать таймер сначала или продолжить с паузы.
	     */
	    start() {
	        handleByState$4(this.state, {
	            paused: __RΦ$i$4.f(() => {
	                this.state = ETimerState$4.Started;
	                this.pauseInterval += Date.now() - this.pauseTime;
	            }, [__RΦ$i$4.m("rt:p", []), __RΦ$i$4.m("rt:f", "F>"), __RΦ$i$4.m("rt:t", () => __RΦ$i$4.a(23))], "paused"),
	            stopped: __RΦ$i$4.f(() => {
	                this.state = ETimerState$4.Started;
	                this.timerId = window.setInterval(this.tick.bind(this), this.timeout);
	                this.time = Date.now();
	            }, [__RΦ$i$4.m("rt:p", []), __RΦ$i$4.m("rt:f", "F>"), __RΦ$i$4.m("rt:t", () => __RΦ$i$4.a(23))], "stopped")
	        });
	    }
	    /**
	     * Поставить на паузу таймер.
	     * Состояние сохраняется, счет приостанавливается.
	     */
	    pause() {
	        handleByState$4(this.state, {
	            started: __RΦ$i$4.f(() => {
	                this.state = ETimerState$4.Paused;
	                this.pauseTime = Date.now();
	            }, [__RΦ$i$4.m("rt:p", []), __RΦ$i$4.m("rt:f", "F>"), __RΦ$i$4.m("rt:t", () => __RΦ$i$4.a(23))], "started")
	        });
	    }
	    /**
	     * Остановить таймер.
	     * Полный сброс таймера.
	     */
	    stop() {
	        const stop = __RΦ$i$4.f(() => {
	            this.state = ETimerState$4.Stopped;
	            clearInterval(this.timerId);
	            this.timerId = undefined;
	            this.time = 0;
	        }, [__RΦ$i$4.m("rt:p", []), __RΦ$i$4.m("rt:f", "F>"), __RΦ$i$4.m("rt:t", () => __RΦ$i$4.a(23))], "stop");
	        handleByState$4(this.state, {
	            started: stop,
	            paused: stop
	        });
	    }
	    /**
	     * Количество миллисекунд с начала старта таймера.
	     * С учетом всех пауз.
	     */
	    get interval() {
	        const result = handleByState$4(this.state, {
	            started: () => Date.now() - this.time - this.pauseTime,
	            paused: () => this.time - this.pauseTime,
	            stopped: () => 0
	        });
	        return result === undefined ? 0 : result;
	    }
	    /**
	     * Выполняемая нагрузка таймера.
	     * @private
	     */
	    tick() {
	        handleByState$4(this.state, {
	            started: __RΦ$i$4.f(() => this.action.call(this), [__RΦ$i$4.m("rt:p", []), __RΦ$i$4.m("rt:f", "F>"), __RΦ$i$4.m("rt:t", () => __RΦ$i$4.a(23))], "started")
	        });
	    }
	}
	(t => __RΦ$i$4.t[692] = t)(Timer$4);
	__RΦ$i$4.m("rt:SP", [])(Timer$4);
	__RΦ$i$4.m("rt:P", ["timerId", "time", "pauseTime", "pauseInterval", "state", "timeout", "action", "interval"])(Timer$4);
	__RΦ$i$4.m("rt:Sm", [])(Timer$4);
	__RΦ$i$4.m("rt:m", ["start", "pause", "stop", "tick"])(Timer$4);
	__RΦ$i$4.m("rt:p", [{ n: "timeout", t: () => __RΦ$i$4.a(15), v: null, f: "#" }, { n: "action", t: () => __RΦ$i$4.a(1603), v: null, f: "#" }])(Timer$4);
	__RΦ$i$4.m("rt:i", [() => undefined, () => undefined])(Timer$4);
	__RΦ$i$4.m("rt:f", "Ce")(Timer$4);
	__RΦ$i$4.m("rt:t", () => __RΦ$i$4.a(1551))(Timer$4.prototype, "timerId");
	__RΦ$i$4.m("rt:f", "P#")(Timer$4.prototype, "timerId");
	__RΦ$i$4.m("rt:t", () => __RΦ$i$4.a(15))(Timer$4.prototype, "time");
	__RΦ$i$4.m("rt:f", "P#")(Timer$4.prototype, "time");
	__RΦ$i$4.m("rt:t", () => __RΦ$i$4.a(15))(Timer$4.prototype, "pauseTime");
	__RΦ$i$4.m("rt:f", "P#")(Timer$4.prototype, "pauseTime");
	__RΦ$i$4.m("rt:t", () => __RΦ$i$4.a(15))(Timer$4.prototype, "pauseInterval");
	__RΦ$i$4.m("rt:f", "P#")(Timer$4.prototype, "pauseInterval");
	__RΦ$i$4.m("rt:t", () => __RΦ$i$4.a(689))(Timer$4.prototype, "state");
	__RΦ$i$4.m("rt:f", "P#")(Timer$4.prototype, "state");
	__RΦ$i$4.m("rt:f", "M$.")(Timer$4.prototype["start"]);
	((t, p) => __RΦ$i$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$4.prototype, "start");
	__RΦ$i$4.m("rt:p", [])(Timer$4.prototype, "start");
	__RΦ$i$4.m("rt:f", "M$.")(Timer$4.prototype, "start");
	__RΦ$i$4.m("rt:t", () => __RΦ$i$4.a(23))(Timer$4.prototype, "start");
	__RΦ$i$4.m("rt:f", "M$.")(Timer$4.prototype["pause"]);
	((t, p) => __RΦ$i$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$4.prototype, "pause");
	__RΦ$i$4.m("rt:p", [])(Timer$4.prototype, "pause");
	__RΦ$i$4.m("rt:f", "M$.")(Timer$4.prototype, "pause");
	__RΦ$i$4.m("rt:t", () => __RΦ$i$4.a(23))(Timer$4.prototype, "pause");
	__RΦ$i$4.m("rt:f", "M$.")(Timer$4.prototype["stop"]);
	((t, p) => __RΦ$i$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$4.prototype, "stop");
	__RΦ$i$4.m("rt:p", [])(Timer$4.prototype, "stop");
	__RΦ$i$4.m("rt:f", "M$.")(Timer$4.prototype, "stop");
	__RΦ$i$4.m("rt:t", () => __RΦ$i$4.a(23))(Timer$4.prototype, "stop");
	__RΦ$i$4.m("rt:t", () => __RΦ$i$4.a(15))(Timer$4.prototype, "interval");
	__RΦ$i$4.m("rt:f", "P$")(Timer$4.prototype, "interval");
	__RΦ$i$4.m("rt:f", "M#.")(Timer$4.prototype["tick"]);
	((t, p) => __RΦ$i$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$4.prototype, "tick");
	__RΦ$i$4.m("rt:p", [])(Timer$4.prototype, "tick");
	__RΦ$i$4.m("rt:f", "M#.")(Timer$4.prototype, "tick");
	__RΦ$i$4.m("rt:t", () => __RΦ$i$4.a(23))(Timer$4.prototype, "tick");

	const __RΦ$h$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$h$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$h$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$h$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1607]: { LΦ: t => Object } } };
	var IΦdefault$6$4 = { name: "ICreator", prototype: {}, identity: Symbol("ICreator (interface)") };
	(t => __RΦ$h$4.t[1608] = t)(IΦdefault$6$4);
	__RΦ$h$4.m("rt:P", [])(IΦdefault$6$4);
	__RΦ$h$4.m("rt:m", ["create"])(IΦdefault$6$4);
	__RΦ$h$4.m("rt:f", "Ie")(IΦdefault$6$4);
	__RΦ$h$4.m("rt:p", [])(IΦdefault$6$4.prototype, "create");
	__RΦ$h$4.m("rt:f", "M")(IΦdefault$6$4.prototype, "create");
	__RΦ$h$4.m("rt:t", () => __RΦ$h$4.a(1607))(IΦdefault$6$4.prototype, "create");
	__RΦ$h$4.m("rt:p", [])(IΦdefault$6$4.prototype, "create");
	__RΦ$h$4.m("rt:f", "M")(IΦdefault$6$4.prototype, "create");
	__RΦ$h$4.m("rt:t", () => __RΦ$h$4.a(1607))(IΦdefault$6$4.prototype, "create");

	const __RΦ$g$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$g$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$g$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$g$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1610]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$g$4.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1618]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$g$4.a(10), __RΦ$g$4.a(1612)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1612]: { LΦ: t => Object }, [1615]: { RΦ: t => ({ TΦ: "g", t: __RΦ$g$4.a(1608), p: [__RΦ$g$4.a(1612)] }) }, [1608]: { LΦ: t => IΦdefault$6$4 } } };
	/**
	 * Отложенная инициализация.
	 * @link https://metanit.com/sharp/tutorial/20.1.php
	 * @link https://docs.microsoft.com/ru-ru/dotnet/api/system.lazy-1?view=net-5.0
	 */
	class Lazy$4 {
	    createFn;
	    #value;
	    #creator;
	    constructor(createFn) {
	        this.createFn = createFn;
	        this.#creator = {
	            create() {
	                return createFn();
	            }
	        };
	    }
	    get value() {
	        if (!this.#value) {
	            this.#value = this.#creator.create();
	        }
	        return this.#value;
	    }
	}
	(t => __RΦ$g$4.t[1611] = t)(Lazy$4);
	__RΦ$g$4.m("rt:SP", [])(Lazy$4);
	__RΦ$g$4.m("rt:P", ["#value", "#creator", "createFn", "value"])(Lazy$4);
	__RΦ$g$4.m("rt:Sm", [])(Lazy$4);
	__RΦ$g$4.m("rt:m", [])(Lazy$4);
	__RΦ$g$4.m("rt:p", [{ n: "createFn", t: () => __RΦ$g$4.a(1610), v: null, f: "#" }])(Lazy$4);
	__RΦ$g$4.m("rt:f", "Ce")(Lazy$4);
	__RΦ$g$4.m("rt:t", () => __RΦ$g$4.a(1618))(Lazy$4.prototype, "#value");
	__RΦ$g$4.m("rt:f", "P")(Lazy$4.prototype, "#value");
	__RΦ$g$4.m("rt:t", () => __RΦ$g$4.a(1615))(Lazy$4.prototype, "#creator");
	__RΦ$g$4.m("rt:f", "P")(Lazy$4.prototype, "#creator");
	__RΦ$g$4.m("rt:t", () => __RΦ$g$4.a(1612))(Lazy$4.prototype, "value");
	__RΦ$g$4.m("rt:f", "P")(Lazy$4.prototype, "value");

	const __RΦ$f$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$f$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$f$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$f$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	var IΦdefault$5$4 = { name: "IPoint", prototype: {}, identity: Symbol("IPoint (interface)") };
	(t => __RΦ$f$4.t[141] = t)(IΦdefault$5$4);
	__RΦ$f$4.m("rt:P", ["x", "y"])(IΦdefault$5$4);
	__RΦ$f$4.m("rt:m", [])(IΦdefault$5$4);
	__RΦ$f$4.m("rt:f", "Ie")(IΦdefault$5$4);
	__RΦ$f$4.m("rt:t", () => __RΦ$f$4.a(15))(IΦdefault$5$4.prototype, "x");
	__RΦ$f$4.m("rt:f", "P")(IΦdefault$5$4.prototype, "x");
	__RΦ$f$4.m("rt:t", () => __RΦ$f$4.a(15))(IΦdefault$5$4.prototype, "y");
	__RΦ$f$4.m("rt:f", "P")(IΦdefault$5$4.prototype, "y");
	__RΦ$f$4.m("rt:t", () => __RΦ$f$4.a(15))(IΦdefault$5$4.prototype, "x");
	__RΦ$f$4.m("rt:f", "P")(IΦdefault$5$4.prototype, "x");
	__RΦ$f$4.m("rt:t", () => __RΦ$f$4.a(15))(IΦdefault$5$4.prototype, "y");
	__RΦ$f$4.m("rt:f", "P")(IΦdefault$5$4.prototype, "y");

	const __RΦ$e$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$e$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$e$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$e$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [141]: { LΦ: t => IΦdefault$5$4 }, [1627]: { TΦ: "5", name: "default" }, [21]: { LΦ: t => Boolean }, [1636]: { RΦ: t => ({ TΦ: "[", e: __RΦ$e$4.a(15) }) }, [14]: { LΦ: t => String } } };
	/*
	 * Увеличить длину вектора можно так:
	 * Vector.translate(Vector.identity.scale(length))
	 *
	 */
	/**
	 * Вектор.
	 * @unmutable
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/vector/Vector.js
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/Point.js
	 */
	class Vector$4 {
	    x;
	    y;
	    /**
	     * Расстояние от начала координат до точки.
	     */
	    static distance(point) {
	        // noinspection JSSuspiciousNameCombination
	        return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
	    }
	    /**
	     * Создать вектор на основе угла и длины.
	     */
	    static create(angle, length) {
	        return new Vector$4(length * Math.cos(angle), length * Math.sin(angle));
	    }
	    /**
	     * Угол между вектором и положительной осью.
	     * Принимает значение от -Math.PI до Math.PI радиан.
	     */
	    get angle() {
	        return Math.atan2(this.y, this.x);
	    }
	    /**
	     * Модуль (длина) вектора.
	     */
	    get length() {
	        return Vector$4.distance(this);
	    }
	    /**
	     * Возвращает true, если вектор является нулевым.
	     */
	    get isNull() {
	        return this.x === 0 && this.y === 0;
	    }
	    /**
	     * Конструктор вектора.
	     * @param x
	     * @param y
	     */
	    constructor(x = 0, y = 0) {
	        this.x = x;
	        this.y = y;
	    }
	    /**
	     * Получить единичный вектор, равный по направлению исходному.
	     * Он же направляющий вектор (единичный, равный по направлению).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get identity() {
	        return (new Vector$4(Math.cos(this.angle), Math.sin(this.angle)));
	    }
	    /**
	     * Получить обратный вектор (инверсия вектора).
	     */
	    get inverse() {
	        return new Vector$4(-this.x, -this.y);
	    }
	    /**
	     * Нормаль вектора (единичный вектор, перпендикулярный исходному).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get normal() {
	        return this.clone().rotate(Math.PI / 2).identity;
	        // TODO Проверить эту формулу нахождения перпендикулярного вектора.
	        /*
	            a: 1 / parallel.x(),
	            b: -1 / parallel.y(),
	        */
	    }
	    /**
	     * Сложение векторов.
	     * @param vector
	     */
	    translate(vector) {
	        return new Vector$4(this.x + vector.x, this.y + vector.y);
	    }
	    /**
	     * Вращение вектора.
	     * @param angle
	     */
	    rotate(angle) {
	        return new Vector$4(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle));
	    }
	    /**
	     * Умножение вектора на число.
	     */
	    scale(scale) {
	        return new Vector$4(this.x * scale, this.y * scale);
	    }
	    /**
	     * Скалярное произведение векторов.
	     * @param vector
	     */
	    multiply(vector) {
	        return new Vector$4(this.x * vector.x, this.y * vector.y);
	    }
	    /**
	     * Взятие остатка от деления.
	     * @param vector
	     */
	    mod(vector) {
	        return new Vector$4(this.x % vector.x, this.y % vector.y);
	    }
	    clone() {
	        return new Vector$4(this.x, this.y);
	    }
	    toArray() {
	        return [this.x, this.y];
	    }
	    toString(digits = 2) {
	        return `[${this.x.toFixed(digits)}, ${this.y.toFixed(digits)}]`;
	    }
	}
	(t => __RΦ$e$4.t[1627] = t)(Vector$4);
	__RΦ$e$4.m("rt:SP", [])(Vector$4);
	__RΦ$e$4.m("rt:P", ["angle", "length", "isNull", "x", "y", "identity", "inverse", "normal"])(Vector$4);
	__RΦ$e$4.m("rt:Sm", ["distance", "create"])(Vector$4);
	__RΦ$e$4.m("rt:m", ["translate", "rotate", "scale", "multiply", "mod", "clone", "toArray", "toString"])(Vector$4);
	__RΦ$e$4.m("rt:p", [{ n: "x", t: () => __RΦ$e$4.a(15), v: function () { return 0; }, f: "$R" }, { n: "y", t: () => __RΦ$e$4.a(15), v: function () { return 0; }, f: "$R" }])(Vector$4);
	__RΦ$e$4.m("rt:i", [() => undefined])(Vector$4);
	__RΦ$e$4.m("rt:f", "Ce")(Vector$4);
	__RΦ$e$4.m("rt:f", "M$S")(Vector$4["distance"]);
	((t, p) => __RΦ$e$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$4, "distance");
	__RΦ$e$4.m("rt:p", [{ n: "point", t: () => __RΦ$e$4.a(141), v: null }])(Vector$4, "distance");
	__RΦ$e$4.m("rt:f", "M$S")(Vector$4, "distance");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(15))(Vector$4, "distance");
	__RΦ$e$4.m("rt:f", "M$S")(Vector$4["create"]);
	((t, p) => __RΦ$e$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$4, "create");
	__RΦ$e$4.m("rt:p", [{ n: "angle", t: () => __RΦ$e$4.a(15), v: null }, { n: "length", t: () => __RΦ$e$4.a(15), v: null }])(Vector$4, "create");
	__RΦ$e$4.m("rt:f", "M$S")(Vector$4, "create");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(1627))(Vector$4, "create");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(15))(Vector$4.prototype, "angle");
	__RΦ$e$4.m("rt:f", "P$")(Vector$4.prototype, "angle");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(15))(Vector$4.prototype, "length");
	__RΦ$e$4.m("rt:f", "P$")(Vector$4.prototype, "length");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(21))(Vector$4.prototype, "isNull");
	__RΦ$e$4.m("rt:f", "P$")(Vector$4.prototype, "isNull");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(1627))(Vector$4.prototype, "identity");
	__RΦ$e$4.m("rt:f", "P$")(Vector$4.prototype, "identity");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(1627))(Vector$4.prototype, "inverse");
	__RΦ$e$4.m("rt:f", "P$")(Vector$4.prototype, "inverse");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(1627))(Vector$4.prototype, "normal");
	__RΦ$e$4.m("rt:f", "P$")(Vector$4.prototype, "normal");
	__RΦ$e$4.m("rt:f", "M$")(Vector$4.prototype["translate"]);
	((t, p) => __RΦ$e$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$4.prototype, "translate");
	__RΦ$e$4.m("rt:p", [{ n: "vector", t: () => __RΦ$e$4.a(1627), v: null }])(Vector$4.prototype, "translate");
	__RΦ$e$4.m("rt:f", "M$")(Vector$4.prototype, "translate");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(1627))(Vector$4.prototype, "translate");
	__RΦ$e$4.m("rt:f", "M$.")(Vector$4.prototype["rotate"]);
	((t, p) => __RΦ$e$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$4.prototype, "rotate");
	__RΦ$e$4.m("rt:p", [{ n: "angle", t: () => __RΦ$e$4.a(15), v: null }])(Vector$4.prototype, "rotate");
	__RΦ$e$4.m("rt:f", "M$.")(Vector$4.prototype, "rotate");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(1627))(Vector$4.prototype, "rotate");
	__RΦ$e$4.m("rt:f", "M$.")(Vector$4.prototype["scale"]);
	((t, p) => __RΦ$e$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$4.prototype, "scale");
	__RΦ$e$4.m("rt:p", [{ n: "scale", t: () => __RΦ$e$4.a(15), v: null }])(Vector$4.prototype, "scale");
	__RΦ$e$4.m("rt:f", "M$.")(Vector$4.prototype, "scale");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(1627))(Vector$4.prototype, "scale");
	__RΦ$e$4.m("rt:f", "M$")(Vector$4.prototype["multiply"]);
	((t, p) => __RΦ$e$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$4.prototype, "multiply");
	__RΦ$e$4.m("rt:p", [{ n: "vector", t: () => __RΦ$e$4.a(1627), v: null }])(Vector$4.prototype, "multiply");
	__RΦ$e$4.m("rt:f", "M$")(Vector$4.prototype, "multiply");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(1627))(Vector$4.prototype, "multiply");
	__RΦ$e$4.m("rt:f", "M$")(Vector$4.prototype["mod"]);
	((t, p) => __RΦ$e$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$4.prototype, "mod");
	__RΦ$e$4.m("rt:p", [{ n: "vector", t: () => __RΦ$e$4.a(1627), v: null }])(Vector$4.prototype, "mod");
	__RΦ$e$4.m("rt:f", "M$")(Vector$4.prototype, "mod");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(1627))(Vector$4.prototype, "mod");
	__RΦ$e$4.m("rt:f", "M$.")(Vector$4.prototype["clone"]);
	((t, p) => __RΦ$e$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$4.prototype, "clone");
	__RΦ$e$4.m("rt:p", [])(Vector$4.prototype, "clone");
	__RΦ$e$4.m("rt:f", "M$.")(Vector$4.prototype, "clone");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(1627))(Vector$4.prototype, "clone");
	__RΦ$e$4.m("rt:f", "M$.")(Vector$4.prototype["toArray"]);
	((t, p) => __RΦ$e$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$4.prototype, "toArray");
	__RΦ$e$4.m("rt:p", [])(Vector$4.prototype, "toArray");
	__RΦ$e$4.m("rt:f", "M$.")(Vector$4.prototype, "toArray");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(1636))(Vector$4.prototype, "toArray");
	__RΦ$e$4.m("rt:f", "M$.")(Vector$4.prototype["toString"]);
	((t, p) => __RΦ$e$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$4.prototype, "toString");
	__RΦ$e$4.m("rt:p", [{ n: "digits", t: () => __RΦ$e$4.a(15), v: function () { return 2; } }])(Vector$4.prototype, "toString");
	__RΦ$e$4.m("rt:f", "M$.")(Vector$4.prototype, "toString");
	__RΦ$e$4.m("rt:t", () => __RΦ$e$4.a(14))(Vector$4.prototype, "toString");

	const __RΦ$d$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$d$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$d$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$d$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	class Angle$4 {
	    /**
	     * Конвертация угла из радиан в градусы.
	     * @param value
	     */
	    static toDegree(value) {
	        return value / Math.PI * 180;
	    }
	    /**
	     * Конвертация угла из градусов в радианы.
	     * @param value
	     */
	    static toRadian(value) {
	        return value * Math.PI / 180;
	    }
	}
	(t => __RΦ$d$5.t[1638] = t)(Angle$4);
	__RΦ$d$5.m("rt:SP", [])(Angle$4);
	__RΦ$d$5.m("rt:P", [])(Angle$4);
	__RΦ$d$5.m("rt:Sm", ["toDegree", "toRadian"])(Angle$4);
	__RΦ$d$5.m("rt:m", [])(Angle$4);
	__RΦ$d$5.m("rt:f", "Ce")(Angle$4);
	__RΦ$d$5.m("rt:f", "M$S.")(Angle$4["toDegree"]);
	((t, p) => __RΦ$d$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle$4, "toDegree");
	__RΦ$d$5.m("rt:p", [{ n: "value", t: () => __RΦ$d$5.a(15), v: null }])(Angle$4, "toDegree");
	__RΦ$d$5.m("rt:f", "M$S.")(Angle$4, "toDegree");
	__RΦ$d$5.m("rt:t", () => __RΦ$d$5.a(15))(Angle$4, "toDegree");
	__RΦ$d$5.m("rt:f", "M$S.")(Angle$4["toRadian"]);
	((t, p) => __RΦ$d$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle$4, "toRadian");
	__RΦ$d$5.m("rt:p", [{ n: "value", t: () => __RΦ$d$5.a(15), v: null }])(Angle$4, "toRadian");
	__RΦ$d$5.m("rt:f", "M$S.")(Angle$4, "toRadian");
	__RΦ$d$5.m("rt:t", () => __RΦ$d$5.a(15))(Angle$4, "toRadian");

	const __RΦ$c$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$c$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$c$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$c$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [151]: { LΦ: t => Object }, [152]: { LΦ: t => Object } } };
	var IΦdefault$4$4 = { name: "IKeyValueObject", prototype: {}, identity: Symbol("IKeyValueObject (interface)") };
	(t => __RΦ$c$5.t[153] = t)(IΦdefault$4$4);
	__RΦ$c$5.m("rt:P", ["key", "value"])(IΦdefault$4$4);
	__RΦ$c$5.m("rt:m", [])(IΦdefault$4$4);
	__RΦ$c$5.m("rt:f", "Ie")(IΦdefault$4$4);
	__RΦ$c$5.m("rt:t", () => __RΦ$c$5.a(151))(IΦdefault$4$4.prototype, "key");
	__RΦ$c$5.m("rt:f", "P")(IΦdefault$4$4.prototype, "key");
	__RΦ$c$5.m("rt:t", () => __RΦ$c$5.a(152))(IΦdefault$4$4.prototype, "value");
	__RΦ$c$5.m("rt:f", "P")(IΦdefault$4$4.prototype, "value");
	__RΦ$c$5.m("rt:t", () => __RΦ$c$5.a(151))(IΦdefault$4$4.prototype, "key");
	__RΦ$c$5.m("rt:f", "P")(IΦdefault$4$4.prototype, "key");
	__RΦ$c$5.m("rt:t", () => __RΦ$c$5.a(152))(IΦdefault$4$4.prototype, "value");
	__RΦ$c$5.m("rt:f", "P")(IΦdefault$4$4.prototype, "value");

	const __RΦ$b$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$b$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$b$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$b$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1828]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$5.a(156), p: [__RΦ$b$5.a(1826), __RΦ$b$5.a(1827)] }) }, [156]: { LΦ: t => Map }, [1826]: { LΦ: t => Object }, [1827]: { LΦ: t => Object }, [1832]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$5.a(1836) }) }, [1836]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$5.a(153), p: [__RΦ$b$5.a(1826), __RΦ$b$5.a(1835)] }) }, [153]: { LΦ: t => IΦdefault$4$4 }, [1835]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b$5.a(10), __RΦ$b$5.a(1827)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1839]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b$5.a(1840), p: [__RΦ$b$5.a(1837), __RΦ$b$5.a(1838)] }) }, [1840]: { LΦ: t => Object }, [1837]: { LΦ: t => Object }, [1838]: { LΦ: t => Object }, [1844]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$5.a(1846) }) }, [1846]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$5.a(153), p: [__RΦ$b$5.a(1837), __RΦ$b$5.a(1838)] }) }, [1663]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b$5.a(1656), __RΦ$b$5.a(1661)] }) }, [1656]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$5.a(156), p: [__RΦ$b$5.a(1645), __RΦ$b$5.a(1646)] }) }, [1645]: { LΦ: t => Object }, [1646]: { LΦ: t => Object }, [1661]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b$5.a(1662), p: [__RΦ$b$5.a(1645), __RΦ$b$5.a(1646)] }) }, [1662]: { LΦ: t => Object }, [1647]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$5.a(1650) }) }, [1650]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$5.a(153), p: [__RΦ$b$5.a(1645), __RΦ$b$5.a(1646)] }) }, [15]: { LΦ: t => Number } } };
	/**
	 * Конвертация разнообразных значений.
	 */
	class Convert$4 {
	    static toArray(object) {
	        const result = [];
	        if (object instanceof Map) {
	            for (const [key, value] of object) {
	                result.push({ key, value });
	            }
	        }
	        else {
	            for (const key in object) {
	                if (!object.hasOwnProperty(key))
	                    continue;
	                result.push({ key, value: Reflect.get(object, key) });
	            }
	        }
	        return result;
	    }
	    /**
	     * Конвертировать миллисекунды в секунды.
	     * @param millisecond
	     */
	    static toSecond(millisecond) {
	        return millisecond / 1000;
	    }
	}
	(t => __RΦ$b$5.t[1824] = t)(Convert$4);
	__RΦ$b$5.m("rt:SP", [])(Convert$4);
	__RΦ$b$5.m("rt:P", [])(Convert$4);
	__RΦ$b$5.m("rt:Sm", ["toArray", "toArray", "toArray", "toSecond"])(Convert$4);
	__RΦ$b$5.m("rt:m", [])(Convert$4);
	__RΦ$b$5.m("rt:f", "Ce")(Convert$4);
	__RΦ$b$5.m("rt:f", "M$S")(Convert$4["toArray"]);
	((t, p) => __RΦ$b$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$4, "toArray");
	__RΦ$b$5.m("rt:p", [{ n: "object", t: () => __RΦ$b$5.a(1828), v: null }])(Convert$4, "toArray");
	__RΦ$b$5.m("rt:f", "M$S")(Convert$4, "toArray");
	__RΦ$b$5.m("rt:t", () => __RΦ$b$5.a(1832))(Convert$4, "toArray");
	__RΦ$b$5.m("rt:f", "M$S")(Convert$4["toArray"]);
	((t, p) => __RΦ$b$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$4, "toArray");
	__RΦ$b$5.m("rt:p", [{ n: "object", t: () => __RΦ$b$5.a(1839), v: null }])(Convert$4, "toArray");
	__RΦ$b$5.m("rt:f", "M$S")(Convert$4, "toArray");
	__RΦ$b$5.m("rt:t", () => __RΦ$b$5.a(1844))(Convert$4, "toArray");
	__RΦ$b$5.m("rt:f", "M$S")(Convert$4["toArray"]);
	((t, p) => __RΦ$b$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$4, "toArray");
	__RΦ$b$5.m("rt:p", [{ n: "object", t: () => __RΦ$b$5.a(1663), v: null }])(Convert$4, "toArray");
	__RΦ$b$5.m("rt:f", "M$S")(Convert$4, "toArray");
	__RΦ$b$5.m("rt:t", () => __RΦ$b$5.a(1647))(Convert$4, "toArray");
	__RΦ$b$5.m("rt:f", "M$S.")(Convert$4["toSecond"]);
	((t, p) => __RΦ$b$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$4, "toSecond");
	__RΦ$b$5.m("rt:p", [{ n: "millisecond", t: () => __RΦ$b$5.a(15), v: null }])(Convert$4, "toSecond");
	__RΦ$b$5.m("rt:f", "M$S.")(Convert$4, "toSecond");
	__RΦ$b$5.m("rt:t", () => __RΦ$b$5.a(15))(Convert$4, "toSecond");

	const __RΦ$a$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$a$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$a$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$a$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1873]: { LΦ: t => 60 }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [15]: { LΦ: t => Number }, [1869]: { LΦ: t => "update" }, [1875]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$5.a(4) }] }) }, [1850]: { RΦ: t => ({ TΦ: "t" }) }, [1871]: { LΦ: t => "render" }, [1876]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$5.a(4) }] }) }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$a$5.a(14), __RΦ$a$5.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1852]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$5.a(4) }] }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * http://gs-studio.com/news-about-it/30703----javascript
	 * https://eatdog.com.ua/assets/gamedev-slides/
	 * https://www.youtube.com/watch?v=-gsjAz9jR3Y
	 */
	class GameLoop$4 {
	    framePerSecond;
	    eventEmitter = new EventEmitter__default$4["default"];
	    time = 0;
	    timeInterval = 0;
	    renderTime = 0;
	    renderTimeInterval = 0;
	    /**
	     * Текущий FPS отрисовки игровой сцены.
	     */
	    get renderFramePerSecond() {
	        return 1 / (this.renderTimeInterval / 1000);
	    }
	    /**
	     * Временной шаг, с которым вызывается функция update для вычисления игровой логики.
	     * Измеряется в миллисекундах.
	     */
	    get step() {
	        return (1 / this.framePerSecond) / 1000;
	    }
	    constructor(
	    /**
	     * Частота обновления игровой логики (генерации события update).
	     * @private
	     */
	    framePerSecond = 60 // TODO Переименовать в updatePerSecond?
	    ) {
	        this.framePerSecond = framePerSecond;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	    start() {
	        this.time = performance.now();
	        this.timeInterval = 0;
	        requestAnimationFrame(this.frame.bind(this));
	    }
	    stop() {
	    }
	    pause() {
	    }
	    frame() {
	        // Обработка логики игры.
	        {
	            const currentTime = performance.now();
	            // Исправление проблемы неактивных вкладок.
	            // Разрешить максимальную задержку между вызовами не более, чем 1 секунда.
	            this.timeInterval = this.timeInterval + Math.min(1000, currentTime - this.time);
	            while (this.timeInterval > this.step) {
	                this.timeInterval = this.timeInterval - this.step;
	                this.eventEmitter.emit('update', this.step);
	            }
	            this.time = currentTime;
	        }
	        // Обработка отрисовки сцены игры.
	        {
	            const renderCurrentTime = performance.now();
	            this.renderTimeInterval = renderCurrentTime - this.renderTime;
	            this.renderTime = renderCurrentTime;
	            this.eventEmitter.emit('render', this.timeInterval);
	        }
	        requestAnimationFrame(this.frame.bind(this));
	    }
	}
	(t => __RΦ$a$5.t[1849] = t)(GameLoop$4);
	__RΦ$a$5.m("rt:SP", [])(GameLoop$4);
	__RΦ$a$5.m("rt:P", ["eventEmitter", "time", "timeInterval", "renderTime", "renderTimeInterval", "renderFramePerSecond", "step", "framePerSecond"])(GameLoop$4);
	__RΦ$a$5.m("rt:Sm", [])(GameLoop$4);
	__RΦ$a$5.m("rt:m", ["on", "on", "on", "start", "stop", "pause", "frame"])(GameLoop$4);
	__RΦ$a$5.m("rt:p", [{ n: "framePerSecond", t: () => __RΦ$a$5.a(1873), v: function () { return 60 // TODO Переименовать в updatePerSecond?
	        ; }, f: "#R" }])(GameLoop$4);
	__RΦ$a$5.m("rt:i", [() => undefined, () => undefined])(GameLoop$4);
	__RΦ$a$5.m("rt:f", "Ce")(GameLoop$4);
	__RΦ$a$5.m("rt:t", () => __RΦ$a$5.a(4))(GameLoop$4.prototype, "eventEmitter");
	__RΦ$a$5.m("rt:f", "P#R")(GameLoop$4.prototype, "eventEmitter");
	__RΦ$a$5.m("rt:t", () => __RΦ$a$5.a(15))(GameLoop$4.prototype, "time");
	__RΦ$a$5.m("rt:f", "P#")(GameLoop$4.prototype, "time");
	__RΦ$a$5.m("rt:t", () => __RΦ$a$5.a(15))(GameLoop$4.prototype, "timeInterval");
	__RΦ$a$5.m("rt:f", "P#")(GameLoop$4.prototype, "timeInterval");
	__RΦ$a$5.m("rt:t", () => __RΦ$a$5.a(15))(GameLoop$4.prototype, "renderTime");
	__RΦ$a$5.m("rt:f", "P#")(GameLoop$4.prototype, "renderTime");
	__RΦ$a$5.m("rt:t", () => __RΦ$a$5.a(15))(GameLoop$4.prototype, "renderTimeInterval");
	__RΦ$a$5.m("rt:f", "P#")(GameLoop$4.prototype, "renderTimeInterval");
	__RΦ$a$5.m("rt:t", () => __RΦ$a$5.a(15))(GameLoop$4.prototype, "renderFramePerSecond");
	__RΦ$a$5.m("rt:f", "P$")(GameLoop$4.prototype, "renderFramePerSecond");
	__RΦ$a$5.m("rt:t", () => __RΦ$a$5.a(15))(GameLoop$4.prototype, "step");
	__RΦ$a$5.m("rt:f", "P$")(GameLoop$4.prototype, "step");
	__RΦ$a$5.m("rt:f", "M")(GameLoop$4.prototype["on"]);
	((t, p) => __RΦ$a$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$4.prototype, "on");
	__RΦ$a$5.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$5.a(1869), v: null }, { n: "update", t: () => __RΦ$a$5.a(1875), v: null }])(GameLoop$4.prototype, "on");
	__RΦ$a$5.m("rt:f", "M")(GameLoop$4.prototype, "on");
	__RΦ$a$5.m("rt:t", () => __RΦ$a$5.a(1850))(GameLoop$4.prototype, "on");
	__RΦ$a$5.m("rt:f", "M")(GameLoop$4.prototype["on"]);
	((t, p) => __RΦ$a$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$4.prototype, "on");
	__RΦ$a$5.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$5.a(1871), v: null }, { n: "render", t: () => __RΦ$a$5.a(1876), v: null }])(GameLoop$4.prototype, "on");
	__RΦ$a$5.m("rt:f", "M")(GameLoop$4.prototype, "on");
	__RΦ$a$5.m("rt:t", () => __RΦ$a$5.a(1850))(GameLoop$4.prototype, "on");
	__RΦ$a$5.m("rt:f", "M")(GameLoop$4.prototype["on"]);
	((t, p) => __RΦ$a$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$4.prototype, "on");
	__RΦ$a$5.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$5.a(143), v: null }, { n: "listener", t: () => __RΦ$a$5.a(1852), v: null }])(GameLoop$4.prototype, "on");
	__RΦ$a$5.m("rt:f", "M")(GameLoop$4.prototype, "on");
	__RΦ$a$5.m("rt:t", () => __RΦ$a$5.a(1850))(GameLoop$4.prototype, "on");
	__RΦ$a$5.m("rt:f", "M$")(GameLoop$4.prototype["start"]);
	((t, p) => __RΦ$a$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$4.prototype, "start");
	__RΦ$a$5.m("rt:p", [])(GameLoop$4.prototype, "start");
	__RΦ$a$5.m("rt:f", "M$")(GameLoop$4.prototype, "start");
	__RΦ$a$5.m("rt:t", () => __RΦ$a$5.a(23))(GameLoop$4.prototype, "start");
	__RΦ$a$5.m("rt:f", "M$")(GameLoop$4.prototype["stop"]);
	((t, p) => __RΦ$a$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$4.prototype, "stop");
	__RΦ$a$5.m("rt:p", [])(GameLoop$4.prototype, "stop");
	__RΦ$a$5.m("rt:f", "M$")(GameLoop$4.prototype, "stop");
	__RΦ$a$5.m("rt:t", () => __RΦ$a$5.a(23))(GameLoop$4.prototype, "stop");
	__RΦ$a$5.m("rt:f", "M$")(GameLoop$4.prototype["pause"]);
	((t, p) => __RΦ$a$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$4.prototype, "pause");
	__RΦ$a$5.m("rt:p", [])(GameLoop$4.prototype, "pause");
	__RΦ$a$5.m("rt:f", "M$")(GameLoop$4.prototype, "pause");
	__RΦ$a$5.m("rt:t", () => __RΦ$a$5.a(23))(GameLoop$4.prototype, "pause");
	__RΦ$a$5.m("rt:f", "M#.")(GameLoop$4.prototype["frame"]);
	((t, p) => __RΦ$a$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$4.prototype, "frame");
	__RΦ$a$5.m("rt:p", [])(GameLoop$4.prototype, "frame");
	__RΦ$a$5.m("rt:f", "M#.")(GameLoop$4.prototype, "frame");
	__RΦ$a$5.m("rt:t", () => __RΦ$a$5.a(23))(GameLoop$4.prototype, "frame");

	const __RΦ$9$1$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$9$1$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$9$1$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$9$1$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1880]: { RΦ: t => ({ TΦ: "g", t: __RΦ$9$1$2.a(156), p: [__RΦ$9$1$2.a(14), __RΦ$9$1$2.a(21)] }) }, [156]: { LΦ: t => Map }, [14]: { LΦ: t => String }, [21]: { LΦ: t => Boolean }, [1883]: { LΦ: t => KeyboardEvent }, [1890]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$1$2.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1893]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$1$2.a(4) }] }) }, [1897]: { LΦ: t => Function }, [1896]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$1$2.a(4) }] }) }, [1898]: { LΦ: t => Function } } };
	/**
	 * Вместо KeyUpDownProcessor используйте Shortcut.
	 * @deprecated
	 * @link http://khusamov.github.io/tutorial/csharp/key-down-up-process
	 */
	class KeyUpDownProcessor$4 {
	    /**
	     * Данный словарь хранит информацию о том, была ли нажата клавиша.
	     * В качестве ключа выступает номер клавиши,
	     * а значение это флаг (была или не была нажата клавиша).
	     * @private
	     * @link https://learn.javascript.ru/keyboard-events
	     */
	    static #theKeyWasDown = new Map;
	    static onKeyDown(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.#theKeyWasDown.has(keyCode)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.#theKeyWasDown.set(keyCode, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.#theKeyWasDown.get(keyCode)) {
	            // Помечаем что она нажата.
	            this.#theKeyWasDown.set(keyCode, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            action();
	        }
	    }
	    static onKeyUp(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Помечаем что она уже не нажата.
	        this.#theKeyWasDown.set(keyCode, false);
	        // Выполняем действие при отжатии клавиши.
	        action();
	    }
	}
	(t => __RΦ$9$1$2.t[1878] = t)(KeyUpDownProcessor$4);
	__RΦ$9$1$2.m("rt:SP", ["#theKeyWasDown"])(KeyUpDownProcessor$4);
	__RΦ$9$1$2.m("rt:P", [])(KeyUpDownProcessor$4);
	__RΦ$9$1$2.m("rt:Sm", ["onKeyDown", "onKeyUp"])(KeyUpDownProcessor$4);
	__RΦ$9$1$2.m("rt:m", [])(KeyUpDownProcessor$4);
	__RΦ$9$1$2.m("rt:f", "Ce")(KeyUpDownProcessor$4);
	__RΦ$9$1$2.m("rt:t", () => __RΦ$9$1$2.a(1880))(KeyUpDownProcessor$4, "#theKeyWasDown");
	__RΦ$9$1$2.m("rt:f", "P")(KeyUpDownProcessor$4, "#theKeyWasDown");
	__RΦ$9$1$2.m("rt:f", "M$S.")(KeyUpDownProcessor$4["onKeyDown"]);
	((t, p) => __RΦ$9$1$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor$4, "onKeyDown");
	__RΦ$9$1$2.m("rt:p", [{ n: "event", t: () => __RΦ$9$1$2.a(1883), v: null }, { n: "action", t: () => __RΦ$9$1$2.a(1890), v: null }])(KeyUpDownProcessor$4, "onKeyDown");
	__RΦ$9$1$2.m("rt:f", "M$S.")(KeyUpDownProcessor$4, "onKeyDown");
	__RΦ$9$1$2.m("rt:t", () => __RΦ$9$1$2.a(23))(KeyUpDownProcessor$4, "onKeyDown");
	__RΦ$9$1$2.m("rt:f", "M$S.")(KeyUpDownProcessor$4["onKeyUp"]);
	((t, p) => __RΦ$9$1$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor$4, "onKeyUp");
	__RΦ$9$1$2.m("rt:p", [{ n: "event", t: () => __RΦ$9$1$2.a(1883), v: null }, { n: "action", t: () => __RΦ$9$1$2.a(1890), v: null }])(KeyUpDownProcessor$4, "onKeyUp");
	__RΦ$9$1$2.m("rt:f", "M$S.")(KeyUpDownProcessor$4, "onKeyUp");
	__RΦ$9$1$2.m("rt:t", () => __RΦ$9$1$2.a(23))(KeyUpDownProcessor$4, "onKeyUp");
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyDown$4(listener) {
	    return __RΦ$9$1$2.f((event) => {
	        KeyUpDownProcessor$4.onKeyDown(event, __RΦ$9$1$2.f(() => {
	            listener(event);
	        }, [__RΦ$9$1$2.m("rt:p", []), __RΦ$9$1$2.m("rt:f", "F>"), __RΦ$9$1$2.m("rt:t", () => __RΦ$9$1$2.a(23))], ""));
	    }, [__RΦ$9$1$2.m("rt:p", [{ n: "event", t: () => __RΦ$9$1$2.a(1883), v: null }]), __RΦ$9$1$2.m("rt:f", "F>"), __RΦ$9$1$2.m("rt:t", () => __RΦ$9$1$2.a(23))], "");
	}
	__RΦ$9$1$2.m("rt:p", [{ n: "listener", t: () => __RΦ$9$1$2.a(1893), v: null }])(onKeyDown$4);
	__RΦ$9$1$2.m("rt:f", "F")(onKeyDown$4);
	__RΦ$9$1$2.m("rt:t", () => __RΦ$9$1$2.a(1897))(onKeyDown$4);
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyUp$4(listener) {
	    return __RΦ$9$1$2.f((event) => {
	        KeyUpDownProcessor$4.onKeyUp(event, __RΦ$9$1$2.f(() => {
	            listener(event);
	        }, [__RΦ$9$1$2.m("rt:p", []), __RΦ$9$1$2.m("rt:f", "F>"), __RΦ$9$1$2.m("rt:t", () => __RΦ$9$1$2.a(23))], ""));
	    }, [__RΦ$9$1$2.m("rt:p", [{ n: "event", t: () => __RΦ$9$1$2.a(1883), v: null }]), __RΦ$9$1$2.m("rt:f", "F>"), __RΦ$9$1$2.m("rt:t", () => __RΦ$9$1$2.a(23))], "");
	}
	__RΦ$9$1$2.m("rt:p", [{ n: "listener", t: () => __RΦ$9$1$2.a(1896), v: null }])(onKeyUp$4);
	__RΦ$9$1$2.m("rt:f", "F")(onKeyUp$4);
	__RΦ$9$1$2.m("rt:t", () => __RΦ$9$1$2.a(1898))(onKeyUp$4);

	const __RΦ$8$1$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$8$1$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$8$1$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$8$1$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$3$4 = { name: "IDisposable", prototype: {}, identity: Symbol("IDisposable (interface)") };
	(t => __RΦ$8$1$2.t[147] = t)(IΦdefault$3$4);
	__RΦ$8$1$2.m("rt:P", [])(IΦdefault$3$4);
	__RΦ$8$1$2.m("rt:m", ["dispose"])(IΦdefault$3$4);
	__RΦ$8$1$2.m("rt:f", "Ie")(IΦdefault$3$4);
	__RΦ$8$1$2.m("rt:p", [])(IΦdefault$3$4.prototype, "dispose");
	__RΦ$8$1$2.m("rt:f", "M")(IΦdefault$3$4.prototype, "dispose");
	__RΦ$8$1$2.m("rt:t", () => __RΦ$8$1$2.a(23))(IΦdefault$3$4.prototype, "dispose");
	__RΦ$8$1$2.m("rt:p", [])(IΦdefault$3$4.prototype, "dispose");
	__RΦ$8$1$2.m("rt:f", "M")(IΦdefault$3$4.prototype, "dispose");
	__RΦ$8$1$2.m("rt:t", () => __RΦ$8$1$2.a(23))(IΦdefault$3$4.prototype, "dispose");

	const __RΦ$7$1$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$7$1$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$7$1$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$7$1$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1899]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$7$1$2.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) } } };
	var IΦdefault$2$4 = { name: "IKeyboardListeners", prototype: {}, identity: Symbol("IKeyboardListeners (interface)") };
	(t => __RΦ$7$1$2.t[1900] = t)(IΦdefault$2$4);
	__RΦ$7$1$2.m("rt:P", ["down", "up"])(IΦdefault$2$4);
	__RΦ$7$1$2.m("rt:m", [])(IΦdefault$2$4);
	__RΦ$7$1$2.m("rt:f", "Ie")(IΦdefault$2$4);
	__RΦ$7$1$2.m("rt:t", () => __RΦ$7$1$2.a(1899))(IΦdefault$2$4.prototype, "down");
	__RΦ$7$1$2.m("rt:f", "P")(IΦdefault$2$4.prototype, "down");
	__RΦ$7$1$2.m("rt:t", () => __RΦ$7$1$2.a(1899))(IΦdefault$2$4.prototype, "up");
	__RΦ$7$1$2.m("rt:f", "P")(IΦdefault$2$4.prototype, "up");
	__RΦ$7$1$2.m("rt:t", () => __RΦ$7$1$2.a(1899))(IΦdefault$2$4.prototype, "down");
	__RΦ$7$1$2.m("rt:f", "P")(IΦdefault$2$4.prototype, "down");
	__RΦ$7$1$2.m("rt:t", () => __RΦ$7$1$2.a(1899))(IΦdefault$2$4.prototype, "up");
	__RΦ$7$1$2.m("rt:f", "P")(IΦdefault$2$4.prototype, "up");

	const __RΦ$6$1$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$6$1$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$6$1$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$6$1$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [709]: { LΦ: t => Object }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1901]: { TΦ: "5", name: "default" }, [2154]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$1$2.a(156), p: [__RΦ$6$1$2.a(14), __RΦ$6$1$2.a(1900)] }) }, [156]: { LΦ: t => Map }, [1900]: { LΦ: t => IΦdefault$2$4 }, [1899]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$6$1$2.a(4) }] }) }, [1880]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$1$2.a(156), p: [__RΦ$6$1$2.a(14), __RΦ$6$1$2.a(21)] }) }, [21]: { LΦ: t => Boolean }, [147]: { LΦ: t => IΦdefault$3$4 }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1883]: { LΦ: t => KeyboardEvent } } };
	const codeOf$4 = __RΦ$6$1$2.f((key) => 'Key' + key.toUpperCase(), [__RΦ$6$1$2.m("rt:p", [{ n: "key", t: () => __RΦ$6$1$2.a(14), v: null }]), __RΦ$6$1$2.m("rt:f", "F>"), __RΦ$6$1$2.m("rt:t", () => __RΦ$6$1$2.a(14))], "codeOf");
	class ShortcutDispatcher$4 {
	    static instanceHolder = new Lazy$4(() => new ShortcutDispatcher$4);
	    static get instance() {
	        return this.instanceHolder.value;
	    }
	    host;
	    listeners = new Map;
	    keyDownListenerBinded;
	    keyUpListenerBinded;
	    theKeyWasDown = new Map;
	    constructor(host = document) {
	        this.host = host;
	        this.keyDownListenerBinded = this.keyDownListener.bind(this);
	        this.keyUpListenerBinded = this.keyUpListener.bind(this);
	        this.host.addEventListener('keydown', this.keyDownListenerBinded);
	        this.host.addEventListener('keyup', this.keyUpListenerBinded);
	    }
	    register(key, listeners) {
	        this.listeners.set(key, listeners);
	        return {
	            dispose: __RΦ$6$1$2.f(() => {
	                this.listeners.delete(key);
	                this.theKeyWasDown.delete(codeOf$4(key));
	            }, [__RΦ$6$1$2.m("rt:p", []), __RΦ$6$1$2.m("rt:f", "F>"), __RΦ$6$1$2.m("rt:t", () => __RΦ$6$1$2.a(23))], "dispose")
	        };
	    }
	    keyDownListener(event) {
	        const code = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.theKeyWasDown.has(code)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.theKeyWasDown.set(code, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.theKeyWasDown.get(code)) {
	            // Помечаем что она нажата.
	            this.theKeyWasDown.set(code, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            for (const [key, listeners] of this.listeners.entries()) {
	                if (code === codeOf$4(key)) {
	                    listeners.down(event);
	                }
	            }
	        }
	    }
	    keyUpListener(event) {
	        // Из события извлекаем номер нажатой клавиши.
	        const code = event.code;
	        // Помечаем что она уже не нажата.
	        this.theKeyWasDown.set(code, false);
	        // Выполняем действие при отжатии клавиши.
	        for (const [key, listeners] of this.listeners.entries()) {
	            if (code === codeOf$4(key)) {
	                listeners.up(event);
	            }
	        }
	    }
	    dispose() {
	        this.host.removeEventListener('keydown', this.keyDownListenerBinded);
	        this.host.removeEventListener('keyup', this.keyUpListenerBinded);
	    }
	}
	(t => __RΦ$6$1$2.t[1901] = t)(ShortcutDispatcher$4);
	__RΦ$6$1$2.m("rt:SP", ["instanceHolder", "instance"])(ShortcutDispatcher$4);
	__RΦ$6$1$2.m("rt:P", ["host", "listeners", "keyDownListenerBinded", "keyUpListenerBinded", "theKeyWasDown"])(ShortcutDispatcher$4);
	__RΦ$6$1$2.m("rt:Sm", [])(ShortcutDispatcher$4);
	__RΦ$6$1$2.m("rt:m", ["register", "keyDownListener", "keyUpListener", "dispose"])(ShortcutDispatcher$4);
	__RΦ$6$1$2.m("rt:p", [{ n: "host", t: () => __RΦ$6$1$2.a(709), v: function () { return document; } }])(ShortcutDispatcher$4);
	__RΦ$6$1$2.m("rt:i", [() => undefined])(ShortcutDispatcher$4);
	__RΦ$6$1$2.m("rt:f", "Ce")(ShortcutDispatcher$4);
	__RΦ$6$1$2.m("rt:t", () => __RΦ$6$1$2.a(4))(ShortcutDispatcher$4, "instanceHolder");
	__RΦ$6$1$2.m("rt:f", "P#R")(ShortcutDispatcher$4, "instanceHolder");
	__RΦ$6$1$2.m("rt:t", () => __RΦ$6$1$2.a(1901))(ShortcutDispatcher$4, "instance");
	__RΦ$6$1$2.m("rt:f", "P$")(ShortcutDispatcher$4, "instance");
	__RΦ$6$1$2.m("rt:t", () => __RΦ$6$1$2.a(709))(ShortcutDispatcher$4.prototype, "host");
	__RΦ$6$1$2.m("rt:f", "P#R")(ShortcutDispatcher$4.prototype, "host");
	__RΦ$6$1$2.m("rt:t", () => __RΦ$6$1$2.a(2154))(ShortcutDispatcher$4.prototype, "listeners");
	__RΦ$6$1$2.m("rt:f", "P#R")(ShortcutDispatcher$4.prototype, "listeners");
	__RΦ$6$1$2.m("rt:t", () => __RΦ$6$1$2.a(1899))(ShortcutDispatcher$4.prototype, "keyDownListenerBinded");
	__RΦ$6$1$2.m("rt:f", "P#R")(ShortcutDispatcher$4.prototype, "keyDownListenerBinded");
	__RΦ$6$1$2.m("rt:t", () => __RΦ$6$1$2.a(1899))(ShortcutDispatcher$4.prototype, "keyUpListenerBinded");
	__RΦ$6$1$2.m("rt:f", "P#R")(ShortcutDispatcher$4.prototype, "keyUpListenerBinded");
	__RΦ$6$1$2.m("rt:t", () => __RΦ$6$1$2.a(1880))(ShortcutDispatcher$4.prototype, "theKeyWasDown");
	__RΦ$6$1$2.m("rt:f", "P#R")(ShortcutDispatcher$4.prototype, "theKeyWasDown");
	__RΦ$6$1$2.m("rt:f", "M$")(ShortcutDispatcher$4.prototype["register"]);
	((t, p) => __RΦ$6$1$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$4.prototype, "register");
	__RΦ$6$1$2.m("rt:p", [{ n: "key", t: () => __RΦ$6$1$2.a(14), v: null }, { n: "listeners", t: () => __RΦ$6$1$2.a(1900), v: null }])(ShortcutDispatcher$4.prototype, "register");
	__RΦ$6$1$2.m("rt:f", "M$")(ShortcutDispatcher$4.prototype, "register");
	__RΦ$6$1$2.m("rt:t", () => __RΦ$6$1$2.a(147))(ShortcutDispatcher$4.prototype, "register");
	__RΦ$6$1$2.m("rt:f", "M#.")(ShortcutDispatcher$4.prototype["keyDownListener"]);
	((t, p) => __RΦ$6$1$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$4.prototype, "keyDownListener");
	__RΦ$6$1$2.m("rt:p", [{ n: "event", t: () => __RΦ$6$1$2.a(1883), v: null }])(ShortcutDispatcher$4.prototype, "keyDownListener");
	__RΦ$6$1$2.m("rt:f", "M#.")(ShortcutDispatcher$4.prototype, "keyDownListener");
	__RΦ$6$1$2.m("rt:t", () => __RΦ$6$1$2.a(23))(ShortcutDispatcher$4.prototype, "keyDownListener");
	__RΦ$6$1$2.m("rt:f", "M#.")(ShortcutDispatcher$4.prototype["keyUpListener"]);
	((t, p) => __RΦ$6$1$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$4.prototype, "keyUpListener");
	__RΦ$6$1$2.m("rt:p", [{ n: "event", t: () => __RΦ$6$1$2.a(1883), v: null }])(ShortcutDispatcher$4.prototype, "keyUpListener");
	__RΦ$6$1$2.m("rt:f", "M#.")(ShortcutDispatcher$4.prototype, "keyUpListener");
	__RΦ$6$1$2.m("rt:t", () => __RΦ$6$1$2.a(23))(ShortcutDispatcher$4.prototype, "keyUpListener");
	__RΦ$6$1$2.m("rt:f", "M$.")(ShortcutDispatcher$4.prototype["dispose"]);
	((t, p) => __RΦ$6$1$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$4.prototype, "dispose");
	__RΦ$6$1$2.m("rt:p", [])(ShortcutDispatcher$4.prototype, "dispose");
	__RΦ$6$1$2.m("rt:f", "M$.")(ShortcutDispatcher$4.prototype, "dispose");
	__RΦ$6$1$2.m("rt:t", () => __RΦ$6$1$2.a(23))(ShortcutDispatcher$4.prototype, "dispose");

	const __RΦ$5$1$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$5$1$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$5$1$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$5$1$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [1900]: { LΦ: t => IΦdefault$2$4 }, [147]: { LΦ: t => IΦdefault$3$4 } } };
	class Shortcut$4 {
	    static register(key, listeners) {
	        return ShortcutDispatcher$4.instance.register(key, listeners);
	    }
	}
	(t => __RΦ$5$1$2.t[2183] = t)(Shortcut$4);
	__RΦ$5$1$2.m("rt:SP", [])(Shortcut$4);
	__RΦ$5$1$2.m("rt:P", [])(Shortcut$4);
	__RΦ$5$1$2.m("rt:Sm", ["register"])(Shortcut$4);
	__RΦ$5$1$2.m("rt:m", [])(Shortcut$4);
	__RΦ$5$1$2.m("rt:f", "Ce")(Shortcut$4);
	__RΦ$5$1$2.m("rt:f", "M$S")(Shortcut$4["register"]);
	((t, p) => __RΦ$5$1$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Shortcut$4, "register");
	__RΦ$5$1$2.m("rt:p", [{ n: "key", t: () => __RΦ$5$1$2.a(14), v: null }, { n: "listeners", t: () => __RΦ$5$1$2.a(1900), v: null }])(Shortcut$4, "register");
	__RΦ$5$1$2.m("rt:f", "M$S")(Shortcut$4, "register");
	__RΦ$5$1$2.m("rt:t", () => __RΦ$5$1$2.a(147))(Shortcut$4, "register");

	const __RΦ$4$1$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$4$1$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$4$1$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$4$1$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [166]: { RΦ: t => ({ TΦ: "[", e: __RΦ$4$1$2.a(165) }) }, [165]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [168]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$4$1$2.a(10), __RΦ$4$1$2.a(167)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [167]: { LΦ: t => Object }, [177]: { RΦ: t => ({ TΦ: "g", t: __RΦ$4$1$2.a(77), p: [__RΦ$4$1$2.a(167)] }) }, [77]: { LΦ: t => Object } } };
	var IΦdefault$1$4 = { name: "IQueue", prototype: {}, identity: Symbol("IQueue (interface)") };
	(t => __RΦ$4$1$2.t[178] = t)(IΦdefault$1$4);
	__RΦ$4$1$2.m("rt:P", ["items"])(IΦdefault$1$4);
	__RΦ$4$1$2.m("rt:m", ["enqueue", "dequeue"])(IΦdefault$1$4);
	__RΦ$4$1$2.m("rt:f", "Ie")(IΦdefault$1$4);
	__RΦ$4$1$2.m("rt:p", [{ n: "items", t: () => __RΦ$4$1$2.a(166), v: null }])(IΦdefault$1$4.prototype, "enqueue");
	__RΦ$4$1$2.m("rt:f", "M")(IΦdefault$1$4.prototype, "enqueue");
	__RΦ$4$1$2.m("rt:t", () => __RΦ$4$1$2.a(23))(IΦdefault$1$4.prototype, "enqueue");
	__RΦ$4$1$2.m("rt:p", [])(IΦdefault$1$4.prototype, "dequeue");
	__RΦ$4$1$2.m("rt:f", "M")(IΦdefault$1$4.prototype, "dequeue");
	__RΦ$4$1$2.m("rt:t", () => __RΦ$4$1$2.a(168))(IΦdefault$1$4.prototype, "dequeue");
	__RΦ$4$1$2.m("rt:t", () => __RΦ$4$1$2.a(177))(IΦdefault$1$4.prototype, "items");
	__RΦ$4$1$2.m("rt:f", "PR")(IΦdefault$1$4.prototype, "items");
	__RΦ$4$1$2.m("rt:p", [{ n: "items", t: () => __RΦ$4$1$2.a(166), v: null }])(IΦdefault$1$4.prototype, "enqueue");
	__RΦ$4$1$2.m("rt:f", "M")(IΦdefault$1$4.prototype, "enqueue");
	__RΦ$4$1$2.m("rt:t", () => __RΦ$4$1$2.a(23))(IΦdefault$1$4.prototype, "enqueue");
	__RΦ$4$1$2.m("rt:p", [])(IΦdefault$1$4.prototype, "dequeue");
	__RΦ$4$1$2.m("rt:f", "M")(IΦdefault$1$4.prototype, "dequeue");
	__RΦ$4$1$2.m("rt:t", () => __RΦ$4$1$2.a(168))(IΦdefault$1$4.prototype, "dequeue");
	__RΦ$4$1$2.m("rt:t", () => __RΦ$4$1$2.a(177))(IΦdefault$1$4.prototype, "items");
	__RΦ$4$1$2.m("rt:f", "PR")(IΦdefault$1$4.prototype, "items");

	const __RΦ$3$1$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$3$1$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$3$1$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$3$1$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [185]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$1$2.a(182) }) }, [182]: { LΦ: t => Object }, [190]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$1$2.a(180) }) }, [180]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [227]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$3$1$2.a(10), __RΦ$3$1$2.a(182)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [228]: { RΦ: t => ({ TΦ: "g", t: __RΦ$3$1$2.a(77), p: [__RΦ$3$1$2.a(182)] }) }, [77]: { LΦ: t => Object } } };
	/**
	 * О́чередь — абстрактный тип данных с дисциплиной доступа к элементам «первый пришёл — первый вышел»
	 * (FIFO, англ. first in, first out).
	 *
	 * Добавление элемента (принято обозначать словом enqueue — поставить в очередь) возможно лишь
	 * в конец очереди, выборка — только из начала очереди (что принято называть словом dequeue — убрать из очереди),
	 * при этом выбранный элемент из очереди удаляется.
	 *
	 * @link https://bit.ly/3tPM13G
	 */
	class Queue$4 {
	    storage = [];
	    enqueue(...items) {
	        this.storage.push(...items);
	    }
	    dequeue() {
	        return this.storage.shift();
	    }
	    get items() {
	        return this.storage;
	    }
	}
	(t => __RΦ$3$1$2.t[181] = t)(Queue$4);
	__RΦ$3$1$2.m("rt:SP", [])(Queue$4);
	__RΦ$3$1$2.m("rt:P", ["storage", "items"])(Queue$4);
	__RΦ$3$1$2.m("rt:Sm", [])(Queue$4);
	__RΦ$3$1$2.m("rt:m", ["enqueue", "dequeue"])(Queue$4);
	__RΦ$3$1$2.m("rt:i", [() => undefined])(Queue$4);
	__RΦ$3$1$2.m("rt:f", "Ce")(Queue$4);
	__RΦ$3$1$2.m("rt:t", () => __RΦ$3$1$2.a(185))(Queue$4.prototype, "storage");
	__RΦ$3$1$2.m("rt:f", "P#")(Queue$4.prototype, "storage");
	__RΦ$3$1$2.m("rt:f", "M$")(Queue$4.prototype["enqueue"]);
	((t, p) => __RΦ$3$1$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue$4.prototype, "enqueue");
	__RΦ$3$1$2.m("rt:p", [{ n: "items", t: () => __RΦ$3$1$2.a(190), v: null }])(Queue$4.prototype, "enqueue");
	__RΦ$3$1$2.m("rt:f", "M$")(Queue$4.prototype, "enqueue");
	__RΦ$3$1$2.m("rt:t", () => __RΦ$3$1$2.a(23))(Queue$4.prototype, "enqueue");
	__RΦ$3$1$2.m("rt:f", "M$")(Queue$4.prototype["dequeue"]);
	((t, p) => __RΦ$3$1$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue$4.prototype, "dequeue");
	__RΦ$3$1$2.m("rt:p", [])(Queue$4.prototype, "dequeue");
	__RΦ$3$1$2.m("rt:f", "M$")(Queue$4.prototype, "dequeue");
	__RΦ$3$1$2.m("rt:t", () => __RΦ$3$1$2.a(227))(Queue$4.prototype, "dequeue");
	__RΦ$3$1$2.m("rt:t", () => __RΦ$3$1$2.a(228))(Queue$4.prototype, "items");
	__RΦ$3$1$2.m("rt:f", "P$")(Queue$4.prototype, "items");

	const __RΦ$2$1$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$2$1$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$2$1$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$2$1$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [407]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$1$3.a(404) }) }, [404]: { LΦ: t => Object }, [273]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$3.a(178), p: [__RΦ$2$1$3.a(230)] }) }, [178]: { LΦ: t => IΦdefault$1$4 }, [230]: { LΦ: t => Object }, [406]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$3.a(403), p: [__RΦ$2$1$3.a(230)] }) }, [403]: { TΦ: "5", name: "ILog" }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [622]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$3.a(178), p: [__RΦ$2$1$3.a(621)] }) }, [621]: { LΦ: t => Object }, [628]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$2$1$3.a(622) }, { t: __RΦ$2$1$3.a(627) }] }) }, [627]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$3.a(229), p: [__RΦ$2$1$3.a(621)] }) }, [229]: { TΦ: "5", name: "default" }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$1$3.a(14), __RΦ$2$1$3.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [397]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [629]: { LΦ: t => Function }, [408]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$1$3.a(230) }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [402]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [630]: { LΦ: t => Function }, [428]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$1$3.a(10), __RΦ$2$1$3.a(230)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	var IΦILog$4 = { name: "ILog", prototype: {}, identity: Symbol("ILog (interface)") };
	(t => __RΦ$2$1$3.t[403] = t)(IΦILog$4);
	__RΦ$2$1$3.m("rt:P", ["enqueue", "dequeue"])(IΦILog$4);
	__RΦ$2$1$3.m("rt:m", [])(IΦILog$4);
	__RΦ$2$1$3.m("rt:f", "I")(IΦILog$4);
	__RΦ$2$1$3.m("rt:t", () => __RΦ$2$1$3.a(407))(IΦILog$4.prototype, "enqueue");
	__RΦ$2$1$3.m("rt:f", "P")(IΦILog$4.prototype, "enqueue");
	__RΦ$2$1$3.m("rt:t", () => __RΦ$2$1$3.a(407))(IΦILog$4.prototype, "dequeue");
	__RΦ$2$1$3.m("rt:f", "P")(IΦILog$4.prototype, "dequeue");
	__RΦ$2$1$3.m("rt:t", () => __RΦ$2$1$3.a(407))(IΦILog$4.prototype, "enqueue");
	__RΦ$2$1$3.m("rt:f", "P")(IΦILog$4.prototype, "enqueue");
	__RΦ$2$1$3.m("rt:t", () => __RΦ$2$1$3.a(407))(IΦILog$4.prototype, "dequeue");
	__RΦ$2$1$3.m("rt:f", "P")(IΦILog$4.prototype, "dequeue");
	class QueueLog$4 {
	    queue;
	    queueProxy;
	    log = {
	        enqueue: [],
	        dequeue: []
	    };
	    get sourceQueue() {
	        return this.queue;
	    }
	    get loggedQueue() {
	        return this.queueProxy;
	    }
	    static create(queue) {
	        const queueLog = new QueueLog$4(queue);
	        return [queueLog.loggedQueue, queueLog];
	    }
	    constructor(queue) {
	        this.queue = queue;
	        this.queueProxy = (new Proxy(queue, {
	            get: this.proxyHandlerGet.bind(this)
	        }));
	    }
	    proxyHandlerGet(target, property, receiver) {
	        const origin = Reflect.get(target, property, receiver);
	        switch (property) {
	            case 'enqueue': return this.createEnqueue(target, origin);
	            case 'dequeue': return this.createDequeue(target, origin);
	            default: return origin;
	        }
	    }
	    createEnqueue(target, origin) {
	        return (__RΦ$2$1$3.f((...items) => {
	            this.log.enqueue.push(...items);
	            origin.call(target, ...items);
	        }, [__RΦ$2$1$3.m("rt:p", [{ n: "items", t: () => __RΦ$2$1$3.a(408), v: null }]), __RΦ$2$1$3.m("rt:f", "F>"), __RΦ$2$1$3.m("rt:t", () => __RΦ$2$1$3.a(23))], ""));
	    }
	    createDequeue(target, origin) {
	        return (__RΦ$2$1$3.f(() => {
	            const item = origin.call(target);
	            if (item) {
	                this.log.dequeue.push(item);
	            }
	            return item;
	        }, [__RΦ$2$1$3.m("rt:p", []), __RΦ$2$1$3.m("rt:f", "F>"), __RΦ$2$1$3.m("rt:t", () => __RΦ$2$1$3.a(428))], ""));
	    }
	}
	(t => __RΦ$2$1$3.t[229] = t)(QueueLog$4);
	__RΦ$2$1$3.m("rt:SP", [])(QueueLog$4);
	__RΦ$2$1$3.m("rt:P", ["queueProxy", "log", "sourceQueue", "loggedQueue", "queue"])(QueueLog$4);
	__RΦ$2$1$3.m("rt:Sm", ["create"])(QueueLog$4);
	__RΦ$2$1$3.m("rt:m", ["proxyHandlerGet", "createEnqueue", "createDequeue"])(QueueLog$4);
	__RΦ$2$1$3.m("rt:p", [{ n: "queue", t: () => __RΦ$2$1$3.a(273), v: null, f: "#" }])(QueueLog$4);
	__RΦ$2$1$3.m("rt:f", "Ce")(QueueLog$4);
	__RΦ$2$1$3.m("rt:t", () => __RΦ$2$1$3.a(273))(QueueLog$4.prototype, "queueProxy");
	__RΦ$2$1$3.m("rt:f", "P#R")(QueueLog$4.prototype, "queueProxy");
	__RΦ$2$1$3.m("rt:t", () => __RΦ$2$1$3.a(406))(QueueLog$4.prototype, "log");
	__RΦ$2$1$3.m("rt:f", "P#")(QueueLog$4.prototype, "log");
	__RΦ$2$1$3.m("rt:t", () => __RΦ$2$1$3.a(4))(QueueLog$4.prototype, "sourceQueue");
	__RΦ$2$1$3.m("rt:f", "P$")(QueueLog$4.prototype, "sourceQueue");
	__RΦ$2$1$3.m("rt:t", () => __RΦ$2$1$3.a(4))(QueueLog$4.prototype, "loggedQueue");
	__RΦ$2$1$3.m("rt:f", "P$")(QueueLog$4.prototype, "loggedQueue");
	__RΦ$2$1$3.m("rt:f", "M$S")(QueueLog$4["create"]);
	((t, p) => __RΦ$2$1$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$4, "create");
	__RΦ$2$1$3.m("rt:p", [{ n: "queue", t: () => __RΦ$2$1$3.a(622), v: null }])(QueueLog$4, "create");
	__RΦ$2$1$3.m("rt:f", "M$S")(QueueLog$4, "create");
	__RΦ$2$1$3.m("rt:t", () => __RΦ$2$1$3.a(628))(QueueLog$4, "create");
	__RΦ$2$1$3.m("rt:f", "M#")(QueueLog$4.prototype["proxyHandlerGet"]);
	((t, p) => __RΦ$2$1$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$4.prototype, "proxyHandlerGet");
	__RΦ$2$1$3.m("rt:p", [{ n: "target", t: () => __RΦ$2$1$3.a(273), v: null }, { n: "property", t: () => __RΦ$2$1$3.a(143), v: null }, { n: "receiver", t: () => __RΦ$2$1$3.a(1), v: null }])(QueueLog$4.prototype, "proxyHandlerGet");
	__RΦ$2$1$3.m("rt:f", "M#")(QueueLog$4.prototype, "proxyHandlerGet");
	__RΦ$2$1$3.m("rt:t", () => __RΦ$2$1$3.a(1))(QueueLog$4.prototype, "proxyHandlerGet");
	__RΦ$2$1$3.m("rt:f", "M#.")(QueueLog$4.prototype["createEnqueue"]);
	((t, p) => __RΦ$2$1$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$4.prototype, "createEnqueue");
	__RΦ$2$1$3.m("rt:p", [{ n: "target", t: () => __RΦ$2$1$3.a(273), v: null }, { n: "origin", t: () => __RΦ$2$1$3.a(397), v: null }])(QueueLog$4.prototype, "createEnqueue");
	__RΦ$2$1$3.m("rt:f", "M#.")(QueueLog$4.prototype, "createEnqueue");
	__RΦ$2$1$3.m("rt:t", () => __RΦ$2$1$3.a(629))(QueueLog$4.prototype, "createEnqueue");
	__RΦ$2$1$3.m("rt:f", "M#.")(QueueLog$4.prototype["createDequeue"]);
	((t, p) => __RΦ$2$1$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$4.prototype, "createDequeue");
	__RΦ$2$1$3.m("rt:p", [{ n: "target", t: () => __RΦ$2$1$3.a(273), v: null }, { n: "origin", t: () => __RΦ$2$1$3.a(402), v: null }])(QueueLog$4.prototype, "createDequeue");
	__RΦ$2$1$3.m("rt:f", "M#.")(QueueLog$4.prototype, "createDequeue");
	__RΦ$2$1$3.m("rt:t", () => __RΦ$2$1$3.a(630))(QueueLog$4.prototype, "createDequeue");

	const __RΦ$1$1$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$1$1$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$1$1$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$1$1$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$1$1$3.a(14), __RΦ$1$1$3.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [144]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$1$1$3.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [146]: { RΦ: t => ({ TΦ: "t" }) } } };
	var IΦdefault$a$3 = { name: "IEventEmitter", prototype: {}, identity: Symbol("IEventEmitter (interface)") };
	(t => __RΦ$1$1$3.t[145] = t)(IΦdefault$a$3);
	__RΦ$1$1$3.m("rt:P", [])(IΦdefault$a$3);
	__RΦ$1$1$3.m("rt:m", ["on"])(IΦdefault$a$3);
	__RΦ$1$1$3.m("rt:f", "Ie")(IΦdefault$a$3);
	__RΦ$1$1$3.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$1$3.a(143), v: null }, { n: "listener", t: () => __RΦ$1$1$3.a(144), v: null }])(IΦdefault$a$3.prototype, "on");
	__RΦ$1$1$3.m("rt:f", "M")(IΦdefault$a$3.prototype, "on");
	__RΦ$1$1$3.m("rt:t", () => __RΦ$1$1$3.a(146))(IΦdefault$a$3.prototype, "on");
	__RΦ$1$1$3.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$1$3.a(143), v: null }, { n: "listener", t: () => __RΦ$1$1$3.a(144), v: null }])(IΦdefault$a$3.prototype, "on");
	__RΦ$1$1$3.m("rt:f", "M")(IΦdefault$a$3.prototype, "on");
	__RΦ$1$1$3.m("rt:t", () => __RΦ$1$1$3.a(146))(IΦdefault$a$3.prototype, "on");

	const __RΦ$s$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$s$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$s$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$s$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [4]: { RΦ: t => ({ TΦ: "~" }) }, [641]: { RΦ: t => ({ TΦ: "[", e: __RΦ$s$4.a(631) }) }, [631]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [658]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$s$4.a(10), __RΦ$s$4.a(633)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [633]: { LΦ: t => Object }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$s$4.a(14), __RΦ$s$4.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [662]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$s$4.a(4) }] }) }, [634]: { RΦ: t => ({ TΦ: "t" }) } } };
	class QueueWithEventEmitter$4 extends Queue$4 {
	    eventEmitter = new EventEmitter__default$4["default"];
	    enqueue(...items) {
	        this.eventEmitter.emit('before-enqueue', this, ...items);
	        super.enqueue(...items);
	        this.eventEmitter.emit('enqueue', this, ...items);
	    }
	    dequeue() {
	        const removed = super.dequeue();
	        this.eventEmitter.emit('dequeue', this, removed);
	        return removed;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	}
	(t => __RΦ$s$4.t[632] = t)(QueueWithEventEmitter$4);
	__RΦ$s$4.m("rt:SP", [])(QueueWithEventEmitter$4);
	__RΦ$s$4.m("rt:P", ["eventEmitter"])(QueueWithEventEmitter$4);
	__RΦ$s$4.m("rt:Sm", [])(QueueWithEventEmitter$4);
	__RΦ$s$4.m("rt:m", ["enqueue", "dequeue", "on"])(QueueWithEventEmitter$4);
	__RΦ$s$4.m("rt:i", [() => undefined])(QueueWithEventEmitter$4);
	__RΦ$s$4.m("rt:f", "Ce")(QueueWithEventEmitter$4);
	__RΦ$s$4.m("rt:t", () => __RΦ$s$4.a(4))(QueueWithEventEmitter$4.prototype, "eventEmitter");
	__RΦ$s$4.m("rt:f", "P#")(QueueWithEventEmitter$4.prototype, "eventEmitter");
	__RΦ$s$4.m("rt:f", "M$")(QueueWithEventEmitter$4.prototype["enqueue"]);
	((t, p) => __RΦ$s$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$4.prototype, "enqueue");
	__RΦ$s$4.m("rt:p", [{ n: "items", t: () => __RΦ$s$4.a(641), v: null }])(QueueWithEventEmitter$4.prototype, "enqueue");
	__RΦ$s$4.m("rt:f", "M$")(QueueWithEventEmitter$4.prototype, "enqueue");
	__RΦ$s$4.m("rt:t", () => __RΦ$s$4.a(23))(QueueWithEventEmitter$4.prototype, "enqueue");
	__RΦ$s$4.m("rt:f", "M$")(QueueWithEventEmitter$4.prototype["dequeue"]);
	((t, p) => __RΦ$s$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$4.prototype, "dequeue");
	__RΦ$s$4.m("rt:p", [])(QueueWithEventEmitter$4.prototype, "dequeue");
	__RΦ$s$4.m("rt:f", "M$")(QueueWithEventEmitter$4.prototype, "dequeue");
	__RΦ$s$4.m("rt:t", () => __RΦ$s$4.a(658))(QueueWithEventEmitter$4.prototype, "dequeue");
	__RΦ$s$4.m("rt:f", "M$")(QueueWithEventEmitter$4.prototype["on"]);
	((t, p) => __RΦ$s$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$4.prototype, "on");
	__RΦ$s$4.m("rt:p", [{ n: "eventName", t: () => __RΦ$s$4.a(143), v: null }, { n: "listener", t: () => __RΦ$s$4.a(662), v: null }])(QueueWithEventEmitter$4.prototype, "on");
	__RΦ$s$4.m("rt:f", "M$")(QueueWithEventEmitter$4.prototype, "on");
	__RΦ$s$4.m("rt:t", () => __RΦ$s$4.a(634))(QueueWithEventEmitter$4.prototype, "on");

	dist$5.Angle = Angle$4;
	dist$5.Convert = Convert$4;
	dist$5.GameLoop = GameLoop$4;
	dist$5.KeyUpDownProcessor = KeyUpDownProcessor$4;
	dist$5.Lazy = Lazy$4;
	dist$5.Queue = Queue$4;
	dist$5.QueueLog = QueueLog$4;
	dist$5.QueueWithEventEmitter = QueueWithEventEmitter$4;
	dist$5.Shortcut = Shortcut$4;
	dist$5.ShortcutDispatcher = ShortcutDispatcher$4;
	dist$5.Timer = Timer$4;
	dist$5.Vector = Vector$4;
	dist$5.execActionScript = execActionScript$4;
	dist$5.execFunctionScript = execFunctionScript$4;
	dist$5.isBrowser = isBrowser$4;
	dist$5.isStoppable = isStoppable$4;
	dist$5.onKeyDown = onKeyDown$4;
	dist$5.onKeyUp = onKeyUp$4;
	dist$5.toOneLine = toOneLine$4;

	const __RΦ$9$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$9$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$9$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$9$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1]: { RΦ: t => ({ TΦ: "~" }) }, [22]: { LΦ: t => Boolean }, [15]: { LΦ: t => String }, [97]: { LΦ: t => Object }, [98]: { LΦ: t => Object }, [99]: { LΦ: t => Object }, [24]: { RΦ: t => ({ TΦ: "V" }) }, [105]: { RΦ: t => ({ TΦ: "[", e: __RΦ$9$5.a(104) }) }, [104]: { RΦ: t => ({ TΦ: "g", t: __RΦ$9$5.a(100), p: [__RΦ$9$5.a(15), __RΦ$9$5.a(1)] }) }, [100]: { LΦ: t => dist$5["IΦdefault"] } } };
	function isUniversalObject$1(object) {
	    return ('getValue' in object &&
	        'setValue' in object &&
	        'items' in object &&
	        typeof object.getValue === 'function' &&
	        typeof object.setValue === 'function' &&
	        Array.isArray(object.items));
	}
	__RΦ$9$5.m("rt:p", [{ n: "object", t: () => __RΦ$9$5.a(1), v: null }])(isUniversalObject$1);
	__RΦ$9$5.m("rt:f", "F")(isUniversalObject$1);
	__RΦ$9$5.m("rt:t", () => __RΦ$9$5.a(22))(isUniversalObject$1);
	var IΦdefault$l = { name: "IUniversalObject", prototype: {}, identity: Symbol("IUniversalObject (interface)") };
	(t => __RΦ$9$5.t[294] = t)(IΦdefault$l);
	__RΦ$9$5.m("rt:P", ["items"])(IΦdefault$l);
	__RΦ$9$5.m("rt:m", ["getValue", "getValue", "setValue"])(IΦdefault$l);
	__RΦ$9$5.m("rt:f", "Ie")(IΦdefault$l);
	__RΦ$9$5.m("rt:p", [{ n: "name", t: () => __RΦ$9$5.a(15), v: null }])(IΦdefault$l.prototype, "getValue");
	__RΦ$9$5.m("rt:f", "M")(IΦdefault$l.prototype, "getValue");
	__RΦ$9$5.m("rt:t", () => __RΦ$9$5.a(97))(IΦdefault$l.prototype, "getValue");
	__RΦ$9$5.m("rt:p", [{ n: "name", t: () => __RΦ$9$5.a(15), v: null }, { n: "defaultValue", t: () => __RΦ$9$5.a(98), v: null }])(IΦdefault$l.prototype, "getValue");
	__RΦ$9$5.m("rt:f", "M")(IΦdefault$l.prototype, "getValue");
	__RΦ$9$5.m("rt:t", () => __RΦ$9$5.a(98))(IΦdefault$l.prototype, "getValue");
	__RΦ$9$5.m("rt:p", [{ n: "name", t: () => __RΦ$9$5.a(15), v: null }, { n: "value", t: () => __RΦ$9$5.a(99), v: null }])(IΦdefault$l.prototype, "setValue");
	__RΦ$9$5.m("rt:f", "M")(IΦdefault$l.prototype, "setValue");
	__RΦ$9$5.m("rt:t", () => __RΦ$9$5.a(24))(IΦdefault$l.prototype, "setValue");
	__RΦ$9$5.m("rt:t", () => __RΦ$9$5.a(105))(IΦdefault$l.prototype, "items");
	__RΦ$9$5.m("rt:f", "PR")(IΦdefault$l.prototype, "items");
	__RΦ$9$5.m("rt:p", [{ n: "name", t: () => __RΦ$9$5.a(15), v: null }])(IΦdefault$l.prototype, "getValue");
	__RΦ$9$5.m("rt:f", "M")(IΦdefault$l.prototype, "getValue");
	__RΦ$9$5.m("rt:t", () => __RΦ$9$5.a(97))(IΦdefault$l.prototype, "getValue");
	__RΦ$9$5.m("rt:p", [{ n: "name", t: () => __RΦ$9$5.a(15), v: null }, { n: "defaultValue", t: () => __RΦ$9$5.a(98), v: null }])(IΦdefault$l.prototype, "getValue");
	__RΦ$9$5.m("rt:f", "M")(IΦdefault$l.prototype, "getValue");
	__RΦ$9$5.m("rt:t", () => __RΦ$9$5.a(98))(IΦdefault$l.prototype, "getValue");
	__RΦ$9$5.m("rt:p", [{ n: "name", t: () => __RΦ$9$5.a(15), v: null }, { n: "value", t: () => __RΦ$9$5.a(99), v: null }])(IΦdefault$l.prototype, "setValue");
	__RΦ$9$5.m("rt:f", "M")(IΦdefault$l.prototype, "setValue");
	__RΦ$9$5.m("rt:t", () => __RΦ$9$5.a(24))(IΦdefault$l.prototype, "setValue");
	__RΦ$9$5.m("rt:t", () => __RΦ$9$5.a(105))(IΦdefault$l.prototype, "items");
	__RΦ$9$5.m("rt:f", "PR")(IΦdefault$l.prototype, "items");

	const __RΦ$8$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$8$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$8$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$8$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [294]: { LΦ: t => IΦdefault$l } } };
	class Adapter$1 {
	    universalObject;
	    constructor(universalObject) {
	        this.universalObject = universalObject;
	    }
	}
	(t => __RΦ$8$5.t[295] = t)(Adapter$1);
	__RΦ$8$5.m("rt:SP", [])(Adapter$1);
	__RΦ$8$5.m("rt:P", ["universalObject"])(Adapter$1);
	__RΦ$8$5.m("rt:Sm", [])(Adapter$1);
	__RΦ$8$5.m("rt:m", [])(Adapter$1);
	__RΦ$8$5.m("rt:p", [{ n: "universalObject", t: () => __RΦ$8$5.a(294), v: null, f: "@" }])(Adapter$1);
	__RΦ$8$5.m("rt:f", "Ce")(Adapter$1);

	const __RΦ$7$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$7$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$7$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$7$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [305]: { RΦ: t => ({ TΦ: "g", t: __RΦ$7$5.a(301), p: [__RΦ$7$5.a(15), __RΦ$7$5.a(1)] }) }, [301]: { LΦ: t => Map }, [15]: { LΦ: t => String }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [322]: { LΦ: t => Object }, [323]: { LΦ: t => Object }, [297]: { LΦ: t => Object }, [310]: { LΦ: t => Object }, [24]: { RΦ: t => ({ TΦ: "V" }) }, [4]: { RΦ: t => ({ TΦ: "~" }) } } };
	/**
	 * Объект, который хранит в себе набор разнотипных свойств.
	 * Простая реализация интерфейса IUniversalObject.
	 */
	class UniversalObject$1 {
	    map = new Map;
	    getValue(name, defaultValue) {
	        const value = this.map.get(name);
	        return value === undefined ? defaultValue : value;
	    }
	    /**
	     * Установить значение элемента.
	     * @param name
	     * @param value
	     */
	    setValue(name, value) {
	        this.map.set(name, value);
	    }
	    /**
	     * Получить список элементов в виде массива,
	     * где каждый элемент представлен двумя ключами: key и value.
	     */
	    get items() {
	        return Convert$5.toArray(this.map);
	    }
	}
	(t => __RΦ$7$5.t[298] = t)(UniversalObject$1);
	__RΦ$7$5.m("rt:SP", [])(UniversalObject$1);
	__RΦ$7$5.m("rt:P", ["map", "items"])(UniversalObject$1);
	__RΦ$7$5.m("rt:Sm", [])(UniversalObject$1);
	__RΦ$7$5.m("rt:m", ["getValue", "getValue", "getValue", "setValue"])(UniversalObject$1);
	__RΦ$7$5.m("rt:i", [() => IΦIUniversalObject])(UniversalObject$1);
	__RΦ$7$5.m("rt:f", "Ce")(UniversalObject$1);
	__RΦ$7$5.m("rt:t", () => __RΦ$7$5.a(305))(UniversalObject$1.prototype, "map");
	__RΦ$7$5.m("rt:f", "P#")(UniversalObject$1.prototype, "map");
	__RΦ$7$5.m("rt:f", "M")(UniversalObject$1.prototype["getValue"]);
	((t, p) => __RΦ$7$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(UniversalObject$1.prototype, "getValue");
	__RΦ$7$5.m("rt:p", [{ n: "name", t: () => __RΦ$7$5.a(15), v: null }])(UniversalObject$1.prototype, "getValue");
	__RΦ$7$5.m("rt:f", "M")(UniversalObject$1.prototype, "getValue");
	__RΦ$7$5.m("rt:t", () => __RΦ$7$5.a(322))(UniversalObject$1.prototype, "getValue");
	__RΦ$7$5.m("rt:f", "M")(UniversalObject$1.prototype["getValue"]);
	((t, p) => __RΦ$7$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(UniversalObject$1.prototype, "getValue");
	__RΦ$7$5.m("rt:p", [{ n: "name", t: () => __RΦ$7$5.a(15), v: null }, { n: "defaultValue", t: () => __RΦ$7$5.a(323), v: null }])(UniversalObject$1.prototype, "getValue");
	__RΦ$7$5.m("rt:f", "M")(UniversalObject$1.prototype, "getValue");
	__RΦ$7$5.m("rt:t", () => __RΦ$7$5.a(323))(UniversalObject$1.prototype, "getValue");
	__RΦ$7$5.m("rt:f", "M")(UniversalObject$1.prototype["getValue"]);
	((t, p) => __RΦ$7$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(UniversalObject$1.prototype, "getValue");
	__RΦ$7$5.m("rt:p", [{ n: "name", t: () => __RΦ$7$5.a(15), v: null }, { n: "defaultValue", t: () => __RΦ$7$5.a(297), v: null, f: "?" }])(UniversalObject$1.prototype, "getValue");
	__RΦ$7$5.m("rt:f", "M")(UniversalObject$1.prototype, "getValue");
	__RΦ$7$5.m("rt:t", () => __RΦ$7$5.a(297))(UniversalObject$1.prototype, "getValue");
	__RΦ$7$5.m("rt:f", "M$.")(UniversalObject$1.prototype["setValue"]);
	((t, p) => __RΦ$7$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(UniversalObject$1.prototype, "setValue");
	__RΦ$7$5.m("rt:p", [{ n: "name", t: () => __RΦ$7$5.a(15), v: null }, { n: "value", t: () => __RΦ$7$5.a(310), v: null }])(UniversalObject$1.prototype, "setValue");
	__RΦ$7$5.m("rt:f", "M$.")(UniversalObject$1.prototype, "setValue");
	__RΦ$7$5.m("rt:t", () => __RΦ$7$5.a(24))(UniversalObject$1.prototype, "setValue");
	__RΦ$7$5.m("rt:t", () => __RΦ$7$5.a(4))(UniversalObject$1.prototype, "items");
	__RΦ$7$5.m("rt:f", "P$")(UniversalObject$1.prototype, "items");

	const __RΦ$6$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$6$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$6$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$6$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [30]: { LΦ: t => Object }, [105]: { RΦ: t => ({ TΦ: "[", e: __RΦ$6$5.a(104) }) }, [104]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$5.a(100), p: [__RΦ$6$5.a(15), __RΦ$6$5.a(1)] }) }, [100]: { LΦ: t => dist$5["IΦdefault"] }, [15]: { LΦ: t => String }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [327]: { LΦ: t => Object }, [332]: { LΦ: t => Object }, [24]: { RΦ: t => ({ TΦ: "V" }) } } };
	// TODO Удалить UniversalObjectAdapter
	/**
	 * @deprecated
	 */
	class UniversalObjectAdapter$1 {
	    plainObject;
	    get items() {
	        // TODO Реализовать свойство items.
	        throw new Error('Свойство UniversalObjectAdapter.items не реализовано');
	    }
	    constructor(plainObject) {
	        this.plainObject = plainObject;
	    }
	    getValue(name, defaultValue) {
	        const value = Reflect.get(this.plainObject, name);
	        return value === undefined ? defaultValue : value;
	    }
	    setValue(name, value) {
	        Reflect.set(this.plainObject, name, value);
	    }
	}
	(t => __RΦ$6$5.t[328] = t)(UniversalObjectAdapter$1);
	__RΦ$6$5.m("rt:SP", [])(UniversalObjectAdapter$1);
	__RΦ$6$5.m("rt:P", ["items", "plainObject"])(UniversalObjectAdapter$1);
	__RΦ$6$5.m("rt:Sm", [])(UniversalObjectAdapter$1);
	__RΦ$6$5.m("rt:m", ["getValue", "setValue"])(UniversalObjectAdapter$1);
	__RΦ$6$5.m("rt:p", [{ n: "plainObject", t: () => __RΦ$6$5.a(30), v: null, f: "#" }])(UniversalObjectAdapter$1);
	__RΦ$6$5.m("rt:i", [() => IΦIUniversalObject])(UniversalObjectAdapter$1);
	__RΦ$6$5.m("rt:f", "Ce")(UniversalObjectAdapter$1);
	__RΦ$6$5.m("rt:t", () => __RΦ$6$5.a(105))(UniversalObjectAdapter$1.prototype, "items");
	__RΦ$6$5.m("rt:f", "P$")(UniversalObjectAdapter$1.prototype, "items");
	__RΦ$6$5.m("rt:f", "M$")(UniversalObjectAdapter$1.prototype["getValue"]);
	((t, p) => __RΦ$6$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(UniversalObjectAdapter$1.prototype, "getValue");
	__RΦ$6$5.m("rt:p", [{ n: "name", t: () => __RΦ$6$5.a(15), v: null }, { n: "defaultValue", t: () => __RΦ$6$5.a(327), v: null, f: "?" }])(UniversalObjectAdapter$1.prototype, "getValue");
	__RΦ$6$5.m("rt:f", "M$")(UniversalObjectAdapter$1.prototype, "getValue");
	__RΦ$6$5.m("rt:t", () => __RΦ$6$5.a(327))(UniversalObjectAdapter$1.prototype, "getValue");
	__RΦ$6$5.m("rt:f", "M$")(UniversalObjectAdapter$1.prototype["setValue"]);
	((t, p) => __RΦ$6$5.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(UniversalObjectAdapter$1.prototype, "setValue");
	__RΦ$6$5.m("rt:p", [{ n: "name", t: () => __RΦ$6$5.a(15), v: null }, { n: "value", t: () => __RΦ$6$5.a(332), v: null }])(UniversalObjectAdapter$1.prototype, "setValue");
	__RΦ$6$5.m("rt:f", "M$")(UniversalObjectAdapter$1.prototype, "setValue");
	__RΦ$6$5.m("rt:t", () => __RΦ$6$5.a(24))(UniversalObjectAdapter$1.prototype, "setValue");

	const __RΦ$5$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$5$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$5$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$5$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [477]: { LΦ: t => Object }, [333]: { LΦ: t => Object } } };
	/**
	 * Заполнить универсальный объект значениями свойств plane-объекта.
	 * Внимание, объект universalObject будет изменен.
	 * @param universalObject
	 * @param object
	 */
	function fillUniversalObject$1(universalObject, object) {
	    const result = universalObject;
	    for (const key in object) {
	        if (object.hasOwnProperty(key)) {
	            result.setValue(key, object[key]);
	        }
	    }
	    return result;
	}
	__RΦ$5$5.m("rt:p", [{ n: "universalObject", t: () => __RΦ$5$5.a(477), v: null }, { n: "object", t: () => __RΦ$5$5.a(333), v: null }])(fillUniversalObject$1);
	__RΦ$5$5.m("rt:f", "F")(fillUniversalObject$1);
	__RΦ$5$5.m("rt:t", () => __RΦ$5$5.a(477))(fillUniversalObject$1);

	const __RΦ$4$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$4$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$4$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$4$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [487]: { RΦ: t => ({ TΦ: "m", t: __RΦ$4$5.a(488), p: [__RΦ$4$5.a(486)] }) }, [488]: { LΦ: t => Object }, [486]: { LΦ: t => Object }, [298]: { LΦ: t => UniversalObject$1 } } };
	/**
	 * Создать IUniversalObject на основе plane-объекта.
	 * @param object
	 */
	function createUniversalObject$1(object) {
	    return fillUniversalObject$1(new UniversalObject$1, object);
	}
	__RΦ$4$5.m("rt:p", [{ n: "object", t: () => __RΦ$4$5.a(487), v: null }])(createUniversalObject$1);
	__RΦ$4$5.m("rt:f", "F")(createUniversalObject$1);
	__RΦ$4$5.m("rt:t", () => __RΦ$4$5.a(298))(createUniversalObject$1);

	const __RΦ$3$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$3$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$3$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$3$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [582]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$5.a(581) }) }, [581]: { LΦ: t => Object }, [520]: { LΦ: t => Object }, [22]: { LΦ: t => Boolean }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [294]: { LΦ: t => IΦdefault$l } } };
	/**
	 * Поиск объекта.
	 * Ищется первый объект для которого совпадает хотя бы один из параметров.
	 * @param list Массив объектов, в котором производится поиск.
	 * @param params Параметры искомого объекта.
	 */
	function findUniversalObject$1(list, params) {
	    const predicate = __RΦ$3$5.f((object) => (Object.entries(params).reduce(__RΦ$3$5.f((result, [key, value]) => result && object.getValue(key) === value, [__RΦ$3$5.m("rt:p", [{ n: "result", t: () => __RΦ$3$5.a(22), v: null }, { n: "[key, value]", t: () => __RΦ$3$5.a(4), v: null }]), __RΦ$3$5.m("rt:f", "F>"), __RΦ$3$5.m("rt:t", () => __RΦ$3$5.a(22))], ""), true)), [__RΦ$3$5.m("rt:p", [{ n: "object", t: () => __RΦ$3$5.a(294), v: null }]), __RΦ$3$5.m("rt:f", "F>"), __RΦ$3$5.m("rt:t", () => __RΦ$3$5.a(22))], "");
	    return list.find(predicate);
	}
	__RΦ$3$5.m("rt:p", [{ n: "list", t: () => __RΦ$3$5.a(582), v: null }, { n: "params", t: () => __RΦ$3$5.a(520), v: null }])(findUniversalObject$1);
	__RΦ$3$5.m("rt:f", "F")(findUniversalObject$1);
	__RΦ$3$5.m("rt:t", () => __RΦ$3$5.a(581))(findUniversalObject$1);

	const __RΦ$2$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$2$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$2$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$2$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [605]: { LΦ: t => Object }, [615]: { RΦ: t => ({ TΦ: "m", t: __RΦ$2$6.a(616), p: [__RΦ$2$6.a(605), __RΦ$2$6.a(611)] }) }, [616]: { LΦ: t => Object }, [611]: { LΦ: t => "type" } } };
	/**
	 * Клонирует объект и удаляет из него свойство type.
	 * @param object
	 */
	function withoutType$1(object) {
	    object = Object.assign({}, object);
	    delete object.type;
	    return object;
	}
	__RΦ$2$6.m("rt:p", [{ n: "object", t: () => __RΦ$2$6.a(605), v: null }])(withoutType$1);
	__RΦ$2$6.m("rt:f", "F")(withoutType$1);
	__RΦ$2$6.m("rt:t", () => __RΦ$2$6.a(615))(withoutType$1);

	const __RΦ$1$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$1$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$1$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$1$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [621]: { LΦ: t => Object }, [294]: { LΦ: t => IΦdefault$l } } };
	/**
	 * Разрешение зависимости вида <Тип объекта>.
	 *
	 * Позволяет найти объект этого типа по набору признаков params.
	 * Поиск объекта будет будет производится в массиве, который будет найден как зависимость <Тип объекта + List>.
	 *
	 * Пример регистрации такой зависимости:
	 * - register('GameObject', universalObjectResolver).
	 * - register('GameObjectList', (): IUniversalObject => [])
	 *
	 * @param params Параметры искомого объекта. Поле type не участвует в поиске.
	 */
	function universalObjectResolver$1(params) {
	    const universalObjectList = resolve(params.type + 'List');
	    return findUniversalObject$1(universalObjectList, withoutType$1(params));
	}
	__RΦ$1$6.m("rt:p", [{ n: "params", t: () => __RΦ$1$6.a(621), v: null }])(universalObjectResolver$1);
	__RΦ$1$6.m("rt:f", "F")(universalObjectResolver$1);
	__RΦ$1$6.m("rt:t", () => __RΦ$1$6.a(294))(universalObjectResolver$1);

	const __RΦ$N = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$N.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$N.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$N.t[id] = t = l;
	        }
	        return t;
	    }, t: { [294]: { LΦ: t => IΦdefault$l }, [641]: { RΦ: t => ({ TΦ: "[", e: __RΦ$N.a(640) }) }, [640]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__constructor", f: "", t: __RΦ$N.a(4) }, { n: "universalObject", f: "", t: __RΦ$N.a(294) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [295]: { LΦ: t => Adapter$1 }, [74]: { RΦ: t => ({ TΦ: "[", e: __RΦ$N.a(1) }) }, [673]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$N.a(15), __RΦ$N.a(23)] }) }, [15]: { LΦ: t => String }, [23]: { LΦ: t => Object }, [22]: { LΦ: t => Boolean } } };
	function createAdapter$1(universalObject, ...adapterClasses) {
	    if (adapterClasses.length === 1) {
	        const AdapterClass = adapterClasses[0];
	        return new AdapterClass(universalObject);
	    }
	    else {
	        return new Proxy(adapterClasses.map(__RΦ$N.f(AdapterClass => new AdapterClass(universalObject), [__RΦ$N.m("rt:p", [{ n: "AdapterClass", t: () => __RΦ$N.a(4), v: null }]), __RΦ$N.m("rt:f", "F>"), __RΦ$N.m("rt:t", () => __RΦ$N.a(295))], "")), {
	            get: proxyHandlerGet$1,
	            set: proxyHandlerSet$1
	        });
	    }
	}
	__RΦ$N.m("rt:p", [{ n: "universalObject", t: () => __RΦ$N.a(294), v: null }, { n: "adapterClasses", t: () => __RΦ$N.a(641), v: null }])(createAdapter$1);
	__RΦ$N.m("rt:f", "F")(createAdapter$1);
	__RΦ$N.m("rt:t", () => __RΦ$N.a(1))(createAdapter$1);
	function proxyHandlerGet$1(adapters, property) {
	    for (const adapter of adapters) {
	        if (property in adapter) {
	            const value = Reflect.get(adapter, property);
	            return (typeof value === 'function'
	                ? value.bind(adapter)
	                : value);
	        }
	    }
	}
	__RΦ$N.m("rt:p", [{ n: "adapters", t: () => __RΦ$N.a(74), v: null }, { n: "property", t: () => __RΦ$N.a(673), v: null }])(proxyHandlerGet$1);
	__RΦ$N.m("rt:f", "F")(proxyHandlerGet$1);
	__RΦ$N.m("rt:t", () => __RΦ$N.a(1))(proxyHandlerGet$1);
	function proxyHandlerSet$1(adapters, property, value) {
	    for (const adapter of adapters) {
	        if (property in adapter) {
	            return Reflect.set(adapter, property, value);
	        }
	    }
	    return false;
	}
	__RΦ$N.m("rt:p", [{ n: "adapters", t: () => __RΦ$N.a(74), v: null }, { n: "property", t: () => __RΦ$N.a(673), v: null }, { n: "value", t: () => __RΦ$N.a(1), v: null }])(proxyHandlerSet$1);
	__RΦ$N.m("rt:f", "F")(proxyHandlerSet$1);
	__RΦ$N.m("rt:t", () => __RΦ$N.a(22))(proxyHandlerSet$1);

	const __RΦ$C$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$C$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$C$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$C$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [84]: { LΦ: t => Vector$5 } } };
	var IΦdefault$b$1 = { name: "IMovable", prototype: {}, identity: Symbol("IMovable (interface)") };
	(t => __RΦ$C$1.t[86] = t)(IΦdefault$b$1);
	__RΦ$C$1.m("rt:P", ["time", "mass", "position", "appliedForce", "linearAcceleration", "linearVelocity"])(IΦdefault$b$1);
	__RΦ$C$1.m("rt:m", [])(IΦdefault$b$1);
	__RΦ$C$1.m("rt:f", "Ie")(IΦdefault$b$1);
	__RΦ$C$1.m("rt:t", () => __RΦ$C$1.a(15))(IΦdefault$b$1.prototype, "time");
	__RΦ$C$1.m("rt:f", "P")(IΦdefault$b$1.prototype, "time");
	__RΦ$C$1.m("rt:t", () => __RΦ$C$1.a(15))(IΦdefault$b$1.prototype, "mass");
	__RΦ$C$1.m("rt:f", "P")(IΦdefault$b$1.prototype, "mass");
	__RΦ$C$1.m("rt:t", () => __RΦ$C$1.a(84))(IΦdefault$b$1.prototype, "position");
	__RΦ$C$1.m("rt:f", "P")(IΦdefault$b$1.prototype, "position");
	__RΦ$C$1.m("rt:t", () => __RΦ$C$1.a(84))(IΦdefault$b$1.prototype, "appliedForce");
	__RΦ$C$1.m("rt:f", "P")(IΦdefault$b$1.prototype, "appliedForce");
	__RΦ$C$1.m("rt:t", () => __RΦ$C$1.a(84))(IΦdefault$b$1.prototype, "linearAcceleration");
	__RΦ$C$1.m("rt:f", "P")(IΦdefault$b$1.prototype, "linearAcceleration");
	__RΦ$C$1.m("rt:t", () => __RΦ$C$1.a(84))(IΦdefault$b$1.prototype, "linearVelocity");
	__RΦ$C$1.m("rt:f", "P")(IΦdefault$b$1.prototype, "linearVelocity");
	__RΦ$C$1.m("rt:t", () => __RΦ$C$1.a(15))(IΦdefault$b$1.prototype, "time");
	__RΦ$C$1.m("rt:f", "P")(IΦdefault$b$1.prototype, "time");
	__RΦ$C$1.m("rt:t", () => __RΦ$C$1.a(15))(IΦdefault$b$1.prototype, "mass");
	__RΦ$C$1.m("rt:f", "P")(IΦdefault$b$1.prototype, "mass");
	__RΦ$C$1.m("rt:t", () => __RΦ$C$1.a(84))(IΦdefault$b$1.prototype, "position");
	__RΦ$C$1.m("rt:f", "P")(IΦdefault$b$1.prototype, "position");
	__RΦ$C$1.m("rt:t", () => __RΦ$C$1.a(84))(IΦdefault$b$1.prototype, "appliedForce");
	__RΦ$C$1.m("rt:f", "P")(IΦdefault$b$1.prototype, "appliedForce");
	__RΦ$C$1.m("rt:t", () => __RΦ$C$1.a(84))(IΦdefault$b$1.prototype, "linearAcceleration");
	__RΦ$C$1.m("rt:f", "P")(IΦdefault$b$1.prototype, "linearAcceleration");
	__RΦ$C$1.m("rt:t", () => __RΦ$C$1.a(84))(IΦdefault$b$1.prototype, "linearVelocity");
	__RΦ$C$1.m("rt:f", "P")(IΦdefault$b$1.prototype, "linearVelocity");

	const __RΦ$B$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$B$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$B$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$B$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [84]: { LΦ: t => Vector$5 } } };
	class MovableAdapter extends Adapter$1 {
	    get time() {
	        return this.universalObject.getValue('time', 0);
	    }
	    set time(value) {
	        this.universalObject.setValue('time', value);
	    }
	    get mass() {
	        return this.universalObject.getValue('mass', 1);
	    }
	    set mass(value) {
	        this.universalObject.setValue('mass', value);
	    }
	    get position() {
	        return this.universalObject.getValue('position', new Vector$5);
	    }
	    set position(value) {
	        this.universalObject.setValue('position', value);
	    }
	    get appliedForce() {
	        return this.universalObject.getValue('appliedForce', new Vector$5);
	    }
	    set appliedForce(value) {
	        this.universalObject.setValue('appliedForce', value);
	    }
	    get linearAcceleration() {
	        return this.universalObject.getValue('linearAcceleration', new Vector$5);
	    }
	    set linearAcceleration(value) {
	        this.universalObject.setValue('linearAcceleration', value);
	    }
	    get linearVelocity() {
	        return this.universalObject.getValue('linearVelocity', new Vector$5);
	    }
	    set linearVelocity(value) {
	        this.universalObject.setValue('linearVelocity', value);
	    }
	}
	(t => __RΦ$B$1.t[88] = t)(MovableAdapter);
	__RΦ$B$1.m("rt:SP", [])(MovableAdapter);
	__RΦ$B$1.m("rt:P", ["time", "time", "mass", "mass", "position", "position", "appliedForce", "appliedForce", "linearAcceleration", "linearAcceleration", "linearVelocity", "linearVelocity"])(MovableAdapter);
	__RΦ$B$1.m("rt:Sm", [])(MovableAdapter);
	__RΦ$B$1.m("rt:m", [])(MovableAdapter);
	__RΦ$B$1.m("rt:i", [() => undefined])(MovableAdapter);
	__RΦ$B$1.m("rt:f", "Ce")(MovableAdapter);
	__RΦ$B$1.m("rt:t", () => __RΦ$B$1.a(15))(MovableAdapter.prototype, "time");
	__RΦ$B$1.m("rt:f", "P$")(MovableAdapter.prototype, "time");
	__RΦ$B$1.m("rt:t", () => __RΦ$B$1.a(15))(MovableAdapter.prototype, "time");
	__RΦ$B$1.m("rt:f", "P$")(MovableAdapter.prototype, "time");
	__RΦ$B$1.m("rt:t", () => __RΦ$B$1.a(15))(MovableAdapter.prototype, "mass");
	__RΦ$B$1.m("rt:f", "P$")(MovableAdapter.prototype, "mass");
	__RΦ$B$1.m("rt:t", () => __RΦ$B$1.a(15))(MovableAdapter.prototype, "mass");
	__RΦ$B$1.m("rt:f", "P$")(MovableAdapter.prototype, "mass");
	__RΦ$B$1.m("rt:t", () => __RΦ$B$1.a(84))(MovableAdapter.prototype, "position");
	__RΦ$B$1.m("rt:f", "P$")(MovableAdapter.prototype, "position");
	__RΦ$B$1.m("rt:t", () => __RΦ$B$1.a(84))(MovableAdapter.prototype, "position");
	__RΦ$B$1.m("rt:f", "P$")(MovableAdapter.prototype, "position");
	__RΦ$B$1.m("rt:t", () => __RΦ$B$1.a(84))(MovableAdapter.prototype, "appliedForce");
	__RΦ$B$1.m("rt:f", "P$")(MovableAdapter.prototype, "appliedForce");
	__RΦ$B$1.m("rt:t", () => __RΦ$B$1.a(84))(MovableAdapter.prototype, "appliedForce");
	__RΦ$B$1.m("rt:f", "P$")(MovableAdapter.prototype, "appliedForce");
	__RΦ$B$1.m("rt:t", () => __RΦ$B$1.a(84))(MovableAdapter.prototype, "linearAcceleration");
	__RΦ$B$1.m("rt:f", "P$")(MovableAdapter.prototype, "linearAcceleration");
	__RΦ$B$1.m("rt:t", () => __RΦ$B$1.a(84))(MovableAdapter.prototype, "linearAcceleration");
	__RΦ$B$1.m("rt:f", "P$")(MovableAdapter.prototype, "linearAcceleration");
	__RΦ$B$1.m("rt:t", () => __RΦ$B$1.a(84))(MovableAdapter.prototype, "linearVelocity");
	__RΦ$B$1.m("rt:f", "P$")(MovableAdapter.prototype, "linearVelocity");
	__RΦ$B$1.m("rt:t", () => __RΦ$B$1.a(84))(MovableAdapter.prototype, "linearVelocity");
	__RΦ$B$1.m("rt:f", "P$")(MovableAdapter.prototype, "linearVelocity");

	const __RΦ$A$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$A$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$A$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$A$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [86]: { LΦ: t => IΦdefault$b$1 }, [15]: { LΦ: t => Number }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Поступательное движение.
	 *
	 * Рассчитывается за определенный промежуток времени timeInterval.
	 * Работает в двух режимах:
	 * - фиксированный промежуток времени (нужно определить fixedTimeInterval)
	 * - вычисляемый промежуток времени (режим по умолчанию)
	 */
	class MoveCommand {
	    movable;
	    fixedTimeInterval;
	    name = 'MoveCommand';
	    /**
	     * Конструктор команды поступательного движения.
	     * @param movable Движущийся объект.
	     * @param fixedTimeInterval Задать фиксированный интервал времени. В миллисекундах.
	     * Используется для варианта игрового цикла с фиксированным шагом.
	     */
	    constructor(movable, // TODO Добавить ITransformable
	    fixedTimeInterval) {
	        this.movable = movable;
	        this.fixedTimeInterval = fixedTimeInterval;
	    }
	    execute() {
	        const currentTime = Date.now();
	        const { time = currentTime } = this.movable;
	        const timeInterval = currentTime - time;
	        // Если фиксированный интервал задан, то выполняем вычисления не чаще этого значения.
	        if (this.fixedTimeInterval && timeInterval < this.fixedTimeInterval)
	            return;
	        const { mass, position, linearAcceleration, linearVelocity, appliedForce } = this.movable;
	        this.movable.linearAcceleration = appliedForce.scale(1 / mass);
	        this.movable.linearVelocity = linearVelocity.translate(linearAcceleration.scale(Convert$5.toSecond(timeInterval)));
	        this.movable.position = position.translate(linearVelocity.scale(Convert$5.toSecond(timeInterval)));
	        this.movable.time = currentTime;
	    }
	}
	(t => __RΦ$A$1.t[128] = t)(MoveCommand);
	__RΦ$A$1.m("rt:SP", [])(MoveCommand);
	__RΦ$A$1.m("rt:P", ["name", "movable", "fixedTimeInterval"])(MoveCommand);
	__RΦ$A$1.m("rt:Sm", [])(MoveCommand);
	__RΦ$A$1.m("rt:m", ["execute"])(MoveCommand);
	__RΦ$A$1.m("rt:p", [{ n: "movable", t: () => __RΦ$A$1.a(86), v: null, f: "#" }, { n: "fixedTimeInterval", t: () => __RΦ$A$1.a(15), v: null, f: "#?" }])(MoveCommand);
	__RΦ$A$1.m("rt:i", [() => undefined])(MoveCommand);
	__RΦ$A$1.m("rt:f", "Ce")(MoveCommand);
	__RΦ$A$1.m("rt:t", () => __RΦ$A$1.a(4))(MoveCommand.prototype, "name");
	__RΦ$A$1.m("rt:f", "P$R")(MoveCommand.prototype, "name");
	__RΦ$A$1.m("rt:f", "M$")(MoveCommand.prototype["execute"]);
	((t, p) => __RΦ$A$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(MoveCommand.prototype, "execute");
	__RΦ$A$1.m("rt:p", [])(MoveCommand.prototype, "execute");
	__RΦ$A$1.m("rt:f", "M$")(MoveCommand.prototype, "execute");
	__RΦ$A$1.m("rt:t", () => __RΦ$A$1.a(23))(MoveCommand.prototype, "execute");

	const __RΦ$z$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$z$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$z$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$z$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [86]: { LΦ: t => IΦdefault$b$1 }, [142]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$z$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	// TODO Эту команду надо удалить и вместо нее использовать RelayCommand
	//  Перед этим в README.md надо прописать пример использования RelayCommand для изменения движения объекта.
	/**
	 * Команда изменения параметров поступательного движения.
	 *
	 * Например, если пространство является тором, то можно исправлять координаты.
	 * Или команда увеличения приложенной к объекту силы.
	 */
	class MoveTransformCommand {
	    movable;
	    transform;
	    name = 'MoveTransformCommand';
	    constructor(movable, transform) {
	        this.movable = movable;
	        this.transform = transform;
	    }
	    execute() {
	        this.transform(this.movable);
	    }
	}
	(t => __RΦ$z$1.t[139] = t)(MoveTransformCommand);
	__RΦ$z$1.m("rt:SP", [])(MoveTransformCommand);
	__RΦ$z$1.m("rt:P", ["name", "movable", "transform"])(MoveTransformCommand);
	__RΦ$z$1.m("rt:Sm", [])(MoveTransformCommand);
	__RΦ$z$1.m("rt:m", ["execute"])(MoveTransformCommand);
	__RΦ$z$1.m("rt:p", [{ n: "movable", t: () => __RΦ$z$1.a(86), v: null, f: "#" }, { n: "transform", t: () => __RΦ$z$1.a(142), v: null, f: "#" }])(MoveTransformCommand);
	__RΦ$z$1.m("rt:i", [() => undefined])(MoveTransformCommand);
	__RΦ$z$1.m("rt:f", "Ce")(MoveTransformCommand);
	__RΦ$z$1.m("rt:t", () => __RΦ$z$1.a(4))(MoveTransformCommand.prototype, "name");
	__RΦ$z$1.m("rt:f", "P$R")(MoveTransformCommand.prototype, "name");
	__RΦ$z$1.m("rt:f", "M$")(MoveTransformCommand.prototype["execute"]);
	((t, p) => __RΦ$z$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(MoveTransformCommand.prototype, "execute");
	__RΦ$z$1.m("rt:p", [])(MoveTransformCommand.prototype, "execute");
	__RΦ$z$1.m("rt:f", "M$")(MoveTransformCommand.prototype, "execute");
	__RΦ$z$1.m("rt:t", () => __RΦ$z$1.a(23))(MoveTransformCommand.prototype, "execute");

	const __RΦ$y$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$y$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$y$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$y$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [84]: { LΦ: t => Vector$5 } } };
	var IΦdefault$a$2 = { name: "ITransformable", prototype: {}, identity: Symbol("ITransformable (interface)") };
	(t => __RΦ$y$1.t[87] = t)(IΦdefault$a$2);
	__RΦ$y$1.m("rt:P", ["position", "rotation", "scale"])(IΦdefault$a$2);
	__RΦ$y$1.m("rt:m", [])(IΦdefault$a$2);
	__RΦ$y$1.m("rt:f", "Ie")(IΦdefault$a$2);
	__RΦ$y$1.m("rt:t", () => __RΦ$y$1.a(84))(IΦdefault$a$2.prototype, "position");
	__RΦ$y$1.m("rt:f", "P")(IΦdefault$a$2.prototype, "position");
	__RΦ$y$1.m("rt:t", () => __RΦ$y$1.a(84))(IΦdefault$a$2.prototype, "rotation");
	__RΦ$y$1.m("rt:f", "P")(IΦdefault$a$2.prototype, "rotation");
	__RΦ$y$1.m("rt:t", () => __RΦ$y$1.a(84))(IΦdefault$a$2.prototype, "scale");
	__RΦ$y$1.m("rt:f", "P")(IΦdefault$a$2.prototype, "scale");
	__RΦ$y$1.m("rt:t", () => __RΦ$y$1.a(84))(IΦdefault$a$2.prototype, "position");
	__RΦ$y$1.m("rt:f", "P")(IΦdefault$a$2.prototype, "position");
	__RΦ$y$1.m("rt:t", () => __RΦ$y$1.a(84))(IΦdefault$a$2.prototype, "rotation");
	__RΦ$y$1.m("rt:f", "P")(IΦdefault$a$2.prototype, "rotation");
	__RΦ$y$1.m("rt:t", () => __RΦ$y$1.a(84))(IΦdefault$a$2.prototype, "scale");
	__RΦ$y$1.m("rt:f", "P")(IΦdefault$a$2.prototype, "scale");

	const __RΦ$x$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$x$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$x$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$x$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [84]: { LΦ: t => Vector$5 } } };
	class TransformableAdapter extends Adapter$1 {
	    get position() {
	        return this.universalObject.getValue('position', new Vector$5(0, 0));
	    }
	    set position(value) {
	        this.universalObject.setValue('position', value);
	    }
	    get rotation() {
	        return this.universalObject.getValue('rotation', new Vector$5(0, 0));
	    }
	    set rotation(value) {
	        this.universalObject.setValue('rotation', value);
	    }
	    get scale() {
	        return this.universalObject.getValue('scale', new Vector$5(1, 1));
	    }
	    set scale(value) {
	        this.universalObject.setValue('scale', value);
	    }
	}
	(t => __RΦ$x$1.t[117] = t)(TransformableAdapter);
	__RΦ$x$1.m("rt:SP", [])(TransformableAdapter);
	__RΦ$x$1.m("rt:P", ["position", "position", "rotation", "rotation", "scale", "scale"])(TransformableAdapter);
	__RΦ$x$1.m("rt:Sm", [])(TransformableAdapter);
	__RΦ$x$1.m("rt:m", [])(TransformableAdapter);
	__RΦ$x$1.m("rt:i", [() => undefined])(TransformableAdapter);
	__RΦ$x$1.m("rt:f", "Ce")(TransformableAdapter);
	__RΦ$x$1.m("rt:t", () => __RΦ$x$1.a(84))(TransformableAdapter.prototype, "position");
	__RΦ$x$1.m("rt:f", "P$")(TransformableAdapter.prototype, "position");
	__RΦ$x$1.m("rt:t", () => __RΦ$x$1.a(84))(TransformableAdapter.prototype, "position");
	__RΦ$x$1.m("rt:f", "P$")(TransformableAdapter.prototype, "position");
	__RΦ$x$1.m("rt:t", () => __RΦ$x$1.a(84))(TransformableAdapter.prototype, "rotation");
	__RΦ$x$1.m("rt:f", "P$")(TransformableAdapter.prototype, "rotation");
	__RΦ$x$1.m("rt:t", () => __RΦ$x$1.a(84))(TransformableAdapter.prototype, "rotation");
	__RΦ$x$1.m("rt:f", "P$")(TransformableAdapter.prototype, "rotation");
	__RΦ$x$1.m("rt:t", () => __RΦ$x$1.a(84))(TransformableAdapter.prototype, "scale");
	__RΦ$x$1.m("rt:f", "P$")(TransformableAdapter.prototype, "scale");
	__RΦ$x$1.m("rt:t", () => __RΦ$x$1.a(84))(TransformableAdapter.prototype, "scale");
	__RΦ$x$1.m("rt:f", "P$")(TransformableAdapter.prototype, "scale");

	const __RΦ$w$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$w$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$w$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$w$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [84]: { LΦ: t => Vector$5 }, [144]: { LΦ: t => undefined } } };
	/**
	 * Специальная функция для корректировки координат движущихся объектов
	 * с целью создания замкнутого пространства типа бублик.
	 * @param position
	 * @param toroidalSurfaceSize
	// * @param toroidalSurfaceOffset
	 */
	function transformPositionForToroid(position, { width, height }
	//, toroidalSurfaceOffset: Vector = new Vector
	) {
	    // let result = position.translate(toroidalSurfaceOffset.inverse)
	    //
	    // // Ограничить по положительной полуоси.
	    // result = result.mod(new Vector(width, height))
	    // // Ограничить по отрицательной полуоси.
	    // result = (
	    // 	result.translate(
	    // 		new Vector(
	    // 			result.x < 0 ? width : 0,
	    // 			result.y < 0 ? height : 0
	    // 		)
	    // 	)
	    // )
	    //
	    // return result.translate(toroidalSurfaceOffset)
	    // Ограничить по положительной полуоси.
	    const result = position.mod(new Vector$5(width, height));
	    // Ограничить по отрицательной полуоси.
	    return (result.translate(new Vector$5(result.x < 0 ? width : 0, result.y < 0 ? height : 0)));
	}
	__RΦ$w$1.m("rt:p", [{ n: "position", t: () => __RΦ$w$1.a(84), v: null }, { n: "{width, height}", t: () => __RΦ$w$1.a(144), v: null }])(transformPositionForToroid);
	__RΦ$w$1.m("rt:f", "F")(transformPositionForToroid);
	__RΦ$w$1.m("rt:t", () => __RΦ$w$1.a(84))(transformPositionForToroid);

	const __RΦ$v$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$v$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$v$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$v$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [142]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$v$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [86]: { LΦ: t => IΦdefault$b$1 }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	function increaseForceActionResolver(increment) {
	    return __RΦ$v$1.f((movable) => {
	        movable.appliedForce = (movable.appliedForce.isNull
	            ? movable.linearVelocity.identity.scale(increment)
	            : movable.appliedForce.translate(movable.appliedForce.identity.scale(increment)));
	    }, [__RΦ$v$1.m("rt:p", [{ n: "movable", t: () => __RΦ$v$1.a(86), v: null }]), __RΦ$v$1.m("rt:f", "F>"), __RΦ$v$1.m("rt:t", () => __RΦ$v$1.a(23))], "");
	}
	__RΦ$v$1.m("rt:p", [{ n: "increment", t: () => __RΦ$v$1.a(15), v: null }])(increaseForceActionResolver);
	__RΦ$v$1.m("rt:f", "F")(increaseForceActionResolver);
	__RΦ$v$1.m("rt:t", () => __RΦ$v$1.a(142))(increaseForceActionResolver);

	const __RΦ$u$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$u$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$u$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$u$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [142]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$u$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [86]: { LΦ: t => IΦdefault$b$1 }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	function decreaseForceActionResolver(increment) {
	    return __RΦ$u$1.f((movable) => {
	        movable.appliedForce = (movable.appliedForce.isNull || movable.appliedForce.length < increment
	            ? new Vector$5(0, 0)
	            : movable.appliedForce.translate(movable.appliedForce.identity.scale(-increment)));
	    }, [__RΦ$u$1.m("rt:p", [{ n: "movable", t: () => __RΦ$u$1.a(86), v: null }]), __RΦ$u$1.m("rt:f", "F>"), __RΦ$u$1.m("rt:t", () => __RΦ$u$1.a(23))], "");
	}
	__RΦ$u$1.m("rt:p", [{ n: "increment", t: () => __RΦ$u$1.a(15), v: null }])(decreaseForceActionResolver);
	__RΦ$u$1.m("rt:f", "F")(decreaseForceActionResolver);
	__RΦ$u$1.m("rt:t", () => __RΦ$u$1.a(142))(decreaseForceActionResolver);

	var dist$4 = {};

	var events$2 = {exports: {}};

	var R$2 = typeof Reflect === 'object' ? Reflect : null;
	var ReflectApply$2 = R$2 && typeof R$2.apply === 'function'
	  ? R$2.apply
	  : function ReflectApply(target, receiver, args) {
	    return Function.prototype.apply.call(target, receiver, args);
	  };

	var ReflectOwnKeys$2;
	if (R$2 && typeof R$2.ownKeys === 'function') {
	  ReflectOwnKeys$2 = R$2.ownKeys;
	} else if (Object.getOwnPropertySymbols) {
	  ReflectOwnKeys$2 = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target)
	      .concat(Object.getOwnPropertySymbols(target));
	  };
	} else {
	  ReflectOwnKeys$2 = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target);
	  };
	}

	function ProcessEmitWarning$2(warning) {
	  if (console && console.warn) console.warn(warning);
	}

	var NumberIsNaN$2 = Number.isNaN || function NumberIsNaN(value) {
	  return value !== value;
	};

	function EventEmitter$1$2() {
	  EventEmitter$1$2.init.call(this);
	}
	events$2.exports = EventEmitter$1$2;
	events$2.exports.once = once$2;

	// Backwards-compat with node 0.10.x
	EventEmitter$1$2.EventEmitter = EventEmitter$1$2;

	EventEmitter$1$2.prototype._events = undefined;
	EventEmitter$1$2.prototype._eventsCount = 0;
	EventEmitter$1$2.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	var defaultMaxListeners$2 = 10;

	function checkListener$2(listener) {
	  if (typeof listener !== 'function') {
	    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
	  }
	}

	Object.defineProperty(EventEmitter$1$2, 'defaultMaxListeners', {
	  enumerable: true,
	  get: function() {
	    return defaultMaxListeners$2;
	  },
	  set: function(arg) {
	    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN$2(arg)) {
	      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
	    }
	    defaultMaxListeners$2 = arg;
	  }
	});

	EventEmitter$1$2.init = function() {

	  if (this._events === undefined ||
	      this._events === Object.getPrototypeOf(this)._events) {
	    this._events = Object.create(null);
	    this._eventsCount = 0;
	  }

	  this._maxListeners = this._maxListeners || undefined;
	};

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter$1$2.prototype.setMaxListeners = function setMaxListeners(n) {
	  if (typeof n !== 'number' || n < 0 || NumberIsNaN$2(n)) {
	    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
	  }
	  this._maxListeners = n;
	  return this;
	};

	function _getMaxListeners$2(that) {
	  if (that._maxListeners === undefined)
	    return EventEmitter$1$2.defaultMaxListeners;
	  return that._maxListeners;
	}

	EventEmitter$1$2.prototype.getMaxListeners = function getMaxListeners() {
	  return _getMaxListeners$2(this);
	};

	EventEmitter$1$2.prototype.emit = function emit(type) {
	  var args = [];
	  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
	  var doError = (type === 'error');

	  var events = this._events;
	  if (events !== undefined)
	    doError = (doError && events.error === undefined);
	  else if (!doError)
	    return false;

	  // If there is no 'error' event listener then throw.
	  if (doError) {
	    var er;
	    if (args.length > 0)
	      er = args[0];
	    if (er instanceof Error) {
	      // Note: The comments on the `throw` lines are intentional, they show
	      // up in Node's output if this results in an unhandled exception.
	      throw er; // Unhandled 'error' event
	    }
	    // At least give some kind of context to the user
	    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
	    err.context = er;
	    throw err; // Unhandled 'error' event
	  }

	  var handler = events[type];

	  if (handler === undefined)
	    return false;

	  if (typeof handler === 'function') {
	    ReflectApply$2(handler, this, args);
	  } else {
	    var len = handler.length;
	    var listeners = arrayClone$2(handler, len);
	    for (var i = 0; i < len; ++i)
	      ReflectApply$2(listeners[i], this, args);
	  }

	  return true;
	};

	function _addListener$2(target, type, listener, prepend) {
	  var m;
	  var events;
	  var existing;

	  checkListener$2(listener);

	  events = target._events;
	  if (events === undefined) {
	    events = target._events = Object.create(null);
	    target._eventsCount = 0;
	  } else {
	    // To avoid recursion in the case that type === "newListener"! Before
	    // adding it to the listeners, first emit "newListener".
	    if (events.newListener !== undefined) {
	      target.emit('newListener', type,
	                  listener.listener ? listener.listener : listener);

	      // Re-assign `events` because a newListener handler could have caused the
	      // this._events to be assigned to a new object
	      events = target._events;
	    }
	    existing = events[type];
	  }

	  if (existing === undefined) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    existing = events[type] = listener;
	    ++target._eventsCount;
	  } else {
	    if (typeof existing === 'function') {
	      // Adding the second element, need to change to array.
	      existing = events[type] =
	        prepend ? [listener, existing] : [existing, listener];
	      // If we've already got an array, just append.
	    } else if (prepend) {
	      existing.unshift(listener);
	    } else {
	      existing.push(listener);
	    }

	    // Check for listener leak
	    m = _getMaxListeners$2(target);
	    if (m > 0 && existing.length > m && !existing.warned) {
	      existing.warned = true;
	      // No error code for this since it is a Warning
	      // eslint-disable-next-line no-restricted-syntax
	      var w = new Error('Possible EventEmitter memory leak detected. ' +
	                          existing.length + ' ' + String(type) + ' listeners ' +
	                          'added. Use emitter.setMaxListeners() to ' +
	                          'increase limit');
	      w.name = 'MaxListenersExceededWarning';
	      w.emitter = target;
	      w.type = type;
	      w.count = existing.length;
	      ProcessEmitWarning$2(w);
	    }
	  }

	  return target;
	}

	EventEmitter$1$2.prototype.addListener = function addListener(type, listener) {
	  return _addListener$2(this, type, listener, false);
	};

	EventEmitter$1$2.prototype.on = EventEmitter$1$2.prototype.addListener;

	EventEmitter$1$2.prototype.prependListener =
	    function prependListener(type, listener) {
	      return _addListener$2(this, type, listener, true);
	    };

	function onceWrapper$2() {
	  if (!this.fired) {
	    this.target.removeListener(this.type, this.wrapFn);
	    this.fired = true;
	    if (arguments.length === 0)
	      return this.listener.call(this.target);
	    return this.listener.apply(this.target, arguments);
	  }
	}

	function _onceWrap$2(target, type, listener) {
	  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
	  var wrapped = onceWrapper$2.bind(state);
	  wrapped.listener = listener;
	  state.wrapFn = wrapped;
	  return wrapped;
	}

	EventEmitter$1$2.prototype.once = function once(type, listener) {
	  checkListener$2(listener);
	  this.on(type, _onceWrap$2(this, type, listener));
	  return this;
	};

	EventEmitter$1$2.prototype.prependOnceListener =
	    function prependOnceListener(type, listener) {
	      checkListener$2(listener);
	      this.prependListener(type, _onceWrap$2(this, type, listener));
	      return this;
	    };

	// Emits a 'removeListener' event if and only if the listener was removed.
	EventEmitter$1$2.prototype.removeListener =
	    function removeListener(type, listener) {
	      var list, events, position, i, originalListener;

	      checkListener$2(listener);

	      events = this._events;
	      if (events === undefined)
	        return this;

	      list = events[type];
	      if (list === undefined)
	        return this;

	      if (list === listener || list.listener === listener) {
	        if (--this._eventsCount === 0)
	          this._events = Object.create(null);
	        else {
	          delete events[type];
	          if (events.removeListener)
	            this.emit('removeListener', type, list.listener || listener);
	        }
	      } else if (typeof list !== 'function') {
	        position = -1;

	        for (i = list.length - 1; i >= 0; i--) {
	          if (list[i] === listener || list[i].listener === listener) {
	            originalListener = list[i].listener;
	            position = i;
	            break;
	          }
	        }

	        if (position < 0)
	          return this;

	        if (position === 0)
	          list.shift();
	        else {
	          spliceOne$2(list, position);
	        }

	        if (list.length === 1)
	          events[type] = list[0];

	        if (events.removeListener !== undefined)
	          this.emit('removeListener', type, originalListener || listener);
	      }

	      return this;
	    };

	EventEmitter$1$2.prototype.off = EventEmitter$1$2.prototype.removeListener;

	EventEmitter$1$2.prototype.removeAllListeners =
	    function removeAllListeners(type) {
	      var listeners, events, i;

	      events = this._events;
	      if (events === undefined)
	        return this;

	      // not listening for removeListener, no need to emit
	      if (events.removeListener === undefined) {
	        if (arguments.length === 0) {
	          this._events = Object.create(null);
	          this._eventsCount = 0;
	        } else if (events[type] !== undefined) {
	          if (--this._eventsCount === 0)
	            this._events = Object.create(null);
	          else
	            delete events[type];
	        }
	        return this;
	      }

	      // emit removeListener for all listeners on all events
	      if (arguments.length === 0) {
	        var keys = Object.keys(events);
	        var key;
	        for (i = 0; i < keys.length; ++i) {
	          key = keys[i];
	          if (key === 'removeListener') continue;
	          this.removeAllListeners(key);
	        }
	        this.removeAllListeners('removeListener');
	        this._events = Object.create(null);
	        this._eventsCount = 0;
	        return this;
	      }

	      listeners = events[type];

	      if (typeof listeners === 'function') {
	        this.removeListener(type, listeners);
	      } else if (listeners !== undefined) {
	        // LIFO order
	        for (i = listeners.length - 1; i >= 0; i--) {
	          this.removeListener(type, listeners[i]);
	        }
	      }

	      return this;
	    };

	function _listeners$2(target, type, unwrap) {
	  var events = target._events;

	  if (events === undefined)
	    return [];

	  var evlistener = events[type];
	  if (evlistener === undefined)
	    return [];

	  if (typeof evlistener === 'function')
	    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

	  return unwrap ?
	    unwrapListeners$2(evlistener) : arrayClone$2(evlistener, evlistener.length);
	}

	EventEmitter$1$2.prototype.listeners = function listeners(type) {
	  return _listeners$2(this, type, true);
	};

	EventEmitter$1$2.prototype.rawListeners = function rawListeners(type) {
	  return _listeners$2(this, type, false);
	};

	EventEmitter$1$2.listenerCount = function(emitter, type) {
	  if (typeof emitter.listenerCount === 'function') {
	    return emitter.listenerCount(type);
	  } else {
	    return listenerCount$2.call(emitter, type);
	  }
	};

	EventEmitter$1$2.prototype.listenerCount = listenerCount$2;
	function listenerCount$2(type) {
	  var events = this._events;

	  if (events !== undefined) {
	    var evlistener = events[type];

	    if (typeof evlistener === 'function') {
	      return 1;
	    } else if (evlistener !== undefined) {
	      return evlistener.length;
	    }
	  }

	  return 0;
	}

	EventEmitter$1$2.prototype.eventNames = function eventNames() {
	  return this._eventsCount > 0 ? ReflectOwnKeys$2(this._events) : [];
	};

	function arrayClone$2(arr, n) {
	  var copy = new Array(n);
	  for (var i = 0; i < n; ++i)
	    copy[i] = arr[i];
	  return copy;
	}

	function spliceOne$2(list, index) {
	  for (; index + 1 < list.length; index++)
	    list[index] = list[index + 1];
	  list.pop();
	}

	function unwrapListeners$2(arr) {
	  var ret = new Array(arr.length);
	  for (var i = 0; i < ret.length; ++i) {
	    ret[i] = arr[i].listener || arr[i];
	  }
	  return ret;
	}

	function once$2(emitter, name) {
	  return new Promise(function (resolve, reject) {
	    function errorListener(err) {
	      emitter.removeListener(name, resolver);
	      reject(err);
	    }

	    function resolver() {
	      if (typeof emitter.removeListener === 'function') {
	        emitter.removeListener('error', errorListener);
	      }
	      resolve([].slice.call(arguments));
	    }
	    eventTargetAgnosticAddListener$2(emitter, name, resolver, { once: true });
	    if (name !== 'error') {
	      addErrorHandlerIfEventEmitter$2(emitter, errorListener, { once: true });
	    }
	  });
	}

	function addErrorHandlerIfEventEmitter$2(emitter, handler, flags) {
	  if (typeof emitter.on === 'function') {
	    eventTargetAgnosticAddListener$2(emitter, 'error', handler, flags);
	  }
	}

	function eventTargetAgnosticAddListener$2(emitter, name, listener, flags) {
	  if (typeof emitter.on === 'function') {
	    if (flags.once) {
	      emitter.once(name, listener);
	    } else {
	      emitter.on(name, listener);
	    }
	  } else if (typeof emitter.addEventListener === 'function') {
	    // EventTarget does not have `error` event semantics like Node
	    // EventEmitters, we do not listen for `error` events here.
	    emitter.addEventListener(name, function wrapListener(arg) {
	      // IE does not have builtin `{ once: true }` support so we
	      // have to do it manually.
	      if (flags.once) {
	        emitter.removeEventListener(name, wrapListener);
	      }
	      listener(arg);
	    });
	  } else {
	    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
	  }
	}

	Object.defineProperty(dist$4, '__esModule', { value: true });

	var EventEmitter$4 = events$2.exports;

	function _interopDefaultLegacy$4 (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var EventEmitter__default$3 = /*#__PURE__*/_interopDefaultLegacy$4(EventEmitter$4);

	const __RΦ$s$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$s$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$s$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$s$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [95]: { LΦ: t => SyntaxError }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Обработчик синтаксической ошибки в коде source.
	 * @param error
	 * @param source
	 */
	function syntaxErrorHandler$3(error, source) {
	    console.group('Синтаксическая ошибка');
	    console.log(error.message);
	    console.log(source);
	    console.log(error.stack);
	    console.groupEnd();
	}
	__RΦ$s$3.m("rt:p", [{ n: "error", t: () => __RΦ$s$3.a(95), v: null }, { n: "source", t: () => __RΦ$s$3.a(14), v: null }])(syntaxErrorHandler$3);
	__RΦ$s$3.m("rt:f", "F")(syntaxErrorHandler$3);
	__RΦ$s$3.m("rt:t", () => __RΦ$s$3.a(23))(syntaxErrorHandler$3);

	const __RΦ$r$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$r$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$r$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$r$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [112]: { LΦ: t => Object } } };
	/**
	 * Выполнить скрипт из текста, который возвращает значение типа T.
	 * @param source
	 */
	function execFunctionScript$3(source) {
	    if (!source.trim()) {
	        throw new Error('Не задано тело функции');
	    }
	    try {
	        const code = new Function('', `return (${source})`);
	        return code();
	    }
	    catch (error) {
	        if (error instanceof SyntaxError) {
	            syntaxErrorHandler$3(error, source);
	        }
	        throw error;
	    }
	}
	__RΦ$r$3.m("rt:p", [{ n: "source", t: () => __RΦ$r$3.a(14), v: null }])(execFunctionScript$3);
	__RΦ$r$3.m("rt:f", "F")(execFunctionScript$3);
	__RΦ$r$3.m("rt:t", () => __RΦ$r$3.a(112))(execFunctionScript$3);

	const __RΦ$q$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$q$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$q$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$q$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [113]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$q$3.a(10), __RΦ$q$3.a(14)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Выполнить скрипт из текста, который ничего не возвращает.
	 * @param source
	 */
	function execActionScript$3(source) {
	    if (source) {
	        try {
	            const code = new Function('', source);
	            code();
	        }
	        catch (error) {
	            if (error instanceof SyntaxError) {
	                syntaxErrorHandler$3(error, source);
	            }
	            throw error;
	        }
	    }
	}
	__RΦ$q$3.m("rt:p", [{ n: "source", t: () => __RΦ$q$3.a(113), v: null }])(execActionScript$3);
	__RΦ$q$3.m("rt:f", "F")(execActionScript$3);
	__RΦ$q$3.m("rt:t", () => __RΦ$q$3.a(23))(execActionScript$3);

	const __RΦ$p$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$p$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$p$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$p$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String } } };
	const SPACE$3 = ' ';
	const EOL$3 = '\n';
	const trim$3 = __RΦ$p$3.f((message) => message.trim()
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	, [__RΦ$p$3.m("rt:p", [{ n: "message", t: () => __RΦ$p$3.a(14), v: null }]), __RΦ$p$3.m("rt:f", "F>"), __RΦ$p$3.m("rt:t", () => __RΦ$p$3.a(14))], "trim");
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	function toOneLine$3(message) {
	    return message.trim().split(EOL$3).map(trim$3).join(SPACE$3);
	}
	__RΦ$p$3.m("rt:p", [{ n: "message", t: () => __RΦ$p$3.a(14), v: null }])(toOneLine$3);
	__RΦ$p$3.m("rt:f", "F")(toOneLine$3);
	__RΦ$p$3.m("rt:t", () => __RΦ$p$3.a(14))(toOneLine$3);

	const __RΦ$o$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$o$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$o$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$o$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1]: { RΦ: t => ({ TΦ: "~" }) } } };
	function isBrowser$3() {
	    return new Function('try { return this === window } catch (e) { return false }')();
	}
	__RΦ$o$3.m("rt:p", [])(isBrowser$3);
	__RΦ$o$3.m("rt:f", "F")(isBrowser$3);
	__RΦ$o$3.m("rt:t", () => __RΦ$o$3.a(1))(isBrowser$3);

	const __RΦ$n$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$n$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$n$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$n$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [21]: { LΦ: t => Boolean } } };
	var IΦdefault$9$3 = { name: "IStoppable", prototype: {}, identity: Symbol("IStoppable (interface)") };
	(t => __RΦ$n$3.t[150] = t)(IΦdefault$9$3);
	__RΦ$n$3.m("rt:P", [])(IΦdefault$9$3);
	__RΦ$n$3.m("rt:m", ["stop"])(IΦdefault$9$3);
	__RΦ$n$3.m("rt:f", "Ie")(IΦdefault$9$3);
	__RΦ$n$3.m("rt:p", [])(IΦdefault$9$3.prototype, "stop");
	__RΦ$n$3.m("rt:f", "M")(IΦdefault$9$3.prototype, "stop");
	__RΦ$n$3.m("rt:t", () => __RΦ$n$3.a(23))(IΦdefault$9$3.prototype, "stop");
	__RΦ$n$3.m("rt:p", [])(IΦdefault$9$3.prototype, "stop");
	__RΦ$n$3.m("rt:f", "M")(IΦdefault$9$3.prototype, "stop");
	__RΦ$n$3.m("rt:t", () => __RΦ$n$3.a(23))(IΦdefault$9$3.prototype, "stop");
	function isStoppable$3(object) {
	    return 'stop' in object && typeof object.stop === 'function';
	}
	__RΦ$n$3.m("rt:p", [{ n: "object", t: () => __RΦ$n$3.a(1), v: null }])(isStoppable$3);
	__RΦ$n$3.m("rt:f", "F")(isStoppable$3);
	__RΦ$n$3.m("rt:t", () => __RΦ$n$3.a(21))(isStoppable$3);

	const __RΦ$m$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$m$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$m$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$m$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	class Angle$3 {
	    /**
	     * Конвертация угла из радиан в градусы.
	     * @param value
	     */
	    static toDegree(value) {
	        return value / Math.PI * 180;
	    }
	    /**
	     * Конвертация угла из градусов в радианы.
	     * @param value
	     */
	    static toRadian(value) {
	        return value * Math.PI / 180;
	    }
	}
	(t => __RΦ$m$3.t[686] = t)(Angle$3);
	__RΦ$m$3.m("rt:SP", [])(Angle$3);
	__RΦ$m$3.m("rt:P", [])(Angle$3);
	__RΦ$m$3.m("rt:Sm", ["toDegree", "toRadian"])(Angle$3);
	__RΦ$m$3.m("rt:m", [])(Angle$3);
	__RΦ$m$3.m("rt:f", "Ce")(Angle$3);
	__RΦ$m$3.m("rt:f", "M$S.")(Angle$3["toDegree"]);
	((t, p) => __RΦ$m$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle$3, "toDegree");
	__RΦ$m$3.m("rt:p", [{ n: "value", t: () => __RΦ$m$3.a(15), v: null }])(Angle$3, "toDegree");
	__RΦ$m$3.m("rt:f", "M$S.")(Angle$3, "toDegree");
	__RΦ$m$3.m("rt:t", () => __RΦ$m$3.a(15))(Angle$3, "toDegree");
	__RΦ$m$3.m("rt:f", "M$S.")(Angle$3["toRadian"]);
	((t, p) => __RΦ$m$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle$3, "toRadian");
	__RΦ$m$3.m("rt:p", [{ n: "value", t: () => __RΦ$m$3.a(15), v: null }])(Angle$3, "toRadian");
	__RΦ$m$3.m("rt:f", "M$S.")(Angle$3, "toRadian");
	__RΦ$m$3.m("rt:t", () => __RΦ$m$3.a(15))(Angle$3, "toRadian");

	const __RΦ$l$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$l$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$l$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$l$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	var IΦdefault$8$3 = { name: "IPoint", prototype: {}, identity: Symbol("IPoint (interface)") };
	(t => __RΦ$l$3.t[141] = t)(IΦdefault$8$3);
	__RΦ$l$3.m("rt:P", ["x", "y"])(IΦdefault$8$3);
	__RΦ$l$3.m("rt:m", [])(IΦdefault$8$3);
	__RΦ$l$3.m("rt:f", "Ie")(IΦdefault$8$3);
	__RΦ$l$3.m("rt:t", () => __RΦ$l$3.a(15))(IΦdefault$8$3.prototype, "x");
	__RΦ$l$3.m("rt:f", "P")(IΦdefault$8$3.prototype, "x");
	__RΦ$l$3.m("rt:t", () => __RΦ$l$3.a(15))(IΦdefault$8$3.prototype, "y");
	__RΦ$l$3.m("rt:f", "P")(IΦdefault$8$3.prototype, "y");
	__RΦ$l$3.m("rt:t", () => __RΦ$l$3.a(15))(IΦdefault$8$3.prototype, "x");
	__RΦ$l$3.m("rt:f", "P")(IΦdefault$8$3.prototype, "x");
	__RΦ$l$3.m("rt:t", () => __RΦ$l$3.a(15))(IΦdefault$8$3.prototype, "y");
	__RΦ$l$3.m("rt:f", "P")(IΦdefault$8$3.prototype, "y");

	const __RΦ$k$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$k$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$k$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$k$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [141]: { LΦ: t => IΦdefault$8$3 }, [674]: { TΦ: "5", name: "default" }, [21]: { LΦ: t => Boolean }, [684]: { RΦ: t => ({ TΦ: "[", e: __RΦ$k$3.a(15) }) }, [14]: { LΦ: t => String } } };
	/*
	 * Увеличить длину вектора можно так:
	 * Vector.translate(Vector.identity.scale(length))
	 *
	 */
	/**
	 * Вектор.
	 * @unmutable
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/vector/Vector.js
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/Point.js
	 */
	class Vector$3 {
	    x;
	    y;
	    /**
	     * Расстояние от начала координат до точки.
	     */
	    static distance(point) {
	        // noinspection JSSuspiciousNameCombination
	        return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
	    }
	    /**
	     * Создать вектор на основе угла и длины.
	     */
	    static create(angle, length) {
	        return new Vector$3(length * Math.cos(angle), length * Math.sin(angle));
	    }
	    /**
	     * Угол между вектором и положительной осью.
	     * Принимает значение от -Math.PI до Math.PI радиан.
	     */
	    get angle() {
	        return Math.atan2(this.y, this.x);
	    }
	    /**
	     * Модуль (длина) вектора.
	     */
	    get length() {
	        return Vector$3.distance(this);
	    }
	    /**
	     * Возвращает true, если вектор является нулевым.
	     */
	    get isNull() {
	        return this.x === 0 && this.y === 0;
	    }
	    /**
	     * Конструктор вектора.
	     * @param x
	     * @param y
	     */
	    constructor(x = 0, y = 0) {
	        this.x = x;
	        this.y = y;
	    }
	    /**
	     * Получить единичный вектор, равный по направлению исходному.
	     * Он же направляющий вектор (единичный, равный по направлению).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get identity() {
	        return (new Vector$3(Math.cos(this.angle), Math.sin(this.angle)));
	    }
	    /**
	     * Получить обратный вектор (инверсия вектора).
	     */
	    get inverse() {
	        return new Vector$3(-this.x, -this.y);
	    }
	    /**
	     * Нормаль вектора (единичный вектор, перпендикулярный исходному).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get normal() {
	        return this.clone().rotate(Math.PI / 2).identity;
	        // TODO Проверить эту формулу нахождения перпендикулярного вектора.
	        /*
	            a: 1 / parallel.x(),
	            b: -1 / parallel.y(),
	        */
	    }
	    /**
	     * Сложение векторов.
	     * @param vector
	     */
	    translate(vector) {
	        return new Vector$3(this.x + vector.x, this.y + vector.y);
	    }
	    /**
	     * Вращение вектора.
	     * @param angle
	     */
	    rotate(angle) {
	        return new Vector$3(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle));
	    }
	    /**
	     * Умножение вектора на число.
	     */
	    scale(scale) {
	        return new Vector$3(this.x * scale, this.y * scale);
	    }
	    /**
	     * Скалярное произведение векторов.
	     * @param vector
	     */
	    multiply(vector) {
	        return new Vector$3(this.x * vector.x, this.y * vector.y);
	    }
	    /**
	     * Взятие остатка от деления.
	     * @param vector
	     */
	    mod(vector) {
	        return new Vector$3(this.x % vector.x, this.y % vector.y);
	    }
	    clone() {
	        return new Vector$3(this.x, this.y);
	    }
	    toArray() {
	        return [this.x, this.y];
	    }
	    toString(digits = 2) {
	        return `[${this.x.toFixed(digits)}, ${this.y.toFixed(digits)}]`;
	    }
	}
	(t => __RΦ$k$3.t[674] = t)(Vector$3);
	__RΦ$k$3.m("rt:SP", [])(Vector$3);
	__RΦ$k$3.m("rt:P", ["angle", "length", "isNull", "x", "y", "identity", "inverse", "normal"])(Vector$3);
	__RΦ$k$3.m("rt:Sm", ["distance", "create"])(Vector$3);
	__RΦ$k$3.m("rt:m", ["translate", "rotate", "scale", "multiply", "mod", "clone", "toArray", "toString"])(Vector$3);
	__RΦ$k$3.m("rt:p", [{ n: "x", t: () => __RΦ$k$3.a(15), v: function () { return 0; }, f: "$R" }, { n: "y", t: () => __RΦ$k$3.a(15), v: function () { return 0; }, f: "$R" }])(Vector$3);
	__RΦ$k$3.m("rt:i", [() => undefined])(Vector$3);
	__RΦ$k$3.m("rt:f", "Ce")(Vector$3);
	__RΦ$k$3.m("rt:f", "M$S")(Vector$3["distance"]);
	((t, p) => __RΦ$k$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$3, "distance");
	__RΦ$k$3.m("rt:p", [{ n: "point", t: () => __RΦ$k$3.a(141), v: null }])(Vector$3, "distance");
	__RΦ$k$3.m("rt:f", "M$S")(Vector$3, "distance");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(15))(Vector$3, "distance");
	__RΦ$k$3.m("rt:f", "M$S")(Vector$3["create"]);
	((t, p) => __RΦ$k$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$3, "create");
	__RΦ$k$3.m("rt:p", [{ n: "angle", t: () => __RΦ$k$3.a(15), v: null }, { n: "length", t: () => __RΦ$k$3.a(15), v: null }])(Vector$3, "create");
	__RΦ$k$3.m("rt:f", "M$S")(Vector$3, "create");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(674))(Vector$3, "create");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(15))(Vector$3.prototype, "angle");
	__RΦ$k$3.m("rt:f", "P$")(Vector$3.prototype, "angle");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(15))(Vector$3.prototype, "length");
	__RΦ$k$3.m("rt:f", "P$")(Vector$3.prototype, "length");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(21))(Vector$3.prototype, "isNull");
	__RΦ$k$3.m("rt:f", "P$")(Vector$3.prototype, "isNull");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(674))(Vector$3.prototype, "identity");
	__RΦ$k$3.m("rt:f", "P$")(Vector$3.prototype, "identity");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(674))(Vector$3.prototype, "inverse");
	__RΦ$k$3.m("rt:f", "P$")(Vector$3.prototype, "inverse");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(674))(Vector$3.prototype, "normal");
	__RΦ$k$3.m("rt:f", "P$")(Vector$3.prototype, "normal");
	__RΦ$k$3.m("rt:f", "M$")(Vector$3.prototype["translate"]);
	((t, p) => __RΦ$k$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$3.prototype, "translate");
	__RΦ$k$3.m("rt:p", [{ n: "vector", t: () => __RΦ$k$3.a(674), v: null }])(Vector$3.prototype, "translate");
	__RΦ$k$3.m("rt:f", "M$")(Vector$3.prototype, "translate");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(674))(Vector$3.prototype, "translate");
	__RΦ$k$3.m("rt:f", "M$.")(Vector$3.prototype["rotate"]);
	((t, p) => __RΦ$k$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$3.prototype, "rotate");
	__RΦ$k$3.m("rt:p", [{ n: "angle", t: () => __RΦ$k$3.a(15), v: null }])(Vector$3.prototype, "rotate");
	__RΦ$k$3.m("rt:f", "M$.")(Vector$3.prototype, "rotate");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(674))(Vector$3.prototype, "rotate");
	__RΦ$k$3.m("rt:f", "M$.")(Vector$3.prototype["scale"]);
	((t, p) => __RΦ$k$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$3.prototype, "scale");
	__RΦ$k$3.m("rt:p", [{ n: "scale", t: () => __RΦ$k$3.a(15), v: null }])(Vector$3.prototype, "scale");
	__RΦ$k$3.m("rt:f", "M$.")(Vector$3.prototype, "scale");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(674))(Vector$3.prototype, "scale");
	__RΦ$k$3.m("rt:f", "M$")(Vector$3.prototype["multiply"]);
	((t, p) => __RΦ$k$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$3.prototype, "multiply");
	__RΦ$k$3.m("rt:p", [{ n: "vector", t: () => __RΦ$k$3.a(674), v: null }])(Vector$3.prototype, "multiply");
	__RΦ$k$3.m("rt:f", "M$")(Vector$3.prototype, "multiply");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(674))(Vector$3.prototype, "multiply");
	__RΦ$k$3.m("rt:f", "M$")(Vector$3.prototype["mod"]);
	((t, p) => __RΦ$k$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$3.prototype, "mod");
	__RΦ$k$3.m("rt:p", [{ n: "vector", t: () => __RΦ$k$3.a(674), v: null }])(Vector$3.prototype, "mod");
	__RΦ$k$3.m("rt:f", "M$")(Vector$3.prototype, "mod");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(674))(Vector$3.prototype, "mod");
	__RΦ$k$3.m("rt:f", "M$.")(Vector$3.prototype["clone"]);
	((t, p) => __RΦ$k$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$3.prototype, "clone");
	__RΦ$k$3.m("rt:p", [])(Vector$3.prototype, "clone");
	__RΦ$k$3.m("rt:f", "M$.")(Vector$3.prototype, "clone");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(674))(Vector$3.prototype, "clone");
	__RΦ$k$3.m("rt:f", "M$.")(Vector$3.prototype["toArray"]);
	((t, p) => __RΦ$k$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$3.prototype, "toArray");
	__RΦ$k$3.m("rt:p", [])(Vector$3.prototype, "toArray");
	__RΦ$k$3.m("rt:f", "M$.")(Vector$3.prototype, "toArray");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(684))(Vector$3.prototype, "toArray");
	__RΦ$k$3.m("rt:f", "M$.")(Vector$3.prototype["toString"]);
	((t, p) => __RΦ$k$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$3.prototype, "toString");
	__RΦ$k$3.m("rt:p", [{ n: "digits", t: () => __RΦ$k$3.a(15), v: function () { return 2; } }])(Vector$3.prototype, "toString");
	__RΦ$k$3.m("rt:f", "M$.")(Vector$3.prototype, "toString");
	__RΦ$k$3.m("rt:t", () => __RΦ$k$3.a(14))(Vector$3.prototype, "toString");

	const __RΦ$j$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$j$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$j$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$j$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [103]: { RΦ: t => ({ TΦ: "[", e: __RΦ$j$3.a(14) }) }, [14]: { LΦ: t => String }, [674]: { LΦ: t => Vector$3 }, [691]: { RΦ: t => ({ TΦ: "t" }) }, [15]: { LΦ: t => Number } } };
	class Transform$1 {
	    transforms = [];
	    scale({ x, y }) {
	        this.transforms.push(`scale(${x}, ${y})`);
	        return this;
	    }
	    rotate(angle) {
	        this.transforms.push(`rotate(${Angle$3.toDegree(angle)})`);
	        return this;
	    }
	    translate({ x, y }) {
	        this.transforms.push(`translate(${x}, ${y})`);
	        return this;
	    }
	    toString() {
	        return this.transforms.join(', ');
	    }
	}
	(t => __RΦ$j$3.t[690] = t)(Transform$1);
	__RΦ$j$3.m("rt:SP", [])(Transform$1);
	__RΦ$j$3.m("rt:P", ["transforms"])(Transform$1);
	__RΦ$j$3.m("rt:Sm", [])(Transform$1);
	__RΦ$j$3.m("rt:m", ["scale", "rotate", "translate", "toString"])(Transform$1);
	__RΦ$j$3.m("rt:f", "Ce")(Transform$1);
	__RΦ$j$3.m("rt:t", () => __RΦ$j$3.a(103))(Transform$1.prototype, "transforms");
	__RΦ$j$3.m("rt:f", "P#")(Transform$1.prototype, "transforms");
	__RΦ$j$3.m("rt:f", "M$")(Transform$1.prototype["scale"]);
	((t, p) => __RΦ$j$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Transform$1.prototype, "scale");
	__RΦ$j$3.m("rt:p", [{ n: "{x, y}", t: () => __RΦ$j$3.a(674), v: null }])(Transform$1.prototype, "scale");
	__RΦ$j$3.m("rt:f", "M$")(Transform$1.prototype, "scale");
	__RΦ$j$3.m("rt:t", () => __RΦ$j$3.a(691))(Transform$1.prototype, "scale");
	__RΦ$j$3.m("rt:f", "M$")(Transform$1.prototype["rotate"]);
	((t, p) => __RΦ$j$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Transform$1.prototype, "rotate");
	__RΦ$j$3.m("rt:p", [{ n: "angle", t: () => __RΦ$j$3.a(15), v: null }])(Transform$1.prototype, "rotate");
	__RΦ$j$3.m("rt:f", "M$")(Transform$1.prototype, "rotate");
	__RΦ$j$3.m("rt:t", () => __RΦ$j$3.a(691))(Transform$1.prototype, "rotate");
	__RΦ$j$3.m("rt:f", "M$")(Transform$1.prototype["translate"]);
	((t, p) => __RΦ$j$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Transform$1.prototype, "translate");
	__RΦ$j$3.m("rt:p", [{ n: "{x, y}", t: () => __RΦ$j$3.a(674), v: null }])(Transform$1.prototype, "translate");
	__RΦ$j$3.m("rt:f", "M$")(Transform$1.prototype, "translate");
	__RΦ$j$3.m("rt:t", () => __RΦ$j$3.a(691))(Transform$1.prototype, "translate");
	__RΦ$j$3.m("rt:f", "M$")(Transform$1.prototype["toString"]);
	((t, p) => __RΦ$j$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Transform$1.prototype, "toString");
	__RΦ$j$3.m("rt:p", [])(Transform$1.prototype, "toString");
	__RΦ$j$3.m("rt:f", "M$")(Transform$1.prototype, "toString");
	__RΦ$j$3.m("rt:t", () => __RΦ$j$3.a(14))(Transform$1.prototype, "toString");

	const __RΦ$i$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$i$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$i$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$i$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$7$3 = { name: "IStartable", prototype: {}, identity: Symbol("IStartable (interface)") };
	(t => __RΦ$i$3.t[149] = t)(IΦdefault$7$3);
	__RΦ$i$3.m("rt:P", [])(IΦdefault$7$3);
	__RΦ$i$3.m("rt:m", ["start"])(IΦdefault$7$3);
	__RΦ$i$3.m("rt:f", "Ie")(IΦdefault$7$3);
	__RΦ$i$3.m("rt:p", [])(IΦdefault$7$3.prototype, "start");
	__RΦ$i$3.m("rt:f", "M")(IΦdefault$7$3.prototype, "start");
	__RΦ$i$3.m("rt:t", () => __RΦ$i$3.a(23))(IΦdefault$7$3.prototype, "start");
	__RΦ$i$3.m("rt:p", [])(IΦdefault$7$3.prototype, "start");
	__RΦ$i$3.m("rt:f", "M")(IΦdefault$7$3.prototype, "start");
	__RΦ$i$3.m("rt:t", () => __RΦ$i$3.a(23))(IΦdefault$7$3.prototype, "start");

	/**
	 * Состояния таймера.
	 */
	var ETimerState$3;
	(function (ETimerState) {
	    ETimerState["Started"] = "started";
	    ETimerState["Paused"] = "paused";
	    ETimerState["Stopped"] = "stopped";
	})(ETimerState$3 || (ETimerState$3 = {}));

	const __RΦ$h$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$h$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$h$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$h$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [700]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$h$3.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [701]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$h$3.a(4) }] }) }, [702]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$h$3.a(4) }] }) } } };
	var IΦdefault$6$3 = { name: "IStateHandlers", prototype: {}, identity: Symbol("IStateHandlers (interface)") };
	(t => __RΦ$h$3.t[703] = t)(IΦdefault$6$3);
	__RΦ$h$3.m("rt:P", ["started", "paused", "stopped"])(IΦdefault$6$3);
	__RΦ$h$3.m("rt:m", [])(IΦdefault$6$3);
	__RΦ$h$3.m("rt:f", "Ie")(IΦdefault$6$3);
	__RΦ$h$3.m("rt:t", () => __RΦ$h$3.a(700))(IΦdefault$6$3.prototype, "started");
	__RΦ$h$3.m("rt:f", "P?")(IΦdefault$6$3.prototype, "started");
	__RΦ$h$3.m("rt:t", () => __RΦ$h$3.a(701))(IΦdefault$6$3.prototype, "paused");
	__RΦ$h$3.m("rt:f", "P?")(IΦdefault$6$3.prototype, "paused");
	__RΦ$h$3.m("rt:t", () => __RΦ$h$3.a(702))(IΦdefault$6$3.prototype, "stopped");
	__RΦ$h$3.m("rt:f", "P?")(IΦdefault$6$3.prototype, "stopped");
	__RΦ$h$3.m("rt:t", () => __RΦ$h$3.a(700))(IΦdefault$6$3.prototype, "started");
	__RΦ$h$3.m("rt:f", "P?")(IΦdefault$6$3.prototype, "started");
	__RΦ$h$3.m("rt:t", () => __RΦ$h$3.a(701))(IΦdefault$6$3.prototype, "paused");
	__RΦ$h$3.m("rt:f", "P?")(IΦdefault$6$3.prototype, "paused");
	__RΦ$h$3.m("rt:t", () => __RΦ$h$3.a(702))(IΦdefault$6$3.prototype, "stopped");
	__RΦ$h$3.m("rt:f", "P?")(IΦdefault$6$3.prototype, "stopped");

	const __RΦ$g$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$g$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$g$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$g$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [723]: { RΦ: t => ({ TΦ: "e", e: ETimerState$3 }) }, [707]: { RΦ: t => ({ TΦ: "g", t: __RΦ$g$3.a(703), p: [__RΦ$g$3.a(706)] }) }, [703]: { LΦ: t => IΦdefault$6$3 }, [706]: { LΦ: t => Object }, [724]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$g$3.a(10), __RΦ$g$3.a(706)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	/**
	 * Запустить определенный скрипт в зависимости от состояния таймера.
	 * @param state Текущее состояние таймера.
	 * @param stateHandlers Массив скриптов (ключ - имя состояния, значение - скрипт).
	 */
	function handleByState$3(state, stateHandlers) {
	    switch (state) {
	        case ETimerState$3.Started: return stateHandlers.started ? stateHandlers.started() : undefined;
	        case ETimerState$3.Paused: return stateHandlers.paused ? stateHandlers.paused() : undefined;
	        case ETimerState$3.Stopped: return stateHandlers.stopped ? stateHandlers.stopped() : undefined;
	    }
	}
	__RΦ$g$3.m("rt:p", [{ n: "state", t: () => __RΦ$g$3.a(723), v: null }, { n: "stateHandlers", t: () => __RΦ$g$3.a(707), v: null }])(handleByState$3);
	__RΦ$g$3.m("rt:f", "F")(handleByState$3);
	__RΦ$g$3.m("rt:t", () => __RΦ$g$3.a(724))(handleByState$3);

	const __RΦ$f$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$f$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$f$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$f$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [1636]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$f$3.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [680]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$f$3.a(10), __RΦ$f$3.a(15)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [723]: { RΦ: t => ({ TΦ: "e", e: ETimerState$3 }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Простая реализация таймера.
	 */
	class Timer$3 {
	    timeout;
	    action;
	    timerId;
	    /**
	     * Время запуска таймера. В миллисекундах.
	     * @private
	     */
	    time = 0;
	    /**
	     * Время постановки на паузу. В миллисекундах.
	     * @private
	     */
	    pauseTime = 0;
	    /**
	     * Общее время остановки таймера. В миллисекундах.
	     * @private
	     */
	    pauseInterval = 0;
	    /**
	     * Текущее состояние таймера
	     * @private
	     */
	    state = ETimerState$3.Stopped;
	    /**
	     * Внимание, внутри action определена this как Timer.
	     * @param timeout
	     * @param action
	     */
	    constructor(timeout, action) {
	        this.timeout = timeout;
	        this.action = action;
	    }
	    /**
	     * Запуск таймера.
	     * Стартовать таймер сначала или продолжить с паузы.
	     */
	    start() {
	        handleByState$3(this.state, {
	            paused: __RΦ$f$3.f(() => {
	                this.state = ETimerState$3.Started;
	                this.pauseInterval += Date.now() - this.pauseTime;
	            }, [__RΦ$f$3.m("rt:p", []), __RΦ$f$3.m("rt:f", "F>"), __RΦ$f$3.m("rt:t", () => __RΦ$f$3.a(23))], "paused"),
	            stopped: __RΦ$f$3.f(() => {
	                this.state = ETimerState$3.Started;
	                this.timerId = window.setInterval(this.tick.bind(this), this.timeout);
	                this.time = Date.now();
	            }, [__RΦ$f$3.m("rt:p", []), __RΦ$f$3.m("rt:f", "F>"), __RΦ$f$3.m("rt:t", () => __RΦ$f$3.a(23))], "stopped")
	        });
	    }
	    /**
	     * Поставить на паузу таймер.
	     * Состояние сохраняется, счет приостанавливается.
	     */
	    pause() {
	        handleByState$3(this.state, {
	            started: __RΦ$f$3.f(() => {
	                this.state = ETimerState$3.Paused;
	                this.pauseTime = Date.now();
	            }, [__RΦ$f$3.m("rt:p", []), __RΦ$f$3.m("rt:f", "F>"), __RΦ$f$3.m("rt:t", () => __RΦ$f$3.a(23))], "started")
	        });
	    }
	    /**
	     * Остановить таймер.
	     * Полный сброс таймера.
	     */
	    stop() {
	        const stop = __RΦ$f$3.f(() => {
	            this.state = ETimerState$3.Stopped;
	            clearInterval(this.timerId);
	            this.timerId = undefined;
	            this.time = 0;
	        }, [__RΦ$f$3.m("rt:p", []), __RΦ$f$3.m("rt:f", "F>"), __RΦ$f$3.m("rt:t", () => __RΦ$f$3.a(23))], "stop");
	        handleByState$3(this.state, {
	            started: stop,
	            paused: stop
	        });
	    }
	    /**
	     * Количество миллисекунд с начала старта таймера.
	     * С учетом всех пауз.
	     */
	    get interval() {
	        const result = handleByState$3(this.state, {
	            started: () => Date.now() - this.time - this.pauseTime,
	            paused: () => this.time - this.pauseTime,
	            stopped: () => 0
	        });
	        return result === undefined ? 0 : result;
	    }
	    /**
	     * Выполняемая нагрузка таймера.
	     * @private
	     */
	    tick() {
	        handleByState$3(this.state, {
	            started: __RΦ$f$3.f(() => this.action.call(this), [__RΦ$f$3.m("rt:p", []), __RΦ$f$3.m("rt:f", "F>"), __RΦ$f$3.m("rt:t", () => __RΦ$f$3.a(23))], "started")
	        });
	    }
	}
	(t => __RΦ$f$3.t[726] = t)(Timer$3);
	__RΦ$f$3.m("rt:SP", [])(Timer$3);
	__RΦ$f$3.m("rt:P", ["timerId", "time", "pauseTime", "pauseInterval", "state", "timeout", "action", "interval"])(Timer$3);
	__RΦ$f$3.m("rt:Sm", [])(Timer$3);
	__RΦ$f$3.m("rt:m", ["start", "pause", "stop", "tick"])(Timer$3);
	__RΦ$f$3.m("rt:p", [{ n: "timeout", t: () => __RΦ$f$3.a(15), v: null, f: "#" }, { n: "action", t: () => __RΦ$f$3.a(1636), v: null, f: "#" }])(Timer$3);
	__RΦ$f$3.m("rt:i", [() => undefined, () => undefined])(Timer$3);
	__RΦ$f$3.m("rt:f", "Ce")(Timer$3);
	__RΦ$f$3.m("rt:t", () => __RΦ$f$3.a(680))(Timer$3.prototype, "timerId");
	__RΦ$f$3.m("rt:f", "P#")(Timer$3.prototype, "timerId");
	__RΦ$f$3.m("rt:t", () => __RΦ$f$3.a(15))(Timer$3.prototype, "time");
	__RΦ$f$3.m("rt:f", "P#")(Timer$3.prototype, "time");
	__RΦ$f$3.m("rt:t", () => __RΦ$f$3.a(15))(Timer$3.prototype, "pauseTime");
	__RΦ$f$3.m("rt:f", "P#")(Timer$3.prototype, "pauseTime");
	__RΦ$f$3.m("rt:t", () => __RΦ$f$3.a(15))(Timer$3.prototype, "pauseInterval");
	__RΦ$f$3.m("rt:f", "P#")(Timer$3.prototype, "pauseInterval");
	__RΦ$f$3.m("rt:t", () => __RΦ$f$3.a(723))(Timer$3.prototype, "state");
	__RΦ$f$3.m("rt:f", "P#")(Timer$3.prototype, "state");
	__RΦ$f$3.m("rt:f", "M$.")(Timer$3.prototype["start"]);
	((t, p) => __RΦ$f$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$3.prototype, "start");
	__RΦ$f$3.m("rt:p", [])(Timer$3.prototype, "start");
	__RΦ$f$3.m("rt:f", "M$.")(Timer$3.prototype, "start");
	__RΦ$f$3.m("rt:t", () => __RΦ$f$3.a(23))(Timer$3.prototype, "start");
	__RΦ$f$3.m("rt:f", "M$.")(Timer$3.prototype["pause"]);
	((t, p) => __RΦ$f$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$3.prototype, "pause");
	__RΦ$f$3.m("rt:p", [])(Timer$3.prototype, "pause");
	__RΦ$f$3.m("rt:f", "M$.")(Timer$3.prototype, "pause");
	__RΦ$f$3.m("rt:t", () => __RΦ$f$3.a(23))(Timer$3.prototype, "pause");
	__RΦ$f$3.m("rt:f", "M$.")(Timer$3.prototype["stop"]);
	((t, p) => __RΦ$f$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$3.prototype, "stop");
	__RΦ$f$3.m("rt:p", [])(Timer$3.prototype, "stop");
	__RΦ$f$3.m("rt:f", "M$.")(Timer$3.prototype, "stop");
	__RΦ$f$3.m("rt:t", () => __RΦ$f$3.a(23))(Timer$3.prototype, "stop");
	__RΦ$f$3.m("rt:t", () => __RΦ$f$3.a(15))(Timer$3.prototype, "interval");
	__RΦ$f$3.m("rt:f", "P$")(Timer$3.prototype, "interval");
	__RΦ$f$3.m("rt:f", "M#.")(Timer$3.prototype["tick"]);
	((t, p) => __RΦ$f$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$3.prototype, "tick");
	__RΦ$f$3.m("rt:p", [])(Timer$3.prototype, "tick");
	__RΦ$f$3.m("rt:f", "M#.")(Timer$3.prototype, "tick");
	__RΦ$f$3.m("rt:t", () => __RΦ$f$3.a(23))(Timer$3.prototype, "tick");

	const __RΦ$e$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$e$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$e$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$e$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1640]: { LΦ: t => Object } } };
	var IΦdefault$5$3 = { name: "ICreator", prototype: {}, identity: Symbol("ICreator (interface)") };
	(t => __RΦ$e$3.t[1641] = t)(IΦdefault$5$3);
	__RΦ$e$3.m("rt:P", [])(IΦdefault$5$3);
	__RΦ$e$3.m("rt:m", ["create"])(IΦdefault$5$3);
	__RΦ$e$3.m("rt:f", "Ie")(IΦdefault$5$3);
	__RΦ$e$3.m("rt:p", [])(IΦdefault$5$3.prototype, "create");
	__RΦ$e$3.m("rt:f", "M")(IΦdefault$5$3.prototype, "create");
	__RΦ$e$3.m("rt:t", () => __RΦ$e$3.a(1640))(IΦdefault$5$3.prototype, "create");
	__RΦ$e$3.m("rt:p", [])(IΦdefault$5$3.prototype, "create");
	__RΦ$e$3.m("rt:f", "M")(IΦdefault$5$3.prototype, "create");
	__RΦ$e$3.m("rt:t", () => __RΦ$e$3.a(1640))(IΦdefault$5$3.prototype, "create");

	const __RΦ$d$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$d$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$d$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$d$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1643]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$d$4.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1651]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$d$4.a(10), __RΦ$d$4.a(1645)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1645]: { LΦ: t => Object }, [1648]: { RΦ: t => ({ TΦ: "g", t: __RΦ$d$4.a(1641), p: [__RΦ$d$4.a(1645)] }) }, [1641]: { LΦ: t => IΦdefault$5$3 } } };
	/**
	 * Отложенная инициализация.
	 * @link https://metanit.com/sharp/tutorial/20.1.php
	 * @link https://docs.microsoft.com/ru-ru/dotnet/api/system.lazy-1?view=net-5.0
	 */
	class Lazy$3 {
	    createFn;
	    #value;
	    #creator;
	    constructor(createFn) {
	        this.createFn = createFn;
	        this.#creator = {
	            create() {
	                return createFn();
	            }
	        };
	    }
	    get value() {
	        if (!this.#value) {
	            this.#value = this.#creator.create();
	        }
	        return this.#value;
	    }
	}
	(t => __RΦ$d$4.t[1644] = t)(Lazy$3);
	__RΦ$d$4.m("rt:SP", [])(Lazy$3);
	__RΦ$d$4.m("rt:P", ["#value", "#creator", "createFn", "value"])(Lazy$3);
	__RΦ$d$4.m("rt:Sm", [])(Lazy$3);
	__RΦ$d$4.m("rt:m", [])(Lazy$3);
	__RΦ$d$4.m("rt:p", [{ n: "createFn", t: () => __RΦ$d$4.a(1643), v: null, f: "#" }])(Lazy$3);
	__RΦ$d$4.m("rt:f", "Ce")(Lazy$3);
	__RΦ$d$4.m("rt:t", () => __RΦ$d$4.a(1651))(Lazy$3.prototype, "#value");
	__RΦ$d$4.m("rt:f", "P")(Lazy$3.prototype, "#value");
	__RΦ$d$4.m("rt:t", () => __RΦ$d$4.a(1648))(Lazy$3.prototype, "#creator");
	__RΦ$d$4.m("rt:f", "P")(Lazy$3.prototype, "#creator");
	__RΦ$d$4.m("rt:t", () => __RΦ$d$4.a(1645))(Lazy$3.prototype, "value");
	__RΦ$d$4.m("rt:f", "P")(Lazy$3.prototype, "value");

	const __RΦ$c$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$c$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$c$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$c$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [151]: { LΦ: t => Object }, [152]: { LΦ: t => Object } } };
	var IΦdefault$4$3 = { name: "IKeyValueObject", prototype: {}, identity: Symbol("IKeyValueObject (interface)") };
	(t => __RΦ$c$4.t[153] = t)(IΦdefault$4$3);
	__RΦ$c$4.m("rt:P", ["key", "value"])(IΦdefault$4$3);
	__RΦ$c$4.m("rt:m", [])(IΦdefault$4$3);
	__RΦ$c$4.m("rt:f", "Ie")(IΦdefault$4$3);
	__RΦ$c$4.m("rt:t", () => __RΦ$c$4.a(151))(IΦdefault$4$3.prototype, "key");
	__RΦ$c$4.m("rt:f", "P")(IΦdefault$4$3.prototype, "key");
	__RΦ$c$4.m("rt:t", () => __RΦ$c$4.a(152))(IΦdefault$4$3.prototype, "value");
	__RΦ$c$4.m("rt:f", "P")(IΦdefault$4$3.prototype, "value");
	__RΦ$c$4.m("rt:t", () => __RΦ$c$4.a(151))(IΦdefault$4$3.prototype, "key");
	__RΦ$c$4.m("rt:f", "P")(IΦdefault$4$3.prototype, "key");
	__RΦ$c$4.m("rt:t", () => __RΦ$c$4.a(152))(IΦdefault$4$3.prototype, "value");
	__RΦ$c$4.m("rt:f", "P")(IΦdefault$4$3.prototype, "value");

	const __RΦ$b$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$b$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$b$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$b$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1838]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$4.a(156), p: [__RΦ$b$4.a(1836), __RΦ$b$4.a(1837)] }) }, [156]: { LΦ: t => Map }, [1836]: { LΦ: t => Object }, [1837]: { LΦ: t => Object }, [1842]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$4.a(1846) }) }, [1846]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$4.a(153), p: [__RΦ$b$4.a(1836), __RΦ$b$4.a(1845)] }) }, [153]: { LΦ: t => IΦdefault$4$3 }, [1845]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b$4.a(10), __RΦ$b$4.a(1837)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1849]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b$4.a(1850), p: [__RΦ$b$4.a(1847), __RΦ$b$4.a(1848)] }) }, [1850]: { LΦ: t => Object }, [1847]: { LΦ: t => Object }, [1848]: { LΦ: t => Object }, [1854]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$4.a(1856) }) }, [1856]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$4.a(153), p: [__RΦ$b$4.a(1847), __RΦ$b$4.a(1848)] }) }, [1673]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b$4.a(1666), __RΦ$b$4.a(1671)] }) }, [1666]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$4.a(156), p: [__RΦ$b$4.a(1655), __RΦ$b$4.a(1656)] }) }, [1655]: { LΦ: t => Object }, [1656]: { LΦ: t => Object }, [1671]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b$4.a(1672), p: [__RΦ$b$4.a(1655), __RΦ$b$4.a(1656)] }) }, [1672]: { LΦ: t => Object }, [1657]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$4.a(1660) }) }, [1660]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$4.a(153), p: [__RΦ$b$4.a(1655), __RΦ$b$4.a(1656)] }) }, [15]: { LΦ: t => Number } } };
	/**
	 * Конвертация разнообразных значений.
	 */
	class Convert$3 {
	    static toArray(object) {
	        const result = [];
	        if (object instanceof Map) {
	            for (const [key, value] of object) {
	                result.push({ key, value });
	            }
	        }
	        else {
	            for (const key in object) {
	                if (!object.hasOwnProperty(key))
	                    continue;
	                result.push({ key, value: Reflect.get(object, key) });
	            }
	        }
	        return result;
	    }
	    /**
	     * Конвертировать миллисекунды в секунды.
	     * @param millisecond
	     */
	    static toSecond(millisecond) {
	        return millisecond / 1000;
	    }
	}
	(t => __RΦ$b$4.t[1834] = t)(Convert$3);
	__RΦ$b$4.m("rt:SP", [])(Convert$3);
	__RΦ$b$4.m("rt:P", [])(Convert$3);
	__RΦ$b$4.m("rt:Sm", ["toArray", "toArray", "toArray", "toSecond"])(Convert$3);
	__RΦ$b$4.m("rt:m", [])(Convert$3);
	__RΦ$b$4.m("rt:f", "Ce")(Convert$3);
	__RΦ$b$4.m("rt:f", "M$S")(Convert$3["toArray"]);
	((t, p) => __RΦ$b$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$3, "toArray");
	__RΦ$b$4.m("rt:p", [{ n: "object", t: () => __RΦ$b$4.a(1838), v: null }])(Convert$3, "toArray");
	__RΦ$b$4.m("rt:f", "M$S")(Convert$3, "toArray");
	__RΦ$b$4.m("rt:t", () => __RΦ$b$4.a(1842))(Convert$3, "toArray");
	__RΦ$b$4.m("rt:f", "M$S")(Convert$3["toArray"]);
	((t, p) => __RΦ$b$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$3, "toArray");
	__RΦ$b$4.m("rt:p", [{ n: "object", t: () => __RΦ$b$4.a(1849), v: null }])(Convert$3, "toArray");
	__RΦ$b$4.m("rt:f", "M$S")(Convert$3, "toArray");
	__RΦ$b$4.m("rt:t", () => __RΦ$b$4.a(1854))(Convert$3, "toArray");
	__RΦ$b$4.m("rt:f", "M$S")(Convert$3["toArray"]);
	((t, p) => __RΦ$b$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$3, "toArray");
	__RΦ$b$4.m("rt:p", [{ n: "object", t: () => __RΦ$b$4.a(1673), v: null }])(Convert$3, "toArray");
	__RΦ$b$4.m("rt:f", "M$S")(Convert$3, "toArray");
	__RΦ$b$4.m("rt:t", () => __RΦ$b$4.a(1657))(Convert$3, "toArray");
	__RΦ$b$4.m("rt:f", "M$S.")(Convert$3["toSecond"]);
	((t, p) => __RΦ$b$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$3, "toSecond");
	__RΦ$b$4.m("rt:p", [{ n: "millisecond", t: () => __RΦ$b$4.a(15), v: null }])(Convert$3, "toSecond");
	__RΦ$b$4.m("rt:f", "M$S.")(Convert$3, "toSecond");
	__RΦ$b$4.m("rt:t", () => __RΦ$b$4.a(15))(Convert$3, "toSecond");

	const __RΦ$a$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$a$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$a$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$a$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1883]: { LΦ: t => 60 }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [15]: { LΦ: t => Number }, [1879]: { LΦ: t => "update" }, [1885]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$4.a(4) }] }) }, [1860]: { RΦ: t => ({ TΦ: "t" }) }, [1881]: { LΦ: t => "render" }, [1886]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$4.a(4) }] }) }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$a$4.a(14), __RΦ$a$4.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1862]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$4.a(4) }] }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * http://gs-studio.com/news-about-it/30703----javascript
	 * https://eatdog.com.ua/assets/gamedev-slides/
	 * https://www.youtube.com/watch?v=-gsjAz9jR3Y
	 */
	class GameLoop$3 {
	    framePerSecond;
	    eventEmitter = new EventEmitter__default$3["default"];
	    time = 0;
	    timeInterval = 0;
	    renderTime = 0;
	    renderTimeInterval = 0;
	    /**
	     * Текущий FPS отрисовки игровой сцены.
	     */
	    get renderFramePerSecond() {
	        return 1 / (this.renderTimeInterval / 1000);
	    }
	    /**
	     * Временной шаг, с которым вызывается функция update для вычисления игровой логики.
	     * Измеряется в миллисекундах.
	     */
	    get step() {
	        return (1 / this.framePerSecond) / 1000;
	    }
	    constructor(
	    /**
	     * Частота обновления игровой логики (генерации события update).
	     * @private
	     */
	    framePerSecond = 60 // TODO Переименовать в updatePerSecond?
	    ) {
	        this.framePerSecond = framePerSecond;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	    start() {
	        this.time = performance.now();
	        this.timeInterval = 0;
	        requestAnimationFrame(this.frame.bind(this));
	    }
	    stop() {
	    }
	    pause() {
	    }
	    frame() {
	        // Обработка логики игры.
	        {
	            const currentTime = performance.now();
	            // Исправление проблемы неактивных вкладок.
	            // Разрешить максимальную задержку между вызовами не более, чем 1 секунда.
	            this.timeInterval = this.timeInterval + Math.min(1000, currentTime - this.time);
	            while (this.timeInterval > this.step) {
	                this.timeInterval = this.timeInterval - this.step;
	                this.eventEmitter.emit('update', this.step);
	            }
	            this.time = currentTime;
	        }
	        // Обработка отрисовки сцены игры.
	        {
	            const renderCurrentTime = performance.now();
	            this.renderTimeInterval = renderCurrentTime - this.renderTime;
	            this.renderTime = renderCurrentTime;
	            this.eventEmitter.emit('render', this.timeInterval);
	        }
	        requestAnimationFrame(this.frame.bind(this));
	    }
	}
	(t => __RΦ$a$4.t[1859] = t)(GameLoop$3);
	__RΦ$a$4.m("rt:SP", [])(GameLoop$3);
	__RΦ$a$4.m("rt:P", ["eventEmitter", "time", "timeInterval", "renderTime", "renderTimeInterval", "renderFramePerSecond", "step", "framePerSecond"])(GameLoop$3);
	__RΦ$a$4.m("rt:Sm", [])(GameLoop$3);
	__RΦ$a$4.m("rt:m", ["on", "on", "on", "start", "stop", "pause", "frame"])(GameLoop$3);
	__RΦ$a$4.m("rt:p", [{ n: "framePerSecond", t: () => __RΦ$a$4.a(1883), v: function () { return 60 // TODO Переименовать в updatePerSecond?
	        ; }, f: "#R" }])(GameLoop$3);
	__RΦ$a$4.m("rt:i", [() => undefined, () => undefined])(GameLoop$3);
	__RΦ$a$4.m("rt:f", "Ce")(GameLoop$3);
	__RΦ$a$4.m("rt:t", () => __RΦ$a$4.a(4))(GameLoop$3.prototype, "eventEmitter");
	__RΦ$a$4.m("rt:f", "P#R")(GameLoop$3.prototype, "eventEmitter");
	__RΦ$a$4.m("rt:t", () => __RΦ$a$4.a(15))(GameLoop$3.prototype, "time");
	__RΦ$a$4.m("rt:f", "P#")(GameLoop$3.prototype, "time");
	__RΦ$a$4.m("rt:t", () => __RΦ$a$4.a(15))(GameLoop$3.prototype, "timeInterval");
	__RΦ$a$4.m("rt:f", "P#")(GameLoop$3.prototype, "timeInterval");
	__RΦ$a$4.m("rt:t", () => __RΦ$a$4.a(15))(GameLoop$3.prototype, "renderTime");
	__RΦ$a$4.m("rt:f", "P#")(GameLoop$3.prototype, "renderTime");
	__RΦ$a$4.m("rt:t", () => __RΦ$a$4.a(15))(GameLoop$3.prototype, "renderTimeInterval");
	__RΦ$a$4.m("rt:f", "P#")(GameLoop$3.prototype, "renderTimeInterval");
	__RΦ$a$4.m("rt:t", () => __RΦ$a$4.a(15))(GameLoop$3.prototype, "renderFramePerSecond");
	__RΦ$a$4.m("rt:f", "P$")(GameLoop$3.prototype, "renderFramePerSecond");
	__RΦ$a$4.m("rt:t", () => __RΦ$a$4.a(15))(GameLoop$3.prototype, "step");
	__RΦ$a$4.m("rt:f", "P$")(GameLoop$3.prototype, "step");
	__RΦ$a$4.m("rt:f", "M")(GameLoop$3.prototype["on"]);
	((t, p) => __RΦ$a$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$3.prototype, "on");
	__RΦ$a$4.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$4.a(1879), v: null }, { n: "update", t: () => __RΦ$a$4.a(1885), v: null }])(GameLoop$3.prototype, "on");
	__RΦ$a$4.m("rt:f", "M")(GameLoop$3.prototype, "on");
	__RΦ$a$4.m("rt:t", () => __RΦ$a$4.a(1860))(GameLoop$3.prototype, "on");
	__RΦ$a$4.m("rt:f", "M")(GameLoop$3.prototype["on"]);
	((t, p) => __RΦ$a$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$3.prototype, "on");
	__RΦ$a$4.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$4.a(1881), v: null }, { n: "render", t: () => __RΦ$a$4.a(1886), v: null }])(GameLoop$3.prototype, "on");
	__RΦ$a$4.m("rt:f", "M")(GameLoop$3.prototype, "on");
	__RΦ$a$4.m("rt:t", () => __RΦ$a$4.a(1860))(GameLoop$3.prototype, "on");
	__RΦ$a$4.m("rt:f", "M")(GameLoop$3.prototype["on"]);
	((t, p) => __RΦ$a$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$3.prototype, "on");
	__RΦ$a$4.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$4.a(143), v: null }, { n: "listener", t: () => __RΦ$a$4.a(1862), v: null }])(GameLoop$3.prototype, "on");
	__RΦ$a$4.m("rt:f", "M")(GameLoop$3.prototype, "on");
	__RΦ$a$4.m("rt:t", () => __RΦ$a$4.a(1860))(GameLoop$3.prototype, "on");
	__RΦ$a$4.m("rt:f", "M$")(GameLoop$3.prototype["start"]);
	((t, p) => __RΦ$a$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$3.prototype, "start");
	__RΦ$a$4.m("rt:p", [])(GameLoop$3.prototype, "start");
	__RΦ$a$4.m("rt:f", "M$")(GameLoop$3.prototype, "start");
	__RΦ$a$4.m("rt:t", () => __RΦ$a$4.a(23))(GameLoop$3.prototype, "start");
	__RΦ$a$4.m("rt:f", "M$")(GameLoop$3.prototype["stop"]);
	((t, p) => __RΦ$a$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$3.prototype, "stop");
	__RΦ$a$4.m("rt:p", [])(GameLoop$3.prototype, "stop");
	__RΦ$a$4.m("rt:f", "M$")(GameLoop$3.prototype, "stop");
	__RΦ$a$4.m("rt:t", () => __RΦ$a$4.a(23))(GameLoop$3.prototype, "stop");
	__RΦ$a$4.m("rt:f", "M$")(GameLoop$3.prototype["pause"]);
	((t, p) => __RΦ$a$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$3.prototype, "pause");
	__RΦ$a$4.m("rt:p", [])(GameLoop$3.prototype, "pause");
	__RΦ$a$4.m("rt:f", "M$")(GameLoop$3.prototype, "pause");
	__RΦ$a$4.m("rt:t", () => __RΦ$a$4.a(23))(GameLoop$3.prototype, "pause");
	__RΦ$a$4.m("rt:f", "M#.")(GameLoop$3.prototype["frame"]);
	((t, p) => __RΦ$a$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$3.prototype, "frame");
	__RΦ$a$4.m("rt:p", [])(GameLoop$3.prototype, "frame");
	__RΦ$a$4.m("rt:f", "M#.")(GameLoop$3.prototype, "frame");
	__RΦ$a$4.m("rt:t", () => __RΦ$a$4.a(23))(GameLoop$3.prototype, "frame");

	const __RΦ$9$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$9$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$9$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$9$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1890]: { RΦ: t => ({ TΦ: "g", t: __RΦ$9$4.a(156), p: [__RΦ$9$4.a(14), __RΦ$9$4.a(21)] }) }, [156]: { LΦ: t => Map }, [14]: { LΦ: t => String }, [21]: { LΦ: t => Boolean }, [1893]: { LΦ: t => KeyboardEvent }, [1900]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$4.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1903]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$4.a(4) }] }) }, [1907]: { LΦ: t => Function }, [1906]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$4.a(4) }] }) }, [1908]: { LΦ: t => Function } } };
	/**
	 * Вместо KeyUpDownProcessor используйте Shortcut.
	 * @deprecated
	 * @link http://khusamov.github.io/tutorial/csharp/key-down-up-process
	 */
	class KeyUpDownProcessor$3 {
	    /**
	     * Данный словарь хранит информацию о том, была ли нажата клавиша.
	     * В качестве ключа выступает номер клавиши,
	     * а значение это флаг (была или не была нажата клавиша).
	     * @private
	     * @link https://learn.javascript.ru/keyboard-events
	     */
	    static #theKeyWasDown = new Map;
	    static onKeyDown(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.#theKeyWasDown.has(keyCode)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.#theKeyWasDown.set(keyCode, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.#theKeyWasDown.get(keyCode)) {
	            // Помечаем что она нажата.
	            this.#theKeyWasDown.set(keyCode, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            action();
	        }
	    }
	    static onKeyUp(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Помечаем что она уже не нажата.
	        this.#theKeyWasDown.set(keyCode, false);
	        // Выполняем действие при отжатии клавиши.
	        action();
	    }
	}
	(t => __RΦ$9$4.t[1888] = t)(KeyUpDownProcessor$3);
	__RΦ$9$4.m("rt:SP", ["#theKeyWasDown"])(KeyUpDownProcessor$3);
	__RΦ$9$4.m("rt:P", [])(KeyUpDownProcessor$3);
	__RΦ$9$4.m("rt:Sm", ["onKeyDown", "onKeyUp"])(KeyUpDownProcessor$3);
	__RΦ$9$4.m("rt:m", [])(KeyUpDownProcessor$3);
	__RΦ$9$4.m("rt:f", "Ce")(KeyUpDownProcessor$3);
	__RΦ$9$4.m("rt:t", () => __RΦ$9$4.a(1890))(KeyUpDownProcessor$3, "#theKeyWasDown");
	__RΦ$9$4.m("rt:f", "P")(KeyUpDownProcessor$3, "#theKeyWasDown");
	__RΦ$9$4.m("rt:f", "M$S.")(KeyUpDownProcessor$3["onKeyDown"]);
	((t, p) => __RΦ$9$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor$3, "onKeyDown");
	__RΦ$9$4.m("rt:p", [{ n: "event", t: () => __RΦ$9$4.a(1893), v: null }, { n: "action", t: () => __RΦ$9$4.a(1900), v: null }])(KeyUpDownProcessor$3, "onKeyDown");
	__RΦ$9$4.m("rt:f", "M$S.")(KeyUpDownProcessor$3, "onKeyDown");
	__RΦ$9$4.m("rt:t", () => __RΦ$9$4.a(23))(KeyUpDownProcessor$3, "onKeyDown");
	__RΦ$9$4.m("rt:f", "M$S.")(KeyUpDownProcessor$3["onKeyUp"]);
	((t, p) => __RΦ$9$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor$3, "onKeyUp");
	__RΦ$9$4.m("rt:p", [{ n: "event", t: () => __RΦ$9$4.a(1893), v: null }, { n: "action", t: () => __RΦ$9$4.a(1900), v: null }])(KeyUpDownProcessor$3, "onKeyUp");
	__RΦ$9$4.m("rt:f", "M$S.")(KeyUpDownProcessor$3, "onKeyUp");
	__RΦ$9$4.m("rt:t", () => __RΦ$9$4.a(23))(KeyUpDownProcessor$3, "onKeyUp");
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyDown$3(listener) {
	    return __RΦ$9$4.f((event) => {
	        KeyUpDownProcessor$3.onKeyDown(event, __RΦ$9$4.f(() => {
	            listener(event);
	        }, [__RΦ$9$4.m("rt:p", []), __RΦ$9$4.m("rt:f", "F>"), __RΦ$9$4.m("rt:t", () => __RΦ$9$4.a(23))], ""));
	    }, [__RΦ$9$4.m("rt:p", [{ n: "event", t: () => __RΦ$9$4.a(1893), v: null }]), __RΦ$9$4.m("rt:f", "F>"), __RΦ$9$4.m("rt:t", () => __RΦ$9$4.a(23))], "");
	}
	__RΦ$9$4.m("rt:p", [{ n: "listener", t: () => __RΦ$9$4.a(1903), v: null }])(onKeyDown$3);
	__RΦ$9$4.m("rt:f", "F")(onKeyDown$3);
	__RΦ$9$4.m("rt:t", () => __RΦ$9$4.a(1907))(onKeyDown$3);
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyUp$3(listener) {
	    return __RΦ$9$4.f((event) => {
	        KeyUpDownProcessor$3.onKeyUp(event, __RΦ$9$4.f(() => {
	            listener(event);
	        }, [__RΦ$9$4.m("rt:p", []), __RΦ$9$4.m("rt:f", "F>"), __RΦ$9$4.m("rt:t", () => __RΦ$9$4.a(23))], ""));
	    }, [__RΦ$9$4.m("rt:p", [{ n: "event", t: () => __RΦ$9$4.a(1893), v: null }]), __RΦ$9$4.m("rt:f", "F>"), __RΦ$9$4.m("rt:t", () => __RΦ$9$4.a(23))], "");
	}
	__RΦ$9$4.m("rt:p", [{ n: "listener", t: () => __RΦ$9$4.a(1906), v: null }])(onKeyUp$3);
	__RΦ$9$4.m("rt:f", "F")(onKeyUp$3);
	__RΦ$9$4.m("rt:t", () => __RΦ$9$4.a(1908))(onKeyUp$3);

	const __RΦ$8$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$8$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$8$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$8$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$3$3 = { name: "IDisposable", prototype: {}, identity: Symbol("IDisposable (interface)") };
	(t => __RΦ$8$4.t[147] = t)(IΦdefault$3$3);
	__RΦ$8$4.m("rt:P", [])(IΦdefault$3$3);
	__RΦ$8$4.m("rt:m", ["dispose"])(IΦdefault$3$3);
	__RΦ$8$4.m("rt:f", "Ie")(IΦdefault$3$3);
	__RΦ$8$4.m("rt:p", [])(IΦdefault$3$3.prototype, "dispose");
	__RΦ$8$4.m("rt:f", "M")(IΦdefault$3$3.prototype, "dispose");
	__RΦ$8$4.m("rt:t", () => __RΦ$8$4.a(23))(IΦdefault$3$3.prototype, "dispose");
	__RΦ$8$4.m("rt:p", [])(IΦdefault$3$3.prototype, "dispose");
	__RΦ$8$4.m("rt:f", "M")(IΦdefault$3$3.prototype, "dispose");
	__RΦ$8$4.m("rt:t", () => __RΦ$8$4.a(23))(IΦdefault$3$3.prototype, "dispose");

	const __RΦ$7$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$7$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$7$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$7$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1909]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$7$4.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) } } };
	var IΦdefault$2$3 = { name: "IKeyboardListeners", prototype: {}, identity: Symbol("IKeyboardListeners (interface)") };
	(t => __RΦ$7$4.t[1910] = t)(IΦdefault$2$3);
	__RΦ$7$4.m("rt:P", ["down", "up"])(IΦdefault$2$3);
	__RΦ$7$4.m("rt:m", [])(IΦdefault$2$3);
	__RΦ$7$4.m("rt:f", "Ie")(IΦdefault$2$3);
	__RΦ$7$4.m("rt:t", () => __RΦ$7$4.a(1909))(IΦdefault$2$3.prototype, "down");
	__RΦ$7$4.m("rt:f", "P")(IΦdefault$2$3.prototype, "down");
	__RΦ$7$4.m("rt:t", () => __RΦ$7$4.a(1909))(IΦdefault$2$3.prototype, "up");
	__RΦ$7$4.m("rt:f", "P")(IΦdefault$2$3.prototype, "up");
	__RΦ$7$4.m("rt:t", () => __RΦ$7$4.a(1909))(IΦdefault$2$3.prototype, "down");
	__RΦ$7$4.m("rt:f", "P")(IΦdefault$2$3.prototype, "down");
	__RΦ$7$4.m("rt:t", () => __RΦ$7$4.a(1909))(IΦdefault$2$3.prototype, "up");
	__RΦ$7$4.m("rt:f", "P")(IΦdefault$2$3.prototype, "up");

	const __RΦ$6$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$6$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$6$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$6$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [743]: { LΦ: t => Object }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1911]: { TΦ: "5", name: "default" }, [2164]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$4.a(156), p: [__RΦ$6$4.a(14), __RΦ$6$4.a(1910)] }) }, [156]: { LΦ: t => Map }, [1910]: { LΦ: t => IΦdefault$2$3 }, [1909]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$6$4.a(4) }] }) }, [1890]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$4.a(156), p: [__RΦ$6$4.a(14), __RΦ$6$4.a(21)] }) }, [21]: { LΦ: t => Boolean }, [147]: { LΦ: t => IΦdefault$3$3 }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1893]: { LΦ: t => KeyboardEvent } } };
	const codeOf$3 = __RΦ$6$4.f((key) => 'Key' + key.toUpperCase(), [__RΦ$6$4.m("rt:p", [{ n: "key", t: () => __RΦ$6$4.a(14), v: null }]), __RΦ$6$4.m("rt:f", "F>"), __RΦ$6$4.m("rt:t", () => __RΦ$6$4.a(14))], "codeOf");
	class ShortcutDispatcher$3 {
	    static instanceHolder = new Lazy$3(() => new ShortcutDispatcher$3);
	    static get instance() {
	        return this.instanceHolder.value;
	    }
	    host;
	    listeners = new Map;
	    keyDownListenerBinded;
	    keyUpListenerBinded;
	    theKeyWasDown = new Map;
	    constructor(host = document) {
	        this.host = host;
	        this.keyDownListenerBinded = this.keyDownListener.bind(this);
	        this.keyUpListenerBinded = this.keyUpListener.bind(this);
	        this.host.addEventListener('keydown', this.keyDownListenerBinded);
	        this.host.addEventListener('keyup', this.keyUpListenerBinded);
	    }
	    register(key, listeners) {
	        this.listeners.set(key, listeners);
	        return {
	            dispose: __RΦ$6$4.f(() => {
	                this.listeners.delete(key);
	                this.theKeyWasDown.delete(codeOf$3(key));
	            }, [__RΦ$6$4.m("rt:p", []), __RΦ$6$4.m("rt:f", "F>"), __RΦ$6$4.m("rt:t", () => __RΦ$6$4.a(23))], "dispose")
	        };
	    }
	    keyDownListener(event) {
	        const code = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.theKeyWasDown.has(code)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.theKeyWasDown.set(code, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.theKeyWasDown.get(code)) {
	            // Помечаем что она нажата.
	            this.theKeyWasDown.set(code, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            for (const [key, listeners] of this.listeners.entries()) {
	                if (code === codeOf$3(key)) {
	                    listeners.down(event);
	                }
	            }
	        }
	    }
	    keyUpListener(event) {
	        // Из события извлекаем номер нажатой клавиши.
	        const code = event.code;
	        // Помечаем что она уже не нажата.
	        this.theKeyWasDown.set(code, false);
	        // Выполняем действие при отжатии клавиши.
	        for (const [key, listeners] of this.listeners.entries()) {
	            if (code === codeOf$3(key)) {
	                listeners.up(event);
	            }
	        }
	    }
	    dispose() {
	        this.host.removeEventListener('keydown', this.keyDownListenerBinded);
	        this.host.removeEventListener('keyup', this.keyUpListenerBinded);
	    }
	}
	(t => __RΦ$6$4.t[1911] = t)(ShortcutDispatcher$3);
	__RΦ$6$4.m("rt:SP", ["instanceHolder", "instance"])(ShortcutDispatcher$3);
	__RΦ$6$4.m("rt:P", ["host", "listeners", "keyDownListenerBinded", "keyUpListenerBinded", "theKeyWasDown"])(ShortcutDispatcher$3);
	__RΦ$6$4.m("rt:Sm", [])(ShortcutDispatcher$3);
	__RΦ$6$4.m("rt:m", ["register", "keyDownListener", "keyUpListener", "dispose"])(ShortcutDispatcher$3);
	__RΦ$6$4.m("rt:p", [{ n: "host", t: () => __RΦ$6$4.a(743), v: function () { return document; } }])(ShortcutDispatcher$3);
	__RΦ$6$4.m("rt:i", [() => undefined])(ShortcutDispatcher$3);
	__RΦ$6$4.m("rt:f", "Ce")(ShortcutDispatcher$3);
	__RΦ$6$4.m("rt:t", () => __RΦ$6$4.a(4))(ShortcutDispatcher$3, "instanceHolder");
	__RΦ$6$4.m("rt:f", "P#R")(ShortcutDispatcher$3, "instanceHolder");
	__RΦ$6$4.m("rt:t", () => __RΦ$6$4.a(1911))(ShortcutDispatcher$3, "instance");
	__RΦ$6$4.m("rt:f", "P$")(ShortcutDispatcher$3, "instance");
	__RΦ$6$4.m("rt:t", () => __RΦ$6$4.a(743))(ShortcutDispatcher$3.prototype, "host");
	__RΦ$6$4.m("rt:f", "P#R")(ShortcutDispatcher$3.prototype, "host");
	__RΦ$6$4.m("rt:t", () => __RΦ$6$4.a(2164))(ShortcutDispatcher$3.prototype, "listeners");
	__RΦ$6$4.m("rt:f", "P#R")(ShortcutDispatcher$3.prototype, "listeners");
	__RΦ$6$4.m("rt:t", () => __RΦ$6$4.a(1909))(ShortcutDispatcher$3.prototype, "keyDownListenerBinded");
	__RΦ$6$4.m("rt:f", "P#R")(ShortcutDispatcher$3.prototype, "keyDownListenerBinded");
	__RΦ$6$4.m("rt:t", () => __RΦ$6$4.a(1909))(ShortcutDispatcher$3.prototype, "keyUpListenerBinded");
	__RΦ$6$4.m("rt:f", "P#R")(ShortcutDispatcher$3.prototype, "keyUpListenerBinded");
	__RΦ$6$4.m("rt:t", () => __RΦ$6$4.a(1890))(ShortcutDispatcher$3.prototype, "theKeyWasDown");
	__RΦ$6$4.m("rt:f", "P#R")(ShortcutDispatcher$3.prototype, "theKeyWasDown");
	__RΦ$6$4.m("rt:f", "M$")(ShortcutDispatcher$3.prototype["register"]);
	((t, p) => __RΦ$6$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$3.prototype, "register");
	__RΦ$6$4.m("rt:p", [{ n: "key", t: () => __RΦ$6$4.a(14), v: null }, { n: "listeners", t: () => __RΦ$6$4.a(1910), v: null }])(ShortcutDispatcher$3.prototype, "register");
	__RΦ$6$4.m("rt:f", "M$")(ShortcutDispatcher$3.prototype, "register");
	__RΦ$6$4.m("rt:t", () => __RΦ$6$4.a(147))(ShortcutDispatcher$3.prototype, "register");
	__RΦ$6$4.m("rt:f", "M#.")(ShortcutDispatcher$3.prototype["keyDownListener"]);
	((t, p) => __RΦ$6$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$3.prototype, "keyDownListener");
	__RΦ$6$4.m("rt:p", [{ n: "event", t: () => __RΦ$6$4.a(1893), v: null }])(ShortcutDispatcher$3.prototype, "keyDownListener");
	__RΦ$6$4.m("rt:f", "M#.")(ShortcutDispatcher$3.prototype, "keyDownListener");
	__RΦ$6$4.m("rt:t", () => __RΦ$6$4.a(23))(ShortcutDispatcher$3.prototype, "keyDownListener");
	__RΦ$6$4.m("rt:f", "M#.")(ShortcutDispatcher$3.prototype["keyUpListener"]);
	((t, p) => __RΦ$6$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$3.prototype, "keyUpListener");
	__RΦ$6$4.m("rt:p", [{ n: "event", t: () => __RΦ$6$4.a(1893), v: null }])(ShortcutDispatcher$3.prototype, "keyUpListener");
	__RΦ$6$4.m("rt:f", "M#.")(ShortcutDispatcher$3.prototype, "keyUpListener");
	__RΦ$6$4.m("rt:t", () => __RΦ$6$4.a(23))(ShortcutDispatcher$3.prototype, "keyUpListener");
	__RΦ$6$4.m("rt:f", "M$.")(ShortcutDispatcher$3.prototype["dispose"]);
	((t, p) => __RΦ$6$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$3.prototype, "dispose");
	__RΦ$6$4.m("rt:p", [])(ShortcutDispatcher$3.prototype, "dispose");
	__RΦ$6$4.m("rt:f", "M$.")(ShortcutDispatcher$3.prototype, "dispose");
	__RΦ$6$4.m("rt:t", () => __RΦ$6$4.a(23))(ShortcutDispatcher$3.prototype, "dispose");

	const __RΦ$5$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$5$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$5$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$5$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [1910]: { LΦ: t => IΦdefault$2$3 }, [147]: { LΦ: t => IΦdefault$3$3 } } };
	class Shortcut$3 {
	    static register(key, listeners) {
	        return ShortcutDispatcher$3.instance.register(key, listeners);
	    }
	}
	(t => __RΦ$5$4.t[2193] = t)(Shortcut$3);
	__RΦ$5$4.m("rt:SP", [])(Shortcut$3);
	__RΦ$5$4.m("rt:P", [])(Shortcut$3);
	__RΦ$5$4.m("rt:Sm", ["register"])(Shortcut$3);
	__RΦ$5$4.m("rt:m", [])(Shortcut$3);
	__RΦ$5$4.m("rt:f", "Ce")(Shortcut$3);
	__RΦ$5$4.m("rt:f", "M$S")(Shortcut$3["register"]);
	((t, p) => __RΦ$5$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Shortcut$3, "register");
	__RΦ$5$4.m("rt:p", [{ n: "key", t: () => __RΦ$5$4.a(14), v: null }, { n: "listeners", t: () => __RΦ$5$4.a(1910), v: null }])(Shortcut$3, "register");
	__RΦ$5$4.m("rt:f", "M$S")(Shortcut$3, "register");
	__RΦ$5$4.m("rt:t", () => __RΦ$5$4.a(147))(Shortcut$3, "register");

	const __RΦ$4$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$4$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$4$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$4$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [166]: { RΦ: t => ({ TΦ: "[", e: __RΦ$4$4.a(165) }) }, [165]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [168]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$4$4.a(10), __RΦ$4$4.a(167)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [167]: { LΦ: t => Object }, [177]: { RΦ: t => ({ TΦ: "g", t: __RΦ$4$4.a(77), p: [__RΦ$4$4.a(167)] }) }, [77]: { LΦ: t => Object } } };
	var IΦdefault$1$3 = { name: "IQueue", prototype: {}, identity: Symbol("IQueue (interface)") };
	(t => __RΦ$4$4.t[178] = t)(IΦdefault$1$3);
	__RΦ$4$4.m("rt:P", ["items"])(IΦdefault$1$3);
	__RΦ$4$4.m("rt:m", ["enqueue", "dequeue"])(IΦdefault$1$3);
	__RΦ$4$4.m("rt:f", "Ie")(IΦdefault$1$3);
	__RΦ$4$4.m("rt:p", [{ n: "items", t: () => __RΦ$4$4.a(166), v: null }])(IΦdefault$1$3.prototype, "enqueue");
	__RΦ$4$4.m("rt:f", "M")(IΦdefault$1$3.prototype, "enqueue");
	__RΦ$4$4.m("rt:t", () => __RΦ$4$4.a(23))(IΦdefault$1$3.prototype, "enqueue");
	__RΦ$4$4.m("rt:p", [])(IΦdefault$1$3.prototype, "dequeue");
	__RΦ$4$4.m("rt:f", "M")(IΦdefault$1$3.prototype, "dequeue");
	__RΦ$4$4.m("rt:t", () => __RΦ$4$4.a(168))(IΦdefault$1$3.prototype, "dequeue");
	__RΦ$4$4.m("rt:t", () => __RΦ$4$4.a(177))(IΦdefault$1$3.prototype, "items");
	__RΦ$4$4.m("rt:f", "PR")(IΦdefault$1$3.prototype, "items");
	__RΦ$4$4.m("rt:p", [{ n: "items", t: () => __RΦ$4$4.a(166), v: null }])(IΦdefault$1$3.prototype, "enqueue");
	__RΦ$4$4.m("rt:f", "M")(IΦdefault$1$3.prototype, "enqueue");
	__RΦ$4$4.m("rt:t", () => __RΦ$4$4.a(23))(IΦdefault$1$3.prototype, "enqueue");
	__RΦ$4$4.m("rt:p", [])(IΦdefault$1$3.prototype, "dequeue");
	__RΦ$4$4.m("rt:f", "M")(IΦdefault$1$3.prototype, "dequeue");
	__RΦ$4$4.m("rt:t", () => __RΦ$4$4.a(168))(IΦdefault$1$3.prototype, "dequeue");
	__RΦ$4$4.m("rt:t", () => __RΦ$4$4.a(177))(IΦdefault$1$3.prototype, "items");
	__RΦ$4$4.m("rt:f", "PR")(IΦdefault$1$3.prototype, "items");

	const __RΦ$3$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$3$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$3$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$3$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [185]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$4.a(182) }) }, [182]: { LΦ: t => Object }, [190]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$4.a(180) }) }, [180]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [227]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$3$4.a(10), __RΦ$3$4.a(182)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [228]: { RΦ: t => ({ TΦ: "g", t: __RΦ$3$4.a(77), p: [__RΦ$3$4.a(182)] }) }, [77]: { LΦ: t => Object } } };
	/**
	 * О́чередь — абстрактный тип данных с дисциплиной доступа к элементам «первый пришёл — первый вышел»
	 * (FIFO, англ. first in, first out).
	 *
	 * Добавление элемента (принято обозначать словом enqueue — поставить в очередь) возможно лишь
	 * в конец очереди, выборка — только из начала очереди (что принято называть словом dequeue — убрать из очереди),
	 * при этом выбранный элемент из очереди удаляется.
	 *
	 * @link https://bit.ly/3tPM13G
	 */
	class Queue$3 {
	    storage = [];
	    enqueue(...items) {
	        this.storage.push(...items);
	    }
	    dequeue() {
	        return this.storage.shift();
	    }
	    get items() {
	        return this.storage;
	    }
	}
	(t => __RΦ$3$4.t[181] = t)(Queue$3);
	__RΦ$3$4.m("rt:SP", [])(Queue$3);
	__RΦ$3$4.m("rt:P", ["storage", "items"])(Queue$3);
	__RΦ$3$4.m("rt:Sm", [])(Queue$3);
	__RΦ$3$4.m("rt:m", ["enqueue", "dequeue"])(Queue$3);
	__RΦ$3$4.m("rt:i", [() => undefined])(Queue$3);
	__RΦ$3$4.m("rt:f", "Ce")(Queue$3);
	__RΦ$3$4.m("rt:t", () => __RΦ$3$4.a(185))(Queue$3.prototype, "storage");
	__RΦ$3$4.m("rt:f", "P#")(Queue$3.prototype, "storage");
	__RΦ$3$4.m("rt:f", "M$")(Queue$3.prototype["enqueue"]);
	((t, p) => __RΦ$3$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue$3.prototype, "enqueue");
	__RΦ$3$4.m("rt:p", [{ n: "items", t: () => __RΦ$3$4.a(190), v: null }])(Queue$3.prototype, "enqueue");
	__RΦ$3$4.m("rt:f", "M$")(Queue$3.prototype, "enqueue");
	__RΦ$3$4.m("rt:t", () => __RΦ$3$4.a(23))(Queue$3.prototype, "enqueue");
	__RΦ$3$4.m("rt:f", "M$")(Queue$3.prototype["dequeue"]);
	((t, p) => __RΦ$3$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue$3.prototype, "dequeue");
	__RΦ$3$4.m("rt:p", [])(Queue$3.prototype, "dequeue");
	__RΦ$3$4.m("rt:f", "M$")(Queue$3.prototype, "dequeue");
	__RΦ$3$4.m("rt:t", () => __RΦ$3$4.a(227))(Queue$3.prototype, "dequeue");
	__RΦ$3$4.m("rt:t", () => __RΦ$3$4.a(228))(Queue$3.prototype, "items");
	__RΦ$3$4.m("rt:f", "P$")(Queue$3.prototype, "items");

	const __RΦ$2$1$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$2$1$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$2$1$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$2$1$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [407]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$1$2.a(404) }) }, [404]: { LΦ: t => Object }, [273]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$2.a(178), p: [__RΦ$2$1$2.a(230)] }) }, [178]: { LΦ: t => IΦdefault$1$3 }, [230]: { LΦ: t => Object }, [406]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$2.a(403), p: [__RΦ$2$1$2.a(230)] }) }, [403]: { TΦ: "5", name: "ILog" }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [622]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$2.a(178), p: [__RΦ$2$1$2.a(621)] }) }, [621]: { LΦ: t => Object }, [628]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$2$1$2.a(622) }, { t: __RΦ$2$1$2.a(627) }] }) }, [627]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$2.a(229), p: [__RΦ$2$1$2.a(621)] }) }, [229]: { TΦ: "5", name: "default" }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$1$2.a(14), __RΦ$2$1$2.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [397]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [629]: { LΦ: t => Function }, [408]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$1$2.a(230) }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [402]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [630]: { LΦ: t => Function }, [428]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$1$2.a(10), __RΦ$2$1$2.a(230)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	var IΦILog$3 = { name: "ILog", prototype: {}, identity: Symbol("ILog (interface)") };
	(t => __RΦ$2$1$2.t[403] = t)(IΦILog$3);
	__RΦ$2$1$2.m("rt:P", ["enqueue", "dequeue"])(IΦILog$3);
	__RΦ$2$1$2.m("rt:m", [])(IΦILog$3);
	__RΦ$2$1$2.m("rt:f", "I")(IΦILog$3);
	__RΦ$2$1$2.m("rt:t", () => __RΦ$2$1$2.a(407))(IΦILog$3.prototype, "enqueue");
	__RΦ$2$1$2.m("rt:f", "P")(IΦILog$3.prototype, "enqueue");
	__RΦ$2$1$2.m("rt:t", () => __RΦ$2$1$2.a(407))(IΦILog$3.prototype, "dequeue");
	__RΦ$2$1$2.m("rt:f", "P")(IΦILog$3.prototype, "dequeue");
	__RΦ$2$1$2.m("rt:t", () => __RΦ$2$1$2.a(407))(IΦILog$3.prototype, "enqueue");
	__RΦ$2$1$2.m("rt:f", "P")(IΦILog$3.prototype, "enqueue");
	__RΦ$2$1$2.m("rt:t", () => __RΦ$2$1$2.a(407))(IΦILog$3.prototype, "dequeue");
	__RΦ$2$1$2.m("rt:f", "P")(IΦILog$3.prototype, "dequeue");
	class QueueLog$3 {
	    queue;
	    queueProxy;
	    log = {
	        enqueue: [],
	        dequeue: []
	    };
	    get sourceQueue() {
	        return this.queue;
	    }
	    get loggedQueue() {
	        return this.queueProxy;
	    }
	    static create(queue) {
	        const queueLog = new QueueLog$3(queue);
	        return [queueLog.loggedQueue, queueLog];
	    }
	    constructor(queue) {
	        this.queue = queue;
	        this.queueProxy = (new Proxy(queue, {
	            get: this.proxyHandlerGet.bind(this)
	        }));
	    }
	    proxyHandlerGet(target, property, receiver) {
	        const origin = Reflect.get(target, property, receiver);
	        switch (property) {
	            case 'enqueue': return this.createEnqueue(target, origin);
	            case 'dequeue': return this.createDequeue(target, origin);
	            default: return origin;
	        }
	    }
	    createEnqueue(target, origin) {
	        return (__RΦ$2$1$2.f((...items) => {
	            this.log.enqueue.push(...items);
	            origin.call(target, ...items);
	        }, [__RΦ$2$1$2.m("rt:p", [{ n: "items", t: () => __RΦ$2$1$2.a(408), v: null }]), __RΦ$2$1$2.m("rt:f", "F>"), __RΦ$2$1$2.m("rt:t", () => __RΦ$2$1$2.a(23))], ""));
	    }
	    createDequeue(target, origin) {
	        return (__RΦ$2$1$2.f(() => {
	            const item = origin.call(target);
	            if (item) {
	                this.log.dequeue.push(item);
	            }
	            return item;
	        }, [__RΦ$2$1$2.m("rt:p", []), __RΦ$2$1$2.m("rt:f", "F>"), __RΦ$2$1$2.m("rt:t", () => __RΦ$2$1$2.a(428))], ""));
	    }
	}
	(t => __RΦ$2$1$2.t[229] = t)(QueueLog$3);
	__RΦ$2$1$2.m("rt:SP", [])(QueueLog$3);
	__RΦ$2$1$2.m("rt:P", ["queueProxy", "log", "sourceQueue", "loggedQueue", "queue"])(QueueLog$3);
	__RΦ$2$1$2.m("rt:Sm", ["create"])(QueueLog$3);
	__RΦ$2$1$2.m("rt:m", ["proxyHandlerGet", "createEnqueue", "createDequeue"])(QueueLog$3);
	__RΦ$2$1$2.m("rt:p", [{ n: "queue", t: () => __RΦ$2$1$2.a(273), v: null, f: "#" }])(QueueLog$3);
	__RΦ$2$1$2.m("rt:f", "Ce")(QueueLog$3);
	__RΦ$2$1$2.m("rt:t", () => __RΦ$2$1$2.a(273))(QueueLog$3.prototype, "queueProxy");
	__RΦ$2$1$2.m("rt:f", "P#R")(QueueLog$3.prototype, "queueProxy");
	__RΦ$2$1$2.m("rt:t", () => __RΦ$2$1$2.a(406))(QueueLog$3.prototype, "log");
	__RΦ$2$1$2.m("rt:f", "P#")(QueueLog$3.prototype, "log");
	__RΦ$2$1$2.m("rt:t", () => __RΦ$2$1$2.a(4))(QueueLog$3.prototype, "sourceQueue");
	__RΦ$2$1$2.m("rt:f", "P$")(QueueLog$3.prototype, "sourceQueue");
	__RΦ$2$1$2.m("rt:t", () => __RΦ$2$1$2.a(4))(QueueLog$3.prototype, "loggedQueue");
	__RΦ$2$1$2.m("rt:f", "P$")(QueueLog$3.prototype, "loggedQueue");
	__RΦ$2$1$2.m("rt:f", "M$S")(QueueLog$3["create"]);
	((t, p) => __RΦ$2$1$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$3, "create");
	__RΦ$2$1$2.m("rt:p", [{ n: "queue", t: () => __RΦ$2$1$2.a(622), v: null }])(QueueLog$3, "create");
	__RΦ$2$1$2.m("rt:f", "M$S")(QueueLog$3, "create");
	__RΦ$2$1$2.m("rt:t", () => __RΦ$2$1$2.a(628))(QueueLog$3, "create");
	__RΦ$2$1$2.m("rt:f", "M#")(QueueLog$3.prototype["proxyHandlerGet"]);
	((t, p) => __RΦ$2$1$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$3.prototype, "proxyHandlerGet");
	__RΦ$2$1$2.m("rt:p", [{ n: "target", t: () => __RΦ$2$1$2.a(273), v: null }, { n: "property", t: () => __RΦ$2$1$2.a(143), v: null }, { n: "receiver", t: () => __RΦ$2$1$2.a(1), v: null }])(QueueLog$3.prototype, "proxyHandlerGet");
	__RΦ$2$1$2.m("rt:f", "M#")(QueueLog$3.prototype, "proxyHandlerGet");
	__RΦ$2$1$2.m("rt:t", () => __RΦ$2$1$2.a(1))(QueueLog$3.prototype, "proxyHandlerGet");
	__RΦ$2$1$2.m("rt:f", "M#.")(QueueLog$3.prototype["createEnqueue"]);
	((t, p) => __RΦ$2$1$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$3.prototype, "createEnqueue");
	__RΦ$2$1$2.m("rt:p", [{ n: "target", t: () => __RΦ$2$1$2.a(273), v: null }, { n: "origin", t: () => __RΦ$2$1$2.a(397), v: null }])(QueueLog$3.prototype, "createEnqueue");
	__RΦ$2$1$2.m("rt:f", "M#.")(QueueLog$3.prototype, "createEnqueue");
	__RΦ$2$1$2.m("rt:t", () => __RΦ$2$1$2.a(629))(QueueLog$3.prototype, "createEnqueue");
	__RΦ$2$1$2.m("rt:f", "M#.")(QueueLog$3.prototype["createDequeue"]);
	((t, p) => __RΦ$2$1$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$3.prototype, "createDequeue");
	__RΦ$2$1$2.m("rt:p", [{ n: "target", t: () => __RΦ$2$1$2.a(273), v: null }, { n: "origin", t: () => __RΦ$2$1$2.a(402), v: null }])(QueueLog$3.prototype, "createDequeue");
	__RΦ$2$1$2.m("rt:f", "M#.")(QueueLog$3.prototype, "createDequeue");
	__RΦ$2$1$2.m("rt:t", () => __RΦ$2$1$2.a(630))(QueueLog$3.prototype, "createDequeue");

	const __RΦ$1$1$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$1$1$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$1$1$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$1$1$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$1$1$2.a(14), __RΦ$1$1$2.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [144]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$1$1$2.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [146]: { RΦ: t => ({ TΦ: "t" }) } } };
	var IΦdefault$k = { name: "IEventEmitter", prototype: {}, identity: Symbol("IEventEmitter (interface)") };
	(t => __RΦ$1$1$2.t[145] = t)(IΦdefault$k);
	__RΦ$1$1$2.m("rt:P", [])(IΦdefault$k);
	__RΦ$1$1$2.m("rt:m", ["on"])(IΦdefault$k);
	__RΦ$1$1$2.m("rt:f", "Ie")(IΦdefault$k);
	__RΦ$1$1$2.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$1$2.a(143), v: null }, { n: "listener", t: () => __RΦ$1$1$2.a(144), v: null }])(IΦdefault$k.prototype, "on");
	__RΦ$1$1$2.m("rt:f", "M")(IΦdefault$k.prototype, "on");
	__RΦ$1$1$2.m("rt:t", () => __RΦ$1$1$2.a(146))(IΦdefault$k.prototype, "on");
	__RΦ$1$1$2.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$1$2.a(143), v: null }, { n: "listener", t: () => __RΦ$1$1$2.a(144), v: null }])(IΦdefault$k.prototype, "on");
	__RΦ$1$1$2.m("rt:f", "M")(IΦdefault$k.prototype, "on");
	__RΦ$1$1$2.m("rt:t", () => __RΦ$1$1$2.a(146))(IΦdefault$k.prototype, "on");

	const __RΦ$t$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$t$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$t$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$t$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [4]: { RΦ: t => ({ TΦ: "~" }) }, [641]: { RΦ: t => ({ TΦ: "[", e: __RΦ$t$3.a(631) }) }, [631]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [658]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$t$3.a(10), __RΦ$t$3.a(633)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [633]: { LΦ: t => Object }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$t$3.a(14), __RΦ$t$3.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [662]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$t$3.a(4) }] }) }, [634]: { RΦ: t => ({ TΦ: "t" }) } } };
	class QueueWithEventEmitter$3 extends Queue$3 {
	    eventEmitter = new EventEmitter__default$3["default"];
	    enqueue(...items) {
	        this.eventEmitter.emit('before-enqueue', this, ...items);
	        super.enqueue(...items);
	        this.eventEmitter.emit('enqueue', this, ...items);
	    }
	    dequeue() {
	        const removed = super.dequeue();
	        this.eventEmitter.emit('dequeue', this, removed);
	        return removed;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	}
	(t => __RΦ$t$3.t[632] = t)(QueueWithEventEmitter$3);
	__RΦ$t$3.m("rt:SP", [])(QueueWithEventEmitter$3);
	__RΦ$t$3.m("rt:P", ["eventEmitter"])(QueueWithEventEmitter$3);
	__RΦ$t$3.m("rt:Sm", [])(QueueWithEventEmitter$3);
	__RΦ$t$3.m("rt:m", ["enqueue", "dequeue", "on"])(QueueWithEventEmitter$3);
	__RΦ$t$3.m("rt:i", [() => undefined])(QueueWithEventEmitter$3);
	__RΦ$t$3.m("rt:f", "Ce")(QueueWithEventEmitter$3);
	__RΦ$t$3.m("rt:t", () => __RΦ$t$3.a(4))(QueueWithEventEmitter$3.prototype, "eventEmitter");
	__RΦ$t$3.m("rt:f", "P#")(QueueWithEventEmitter$3.prototype, "eventEmitter");
	__RΦ$t$3.m("rt:f", "M$")(QueueWithEventEmitter$3.prototype["enqueue"]);
	((t, p) => __RΦ$t$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$3.prototype, "enqueue");
	__RΦ$t$3.m("rt:p", [{ n: "items", t: () => __RΦ$t$3.a(641), v: null }])(QueueWithEventEmitter$3.prototype, "enqueue");
	__RΦ$t$3.m("rt:f", "M$")(QueueWithEventEmitter$3.prototype, "enqueue");
	__RΦ$t$3.m("rt:t", () => __RΦ$t$3.a(23))(QueueWithEventEmitter$3.prototype, "enqueue");
	__RΦ$t$3.m("rt:f", "M$")(QueueWithEventEmitter$3.prototype["dequeue"]);
	((t, p) => __RΦ$t$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$3.prototype, "dequeue");
	__RΦ$t$3.m("rt:p", [])(QueueWithEventEmitter$3.prototype, "dequeue");
	__RΦ$t$3.m("rt:f", "M$")(QueueWithEventEmitter$3.prototype, "dequeue");
	__RΦ$t$3.m("rt:t", () => __RΦ$t$3.a(658))(QueueWithEventEmitter$3.prototype, "dequeue");
	__RΦ$t$3.m("rt:f", "M$")(QueueWithEventEmitter$3.prototype["on"]);
	((t, p) => __RΦ$t$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$3.prototype, "on");
	__RΦ$t$3.m("rt:p", [{ n: "eventName", t: () => __RΦ$t$3.a(143), v: null }, { n: "listener", t: () => __RΦ$t$3.a(662), v: null }])(QueueWithEventEmitter$3.prototype, "on");
	__RΦ$t$3.m("rt:f", "M$")(QueueWithEventEmitter$3.prototype, "on");
	__RΦ$t$3.m("rt:t", () => __RΦ$t$3.a(634))(QueueWithEventEmitter$3.prototype, "on");

	dist$4.Angle = Angle$3;
	dist$4.Convert = Convert$3;
	dist$4.GameLoop = GameLoop$3;
	dist$4.KeyUpDownProcessor = KeyUpDownProcessor$3;
	dist$4.Lazy = Lazy$3;
	dist$4.Queue = Queue$3;
	dist$4.QueueLog = QueueLog$3;
	dist$4.QueueWithEventEmitter = QueueWithEventEmitter$3;
	dist$4.Shortcut = Shortcut$3;
	dist$4.ShortcutDispatcher = ShortcutDispatcher$3;
	dist$4.Timer = Timer$3;
	dist$4.Transform = Transform$1;
	var Vector_1$1 = dist$4.Vector = Vector$3;
	dist$4.execActionScript = execActionScript$3;
	dist$4.execFunctionScript = execFunctionScript$3;
	dist$4.isBrowser = isBrowser$3;
	dist$4.isStoppable = isStoppable$3;
	dist$4.onKeyDown = onKeyDown$3;
	dist$4.onKeyUp = onKeyUp$3;
	dist$4.toOneLine = toOneLine$3;

	const __RΦ$2$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$2$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$2$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$2$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [149]: { LΦ: t => Function }, [86]: { LΦ: t => IΦdefault$b$1 }, [84]: { LΦ: t => Vector_1$1 } } };
	function clockwiseRotateForceActionResolver(increment) {
	    return __RΦ$2$5.f((movable) => movable.appliedForce = movable.appliedForce.rotate(-increment), [__RΦ$2$5.m("rt:p", [{ n: "movable", t: () => __RΦ$2$5.a(86), v: null }]), __RΦ$2$5.m("rt:f", "F>"), __RΦ$2$5.m("rt:t", () => __RΦ$2$5.a(84))], "");
	}
	__RΦ$2$5.m("rt:p", [{ n: "increment", t: () => __RΦ$2$5.a(15), v: null }])(clockwiseRotateForceActionResolver);
	__RΦ$2$5.m("rt:f", "F")(clockwiseRotateForceActionResolver);
	__RΦ$2$5.m("rt:t", () => __RΦ$2$5.a(149))(clockwiseRotateForceActionResolver);

	const __RΦ$1$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$1$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$1$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$1$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [339]: { LΦ: t => Function }, [86]: { LΦ: t => IΦdefault$b$1 }, [84]: { LΦ: t => Vector_1$1 } } };
	function counterclockwiseRotateForceActionResolver(increment) {
	    return __RΦ$1$5.f((movable) => movable.appliedForce = movable.appliedForce.rotate(increment), [__RΦ$1$5.m("rt:p", [{ n: "movable", t: () => __RΦ$1$5.a(86), v: null }]), __RΦ$1$5.m("rt:f", "F>"), __RΦ$1$5.m("rt:t", () => __RΦ$1$5.a(84))], "");
	}
	__RΦ$1$5.m("rt:p", [{ n: "increment", t: () => __RΦ$1$5.a(15), v: null }])(counterclockwiseRotateForceActionResolver);
	__RΦ$1$5.m("rt:f", "F")(counterclockwiseRotateForceActionResolver);
	__RΦ$1$5.m("rt:t", () => __RΦ$1$5.a(339))(counterclockwiseRotateForceActionResolver);

	const __RΦ$M = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$M.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$M.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$M.t[id] = t = l;
	        }
	        return t;
	    }, t: { [341]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$M.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [142]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$M.a(4) }] }) }, [86]: { LΦ: t => IΦdefault$b$1 }, [84]: { LΦ: t => Vector_1$1 } } };
	function toroidalTransformActionResolver(getToroidalSurfaceSize
	//getToroidalSurfaceOffset?: TGetVector
	) {
	    return (__RΦ$M.f((movable) => movable.position = (transformPositionForToroid(movable.position, getToroidalSurfaceSize()
	    //getToroidalSurfaceOffset ? getToroidalSurfaceOffset() : undefined
	    )), [__RΦ$M.m("rt:p", [{ n: "movable", t: () => __RΦ$M.a(86), v: null }]), __RΦ$M.m("rt:f", "F>"), __RΦ$M.m("rt:t", () => __RΦ$M.a(84))], ""));
	}
	__RΦ$M.m("rt:p", [{ n: "getToroidalSurfaceSize", t: () => __RΦ$M.a(341), v: null }])(toroidalTransformActionResolver);
	__RΦ$M.m("rt:f", "F")(toroidalTransformActionResolver);
	__RΦ$M.m("rt:t", () => __RΦ$M.a(142))(toroidalTransformActionResolver);

	const __RΦ$L = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$L.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$L.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$L.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [84]: { RΦ: t => ({ TΦ: "[", e: __RΦ$L.a(14) }) } } };
	var IΦdefault$j = { name: "IGameObject", prototype: {}, identity: Symbol("IGameObject (interface)") };
	(t => __RΦ$L.t[85] = t)(IΦdefault$j);
	__RΦ$L.m("rt:P", ["name", "kind"])(IΦdefault$j);
	__RΦ$L.m("rt:m", [])(IΦdefault$j);
	__RΦ$L.m("rt:f", "Ie")(IΦdefault$j);
	__RΦ$L.m("rt:t", () => __RΦ$L.a(14))(IΦdefault$j.prototype, "name");
	__RΦ$L.m("rt:f", "P")(IΦdefault$j.prototype, "name");
	__RΦ$L.m("rt:t", () => __RΦ$L.a(84))(IΦdefault$j.prototype, "kind");
	__RΦ$L.m("rt:f", "P")(IΦdefault$j.prototype, "kind");
	__RΦ$L.m("rt:t", () => __RΦ$L.a(14))(IΦdefault$j.prototype, "name");
	__RΦ$L.m("rt:f", "P")(IΦdefault$j.prototype, "name");
	__RΦ$L.m("rt:t", () => __RΦ$L.a(84))(IΦdefault$j.prototype, "kind");
	__RΦ$L.m("rt:f", "P")(IΦdefault$j.prototype, "kind");

	const __RΦ$K = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$K.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$K.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$K.t[id] = t = l;
	        }
	        return t;
	    }, t: { [89]: { LΦ: t => undefined }, [84]: { RΦ: t => ({ TΦ: "[", e: __RΦ$K.a(14) }) }, [14]: { LΦ: t => String } } };
	class GameObjectAdapter {
	    universalObject;
	    constructor(universalObject) {
	        this.universalObject = universalObject;
	    }
	    get kind() {
	        return this.universalObject.getValue('kind', ['IGameObject']);
	    }
	    set kind(value) {
	        this.universalObject.setValue('kind', value);
	    }
	    get name() {
	        return this.universalObject.getValue('name', 'theGameObject');
	    }
	    set name(value) {
	        this.universalObject.setValue('name', value);
	    }
	}
	(t => __RΦ$K.t[86] = t)(GameObjectAdapter);
	__RΦ$K.m("rt:SP", [])(GameObjectAdapter);
	__RΦ$K.m("rt:P", ["universalObject", "kind", "kind", "name", "name"])(GameObjectAdapter);
	__RΦ$K.m("rt:Sm", [])(GameObjectAdapter);
	__RΦ$K.m("rt:m", [])(GameObjectAdapter);
	__RΦ$K.m("rt:p", [{ n: "universalObject", t: () => __RΦ$K.a(89), v: null, f: "#" }])(GameObjectAdapter);
	__RΦ$K.m("rt:i", [() => undefined])(GameObjectAdapter);
	__RΦ$K.m("rt:f", "Ce")(GameObjectAdapter);
	__RΦ$K.m("rt:t", () => __RΦ$K.a(84))(GameObjectAdapter.prototype, "kind");
	__RΦ$K.m("rt:f", "P$")(GameObjectAdapter.prototype, "kind");
	__RΦ$K.m("rt:t", () => __RΦ$K.a(84))(GameObjectAdapter.prototype, "kind");
	__RΦ$K.m("rt:f", "P$")(GameObjectAdapter.prototype, "kind");
	__RΦ$K.m("rt:t", () => __RΦ$K.a(14))(GameObjectAdapter.prototype, "name");
	__RΦ$K.m("rt:f", "P$")(GameObjectAdapter.prototype, "name");
	__RΦ$K.m("rt:t", () => __RΦ$K.a(14))(GameObjectAdapter.prototype, "name");
	__RΦ$K.m("rt:f", "P$")(GameObjectAdapter.prototype, "name");

	const __RΦ$J = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$J.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$J.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$J.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String } } };
	var IΦdefault$i = { name: "IRenderable", prototype: {}, identity: Symbol("IRenderable (interface)") };
	(t => __RΦ$J.t[112] = t)(IΦdefault$i);
	__RΦ$J.m("rt:P", ["renderComponent"])(IΦdefault$i);
	__RΦ$J.m("rt:m", [])(IΦdefault$i);
	__RΦ$J.m("rt:f", "Ie")(IΦdefault$i);
	__RΦ$J.m("rt:t", () => __RΦ$J.a(14))(IΦdefault$i.prototype, "renderComponent");
	__RΦ$J.m("rt:f", "P")(IΦdefault$i.prototype, "renderComponent");
	__RΦ$J.m("rt:t", () => __RΦ$J.a(14))(IΦdefault$i.prototype, "renderComponent");
	__RΦ$J.m("rt:f", "P")(IΦdefault$i.prototype, "renderComponent");

	const __RΦ$I = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$I.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$I.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$I.t[id] = t = l;
	        }
	        return t;
	    }, t: { [89]: { LΦ: t => undefined }, [14]: { LΦ: t => String } } };
	class RenderableAdapter {
	    universalObject;
	    constructor(universalObject) {
	        this.universalObject = universalObject;
	    }
	    get renderComponent() {
	        return this.universalObject.getValue('renderComponent', 'UnknownObject');
	    }
	    set renderComponent(value) {
	        this.universalObject.setValue('renderComponent', value);
	    }
	}
	(t => __RΦ$I.t[113] = t)(RenderableAdapter);
	__RΦ$I.m("rt:SP", [])(RenderableAdapter);
	__RΦ$I.m("rt:P", ["universalObject", "renderComponent", "renderComponent"])(RenderableAdapter);
	__RΦ$I.m("rt:Sm", [])(RenderableAdapter);
	__RΦ$I.m("rt:m", [])(RenderableAdapter);
	__RΦ$I.m("rt:p", [{ n: "universalObject", t: () => __RΦ$I.a(89), v: null, f: "#" }])(RenderableAdapter);
	__RΦ$I.m("rt:i", [() => undefined])(RenderableAdapter);
	__RΦ$I.m("rt:f", "Ce")(RenderableAdapter);
	__RΦ$I.m("rt:t", () => __RΦ$I.a(14))(RenderableAdapter.prototype, "renderComponent");
	__RΦ$I.m("rt:f", "P$")(RenderableAdapter.prototype, "renderComponent");
	__RΦ$I.m("rt:t", () => __RΦ$I.a(14))(RenderableAdapter.prototype, "renderComponent");
	__RΦ$I.m("rt:f", "P$")(RenderableAdapter.prototype, "renderComponent");

	const __RΦ$H = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$H.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$H.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$H.t[id] = t = l;
	        }
	        return t;
	    }, t: { [127]: { LΦ: t => undefined } } };
	var IΦdefault$h = { name: "IToroidalSurface", prototype: {}, identity: Symbol("IToroidalSurface (interface)") };
	(t => __RΦ$H.t[586] = t)(IΦdefault$h);
	__RΦ$H.m("rt:P", ["size"])(IΦdefault$h);
	__RΦ$H.m("rt:m", [])(IΦdefault$h);
	__RΦ$H.m("rt:f", "Ie")(IΦdefault$h);
	__RΦ$H.m("rt:t", () => __RΦ$H.a(127))(IΦdefault$h.prototype, "size");
	__RΦ$H.m("rt:f", "P")(IΦdefault$h.prototype, "size");
	__RΦ$H.m("rt:t", () => __RΦ$H.a(127))(IΦdefault$h.prototype, "size");
	__RΦ$H.m("rt:f", "P")(IΦdefault$h.prototype, "size");

	const __RΦ$G = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$G.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$G.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$G.t[id] = t = l;
	        }
	        return t;
	    }, t: { [87]: { LΦ: t => undefined }, [127]: { LΦ: t => undefined } } };
	const NULL_SIZE = {
	    width: 0,
	    height: 0
	};
	class ToroidalSurfaceAdapter {
	    universalObject;
	    constructor(universalObject) {
	        this.universalObject = universalObject;
	    }
	    get size() {
	        return this.universalObject.getValue('size', NULL_SIZE);
	    }
	    set size(value) {
	        this.universalObject.setValue('size', value);
	    }
	}
	(t => __RΦ$G.t[124] = t)(ToroidalSurfaceAdapter);
	__RΦ$G.m("rt:SP", [])(ToroidalSurfaceAdapter);
	__RΦ$G.m("rt:P", ["universalObject", "size", "size"])(ToroidalSurfaceAdapter);
	__RΦ$G.m("rt:Sm", [])(ToroidalSurfaceAdapter);
	__RΦ$G.m("rt:m", [])(ToroidalSurfaceAdapter);
	__RΦ$G.m("rt:p", [{ n: "universalObject", t: () => __RΦ$G.a(87), v: null, f: "#" }])(ToroidalSurfaceAdapter);
	__RΦ$G.m("rt:i", [() => undefined])(ToroidalSurfaceAdapter);
	__RΦ$G.m("rt:f", "Ce")(ToroidalSurfaceAdapter);
	__RΦ$G.m("rt:t", () => __RΦ$G.a(127))(ToroidalSurfaceAdapter.prototype, "size");
	__RΦ$G.m("rt:f", "P$")(ToroidalSurfaceAdapter.prototype, "size");
	__RΦ$G.m("rt:t", () => __RΦ$G.a(127))(ToroidalSurfaceAdapter.prototype, "size");
	__RΦ$G.m("rt:f", "P$")(ToroidalSurfaceAdapter.prototype, "size");

	const __RΦ$F = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$F.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$F.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$F.t[id] = t = l;
	        }
	        return t;
	    }, t: { [235]: { LΦ: t => Vector$5 }, [103]: { LΦ: t => undefined }, [232]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$F.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [101]: { RΦ: t => ({ TΦ: "&", t: [__RΦ$F.a(88), __RΦ$F.a(86)] }) }, [88]: { TΦ: "5", name: "IToroidalRenderProps" }, [86]: { RΦ: t => ({ TΦ: "O", m: [{ n: "children", f: "?", t: __RΦ$F.a(100) }] }) }, [100]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$F.a(10), __RΦ$F.a(13), __RΦ$F.a(14), __RΦ$F.a(15), __RΦ$F.a(18), __RΦ$F.a(20), __RΦ$F.a(93), __RΦ$F.a(97), __RΦ$F.a(98)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [13]: { RΦ: t => ({ TΦ: "n" }) }, [14]: { LΦ: t => String }, [15]: { LΦ: t => Number }, [18]: { RΦ: t => ({ TΦ: "0" }) }, [20]: { RΦ: t => ({ TΦ: "1" }) }, [93]: { RΦ: t => ({ TΦ: "g", t: __RΦ$F.a(89), p: [__RΦ$F.a(1), __RΦ$F.a(1229)] }) }, [89]: { LΦ: t => LΦ_1__namespace.IΦReactElement }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [1229]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$F.a(14), __RΦ$F.a(826), __RΦ$F.a(827)] }) }, [826]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$F.a(4) }] }) }, [827]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__new", f: "", t: __RΦ$F.a(4) }] }) }, [97]: { RΦ: t => ({ TΦ: "g", t: __RΦ$F.a(94), p: [__RΦ$F.a(100)] }) }, [94]: { LΦ: t => Object }, [98]: { LΦ: t => LΦ_1__namespace.IΦReactPortal }, [1550]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$F.a(13), __RΦ$F.a(282)] }) }, [282]: { LΦ: t => LΦ_1__namespace.IΦElement }, [19]: { RΦ: t => ({ TΦ: "1" }) }, [21]: { LΦ: t => Boolean } } };
	var IΦIToroidalRenderProps = { name: "IToroidalRenderProps", prototype: {}, identity: Symbol("IToroidalRenderProps (interface)") };
	(t => __RΦ$F.t[88] = t)(IΦIToroidalRenderProps);
	__RΦ$F.m("rt:P", ["position", "toroidalSurfaceSize", "isVisible"])(IΦIToroidalRenderProps);
	__RΦ$F.m("rt:m", [])(IΦIToroidalRenderProps);
	__RΦ$F.m("rt:f", "Ie")(IΦIToroidalRenderProps);
	__RΦ$F.m("rt:t", () => __RΦ$F.a(235))(IΦIToroidalRenderProps.prototype, "position");
	__RΦ$F.m("rt:f", "P")(IΦIToroidalRenderProps.prototype, "position");
	__RΦ$F.m("rt:t", () => __RΦ$F.a(103))(IΦIToroidalRenderProps.prototype, "toroidalSurfaceSize");
	__RΦ$F.m("rt:f", "P")(IΦIToroidalRenderProps.prototype, "toroidalSurfaceSize");
	__RΦ$F.m("rt:t", () => __RΦ$F.a(232))(IΦIToroidalRenderProps.prototype, "isVisible");
	__RΦ$F.m("rt:f", "P?")(IΦIToroidalRenderProps.prototype, "isVisible");
	__RΦ$F.m("rt:t", () => __RΦ$F.a(235))(IΦIToroidalRenderProps.prototype, "position");
	__RΦ$F.m("rt:f", "P")(IΦIToroidalRenderProps.prototype, "position");
	__RΦ$F.m("rt:t", () => __RΦ$F.a(103))(IΦIToroidalRenderProps.prototype, "toroidalSurfaceSize");
	__RΦ$F.m("rt:f", "P")(IΦIToroidalRenderProps.prototype, "toroidalSurfaceSize");
	__RΦ$F.m("rt:t", () => __RΦ$F.a(232))(IΦIToroidalRenderProps.prototype, "isVisible");
	__RΦ$F.m("rt:f", "P?")(IΦIToroidalRenderProps.prototype, "isVisible");
	/**
	 * Отрисовывает копии игрового объекта для непрерывного пересечения замкнутого пространства типа бублик.
	 * @param position Координаты игрового объекта.
	 * @param toroidalSurfaceSize Размеры игрового пространства.
	 * @param isVisible Функция для оптимизации вывода (возвращает флаг - показывать или нет тот или иной объект).
	 * @param children Отрисовка игрового объекта в своих координатах.
	 */
	function ToroidalRender({ toroidalSurfaceSize, children, isVisible = __RΦ$F.f(() => true, [__RΦ$F.m("rt:p", []), __RΦ$F.m("rt:f", "F>"), __RΦ$F.m("rt:t", () => __RΦ$F.a(19))], ""), position }) {
	    const { width, height } = toroidalSurfaceSize;
	    let offsets = [
	        [+width, +height],
	        [-width, +height],
	        [+width, -height],
	        [-width, -height],
	        [0, +height],
	        [0, -height],
	        [+width, 0],
	        [-width, 0],
	        [0, 0]
	    ];
	    // Для смещенной камеры сложно подсчитать клоны и пока просто тупо выводятся все 8 клонов.
	    // Эти рассчеты оставлены, так как при столкновениях все равно будут считаться только три клона, а не все 8.
	    //
	    // const {x, y} = position
	    //
	    // const middleX = width / 2 + toroidalSurfaceOffset.x
	    // const middleY = height / 2 + toroidalSurfaceOffset.y
	    //
	    // const offsets = (
	    // 	[
	    // 		[[+width, 0], [+width, +height], [0, +height]], // left-bottom
	    // 		[[-width, 0], [-width, +height], [0, +height]], // right-bottom
	    // 		[[+width, 0], [+width, -height], [0, -height]], // left-top
	    // 		[[-width, 0], [-width, -height], [0, -height]], // right-top
	    // 		// [[+150, 0], [+150, +150], [0, +150]], // left-bottom
	    // 		// [[-150, 0], [-150, +150], [0, +150]], // right-bottom
	    // 		// [[+150, 0], [+150, -150], [0, -150]], // left-top
	    // 		// [[-150, 0], [-150, -150], [0, -150]], // right-top
	    // 	][
	    // 		[
	    // 			x < middleX && y < middleY, // left-bottom
	    // 			x > middleX && y < middleY, // right-bottom
	    // 			x < middleX && y > middleY, // left-top
	    // 			x > middleX && y > middleY, // right-top
	    // 		].findIndex(item => item === true)
	    // 	]
	    // )
	    offsets = offsets.filter(__RΦ$F.f(([x, y]) => isVisible(position.translate(new Vector$5(x, y))), [__RΦ$F.m("rt:p", [{ n: "[x, y]", t: () => __RΦ$F.a(4), v: null }]), __RΦ$F.m("rt:f", "F>"), __RΦ$F.m("rt:t", () => __RΦ$F.a(21))], ""));
	    if (offsets.length <= 0)
	        return null;
	    return (jsxRuntime.exports.jsx("g", { children: offsets.map(__RΦ$F.f(([x, y]) => (jsxRuntime.exports.jsx("g", { transform: `translate(${x}, ${y})`, children: children })), [__RΦ$F.m("rt:p", [{ n: "[x, y]", t: () => __RΦ$F.a(4), v: null }]), __RΦ$F.m("rt:f", "F>"), __RΦ$F.m("rt:t", () => __RΦ$F.a(282))], "")) }));
	}
	__RΦ$F.m("rt:p", [{ n: "{toroidalSurfaceSize, children, isVisible = () => true, position}", t: () => __RΦ$F.a(101), v: null }])(ToroidalRender);
	__RΦ$F.m("rt:f", "F")(ToroidalRender);
	__RΦ$F.m("rt:t", () => __RΦ$F.a(1550))(ToroidalRender);

	var _path;

	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

	var SvgSpaceshipImage = function SvgSpaceshipImage(props) {
	  return /*#__PURE__*/react$1.exports.createElement("svg", _extends({
	    width: 21,
	    height: 38,
	    fill: "none",
	    xmlns: "http://www.w3.org/2000/svg"
	  }, props), _path || (_path = /*#__PURE__*/react$1.exports.createElement("path", {
	    d: "M1.19 37 10.5 1.948 19.81 37H1.19Z",
	    stroke: "#000"
	  })));
	};

	function styleInject(css, ref) {
	  if ( ref === void 0 ) ref = {};
	  var insertAt = ref.insertAt;

	  if (!css || typeof document === 'undefined') { return; }

	  var head = document.head || document.getElementsByTagName('head')[0];
	  var style = document.createElement('style');
	  style.type = 'text/css';

	  if (insertAt === 'top') {
	    if (head.firstChild) {
	      head.insertBefore(style, head.firstChild);
	    } else {
	      head.appendChild(style);
	    }
	  } else {
	    head.appendChild(style);
	  }

	  if (style.styleSheet) {
	    style.styleSheet.cssText = css;
	  } else {
	    style.appendChild(document.createTextNode(css));
	  }
	}

	var css_248z$5 = ".Spaceship-module_Spaceship__CTl-L line.Spaceship-module_appliedForce__JDymE {\n  stroke: red; }\n\n.Spaceship-module_Spaceship__CTl-L path {\n  stroke: blue; }\n";
	var styles$4 = {"Spaceship":"Spaceship-module_Spaceship__CTl-L","appliedForce":"Spaceship-module_appliedForce__JDymE"};
	styleInject(css_248z$5);

	const __RΦ$E = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$E.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$E.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$E.t[id] = t = l;
	        }
	        return t;
	    }, t: { [87]: { LΦ: t => undefined }, [2469]: { TΦ: "5", name: "ISpaceshipProps" }, [174]: { LΦ: t => LΦ_1__namespace.IΦElement } } };
	const spaceshipImageSize = {
	    width: 21,
	    height: 38
	};
	var IΦISpaceshipProps = { name: "ISpaceshipProps", prototype: {}, identity: Symbol("ISpaceshipProps (interface)") };
	(t => __RΦ$E.t[2469] = t)(IΦISpaceshipProps);
	__RΦ$E.m("rt:P", ["object"])(IΦISpaceshipProps);
	__RΦ$E.m("rt:m", [])(IΦISpaceshipProps);
	__RΦ$E.m("rt:f", "I")(IΦISpaceshipProps);
	__RΦ$E.m("rt:t", () => __RΦ$E.a(87))(IΦISpaceshipProps.prototype, "object");
	__RΦ$E.m("rt:f", "P")(IΦISpaceshipProps.prototype, "object");
	__RΦ$E.m("rt:t", () => __RΦ$E.a(87))(IΦISpaceshipProps.prototype, "object");
	__RΦ$E.m("rt:f", "P")(IΦISpaceshipProps.prototype, "object");
	function Spaceship({ object }) {
	    const { position, linearVelocity, appliedForce } = new MovableAdapter(object);
	    const { x, y } = position;
	    const transform = (new Transform$2()
	        // Поворачиваем изображение корабля по вектору скорости.
	        // Считаем, что в редакторе нос корабля смотрит строго наверх.
	        .rotate(linearVelocity.rotate(Angle$5.toRadian(90)).angle)
	        // Смещение изображения по центру.
	        .translate(new Vector$5(spaceshipImageSize.width, spaceshipImageSize.height).scale(-1 / 2)));
	    return (jsxRuntime.exports.jsxs("g", { className: styles$4.Spaceship, transform: `translate(${x}, ${y})`, children: [jsxRuntime.exports.jsx("g", { transform: transform.toString(), children: jsxRuntime.exports.jsx(SvgSpaceshipImage, {}) }), jsxRuntime.exports.jsx("line", { className: styles$4.appliedForce, x1: 0, y1: 0, x2: appliedForce.length / 50, y2: 0, transform: `rotate(${Angle$5.toDegree(appliedForce.angle)})` })] }));
	}
	__RΦ$E.m("rt:p", [{ n: "{object}", t: () => __RΦ$E.a(2469), v: null }])(Spaceship);
	__RΦ$E.m("rt:f", "F")(Spaceship);
	__RΦ$E.m("rt:t", () => __RΦ$E.a(174))(Spaceship);

	// This of course could've been more streamlined with internal state instead of
	// refs, but then host hooks / components could not opt out of renders.
	// This could've been exported to its own module, but the current build doesn't
	// seem to work with module imports and I had no more time to spend on this...
	function useResolvedElement(subscriber, refOrElement) {
	  var callbackRefElement = react$1.exports.useRef(null);
	  var lastReportRef = react$1.exports.useRef(null);
	  var cleanupRef = react$1.exports.useRef();
	  var callSubscriber = react$1.exports.useCallback(function () {
	    var element = null;

	    if (callbackRefElement.current) {
	      element = callbackRefElement.current;
	    } else if (refOrElement) {
	      if (refOrElement instanceof HTMLElement) {
	        element = refOrElement;
	      } else {
	        element = refOrElement.current;
	      }
	    }

	    if (lastReportRef.current && lastReportRef.current.element === element && lastReportRef.current.reporter === callSubscriber) {
	      return;
	    }

	    if (cleanupRef.current) {
	      cleanupRef.current(); // Making sure the cleanup is not called accidentally multiple times.

	      cleanupRef.current = null;
	    }

	    lastReportRef.current = {
	      reporter: callSubscriber,
	      element: element
	    }; // Only calling the subscriber, if there's an actual element to report.

	    if (element) {
	      cleanupRef.current = subscriber(element);
	    }
	  }, [refOrElement, subscriber]); // On each render, we check whether a ref changed, or if we got a new raw
	  // element.

	  react$1.exports.useEffect(function () {
	    // With this we're *technically* supporting cases where ref objects' current value changes, but only if there's a
	    // render accompanying that change as well.
	    // To guarantee we always have the right element, one must use the ref callback provided instead, but we support
	    // RefObjects to make the hook API more convenient in certain cases.
	    callSubscriber();
	  }, [callSubscriber]);
	  return react$1.exports.useCallback(function (element) {
	    callbackRefElement.current = element;
	    callSubscriber();
	  }, [callSubscriber]);
	}

	// We're only using the first element of the size sequences, until future versions of the spec solidify on how
	// exactly it'll be used for fragments in multi-column scenarios:
	// From the spec:
	// > The box size properties are exposed as FrozenArray in order to support elements that have multiple fragments,
	// > which occur in multi-column scenarios. However the current definitions of content rect and border box do not
	// > mention how those boxes are affected by multi-column layout. In this spec, there will only be a single
	// > ResizeObserverSize returned in the FrozenArray, which will correspond to the dimensions of the first column.
	// > A future version of this spec will extend the returned FrozenArray to contain the per-fragment size information.
	// (https://drafts.csswg.org/resize-observer/#resize-observer-entry-interface)
	//
	// Also, testing these new box options revealed that in both Chrome and FF everything is returned in the callback,
	// regardless of the "box" option.
	// The spec states the following on this:
	// > This does not have any impact on which box dimensions are returned to the defined callback when the event
	// > is fired, it solely defines which box the author wishes to observe layout changes on.
	// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)
	// I'm not exactly clear on what this means, especially when you consider a later section stating the following:
	// > This section is non-normative. An author may desire to observe more than one CSS box.
	// > In this case, author will need to use multiple ResizeObservers.
	// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)
	// Which is clearly not how current browser implementations behave, and seems to contradict the previous quote.
	// For this reason I decided to only return the requested size,
	// even though it seems we have access to results for all box types.
	// This also means that we get to keep the current api, being able to return a simple { width, height } pair,
	// regardless of box option.
	var extractSize = function extractSize(entry, boxProp, sizeType) {
	  if (!entry[boxProp]) {
	    if (boxProp === "contentBoxSize") {
	      // The dimensions in `contentBoxSize` and `contentRect` are equivalent according to the spec.
	      // See the 6th step in the description for the RO algorithm:
	      // https://drafts.csswg.org/resize-observer/#create-and-populate-resizeobserverentry-h
	      // > Set this.contentRect to logical this.contentBoxSize given target and observedBox of "content-box".
	      // In real browser implementations of course these objects differ, but the width/height values should be equivalent.
	      return entry.contentRect[sizeType === "inlineSize" ? "width" : "height"];
	    }

	    return undefined;
	  } // A couple bytes smaller than calling Array.isArray() and just as effective here.


	  return entry[boxProp][0] ? entry[boxProp][0][sizeType] : // TS complains about this, because the RO entry type follows the spec and does not reflect Firefox's current
	  // behaviour of returning objects instead of arrays for `borderBoxSize` and `contentBoxSize`.
	  // @ts-ignore
	  entry[boxProp][sizeType];
	};

	function useResizeObserver(opts) {
	  if (opts === void 0) {
	    opts = {};
	  }

	  // Saving the callback as a ref. With this, I don't need to put onResize in the
	  // effect dep array, and just passing in an anonymous function without memoising
	  // will not reinstantiate the hook's ResizeObserver.
	  var onResize = opts.onResize;
	  var onResizeRef = react$1.exports.useRef(undefined);
	  onResizeRef.current = onResize;
	  var round = opts.round || Math.round; // Using a single instance throughout the hook's lifetime

	  var resizeObserverRef = react$1.exports.useRef();

	  var _useState = react$1.exports.useState({
	    width: undefined,
	    height: undefined
	  }),
	      size = _useState[0],
	      setSize = _useState[1]; // In certain edge cases the RO might want to report a size change just after
	  // the component unmounted.


	  var didUnmount = react$1.exports.useRef(false);
	  react$1.exports.useEffect(function () {
	    return function () {
	      didUnmount.current = true;
	    };
	  }, []); // Using a ref to track the previous width / height to avoid unnecessary renders.

	  var previous = react$1.exports.useRef({
	    width: undefined,
	    height: undefined
	  }); // This block is kinda like a useEffect, only it's called whenever a new
	  // element could be resolved based on the ref option. It also has a cleanup
	  // function.

	  var refCallback = useResolvedElement(react$1.exports.useCallback(function (element) {
	    // We only use a single Resize Observer instance, and we're instantiating it on demand, only once there's something to observe.
	    // This instance is also recreated when the `box` option changes, so that a new observation is fired if there was a previously observed element with a different box option.
	    if (!resizeObserverRef.current || resizeObserverRef.current.box !== opts.box || resizeObserverRef.current.round !== round) {
	      resizeObserverRef.current = {
	        box: opts.box,
	        round: round,
	        instance: new ResizeObserver(function (entries) {
	          var entry = entries[0];
	          var boxProp = opts.box === "border-box" ? "borderBoxSize" : opts.box === "device-pixel-content-box" ? "devicePixelContentBoxSize" : "contentBoxSize";
	          var reportedWidth = extractSize(entry, boxProp, "inlineSize");
	          var reportedHeight = extractSize(entry, boxProp, "blockSize");
	          var newWidth = reportedWidth ? round(reportedWidth) : undefined;
	          var newHeight = reportedHeight ? round(reportedHeight) : undefined;

	          if (previous.current.width !== newWidth || previous.current.height !== newHeight) {
	            var newSize = {
	              width: newWidth,
	              height: newHeight
	            };
	            previous.current.width = newWidth;
	            previous.current.height = newHeight;

	            if (onResizeRef.current) {
	              onResizeRef.current(newSize);
	            } else {
	              if (!didUnmount.current) {
	                setSize(newSize);
	              }
	            }
	          }
	        })
	      };
	    }

	    resizeObserverRef.current.instance.observe(element, {
	      box: opts.box
	    });
	    return function () {
	      if (resizeObserverRef.current) {
	        resizeObserverRef.current.instance.unobserve(element);
	      }
	    };
	  }, [opts.box, round]), opts.ref);
	  return react$1.exports.useMemo(function () {
	    return {
	      ref: refCallback,
	      width: size.width,
	      height: size.height
	    };
	  }, [refCallback, size ? size.width : null, size ? size.height : null]);
	}

	var dist$3 = {};

	Object.defineProperty(dist$3, '__esModule', { value: true });

	var react = react$1.exports;
	var EventEmitter$3 = events$4.exports;

	function _interopDefaultLegacy$3 (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var EventEmitter__default$2 = /*#__PURE__*/_interopDefaultLegacy$3(EventEmitter$3);

	const __RΦ$t$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$t$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$t$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$t$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [95]: { LΦ: t => SyntaxError }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Обработчик синтаксической ошибки в коде source.
	 * @param error
	 * @param source
	 */
	function syntaxErrorHandler$2(error, source) {
	    console.group('Синтаксическая ошибка');
	    console.log(error.message);
	    console.log(source);
	    console.log(error.stack);
	    console.groupEnd();
	}
	__RΦ$t$2.m("rt:p", [{ n: "error", t: () => __RΦ$t$2.a(95), v: null }, { n: "source", t: () => __RΦ$t$2.a(14), v: null }])(syntaxErrorHandler$2);
	__RΦ$t$2.m("rt:f", "F")(syntaxErrorHandler$2);
	__RΦ$t$2.m("rt:t", () => __RΦ$t$2.a(23))(syntaxErrorHandler$2);

	const __RΦ$s$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$s$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$s$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$s$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [112]: { LΦ: t => Object } } };
	/**
	 * Выполнить скрипт из текста, который возвращает значение типа T.
	 * @param source
	 */
	function execFunctionScript$2(source) {
	    if (!source.trim()) {
	        throw new Error('Не задано тело функции');
	    }
	    try {
	        const code = new Function('', `return (${source})`);
	        return code();
	    }
	    catch (error) {
	        if (error instanceof SyntaxError) {
	            syntaxErrorHandler$2(error, source);
	        }
	        throw error;
	    }
	}
	__RΦ$s$2.m("rt:p", [{ n: "source", t: () => __RΦ$s$2.a(14), v: null }])(execFunctionScript$2);
	__RΦ$s$2.m("rt:f", "F")(execFunctionScript$2);
	__RΦ$s$2.m("rt:t", () => __RΦ$s$2.a(112))(execFunctionScript$2);

	const __RΦ$r$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$r$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$r$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$r$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [113]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$r$2.a(10), __RΦ$r$2.a(14)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Выполнить скрипт из текста, который ничего не возвращает.
	 * @param source
	 */
	function execActionScript$2(source) {
	    if (source) {
	        try {
	            const code = new Function('', source);
	            code();
	        }
	        catch (error) {
	            if (error instanceof SyntaxError) {
	                syntaxErrorHandler$2(error, source);
	            }
	            throw error;
	        }
	    }
	}
	__RΦ$r$2.m("rt:p", [{ n: "source", t: () => __RΦ$r$2.a(113), v: null }])(execActionScript$2);
	__RΦ$r$2.m("rt:f", "F")(execActionScript$2);
	__RΦ$r$2.m("rt:t", () => __RΦ$r$2.a(23))(execActionScript$2);

	const __RΦ$q$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$q$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$q$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$q$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String } } };
	const SPACE$2 = ' ';
	const EOL$2 = '\n';
	const trim$2 = __RΦ$q$2.f((message) => message.trim()
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	, [__RΦ$q$2.m("rt:p", [{ n: "message", t: () => __RΦ$q$2.a(14), v: null }]), __RΦ$q$2.m("rt:f", "F>"), __RΦ$q$2.m("rt:t", () => __RΦ$q$2.a(14))], "trim");
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	function toOneLine$2(message) {
	    return message.trim().split(EOL$2).map(trim$2).join(SPACE$2);
	}
	__RΦ$q$2.m("rt:p", [{ n: "message", t: () => __RΦ$q$2.a(14), v: null }])(toOneLine$2);
	__RΦ$q$2.m("rt:f", "F")(toOneLine$2);
	__RΦ$q$2.m("rt:t", () => __RΦ$q$2.a(14))(toOneLine$2);

	const __RΦ$p$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$p$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$p$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$p$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1]: { RΦ: t => ({ TΦ: "~" }) } } };
	function isBrowser$2() {
	    return new Function('try { return this === window } catch (e) { return false }')();
	}
	__RΦ$p$2.m("rt:p", [])(isBrowser$2);
	__RΦ$p$2.m("rt:f", "F")(isBrowser$2);
	__RΦ$p$2.m("rt:t", () => __RΦ$p$2.a(1))(isBrowser$2);

	const __RΦ$o$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$o$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$o$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$o$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [246]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$o$2.a(15) }, { t: __RΦ$o$2.a(15) }] }) }, [15]: { LΦ: t => Number }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [234]: { LΦ: t => Function } } };
	/**
	 * Бесконечный запрос кадров анимации для текущего компонента.
	 * Если компонент уничтожается, то запрос автоматически отменяется.
	 * Возвращает мгновенный FPS и время с начала анимации в миллисекундах.
	 */
	function useRequestAnimationFrame() {
	    const frame = react.useRef(0);
	    const previousTime = react.useRef(0);
	    const [time, setTime] = react.useState(0);
	    const [framesPerSecond, setFramesPerSecond] = react.useState(0);
	    const render = __RΦ$o$2.f((time) => {
	        setFramesPerSecond(1000 / (time - previousTime.current));
	        setTime(time);
	        previousTime.current = time;
	        frame.current = requestAnimationFrame(render);
	    }, [__RΦ$o$2.m("rt:p", [{ n: "time", t: () => __RΦ$o$2.a(15), v: null }]), __RΦ$o$2.m("rt:f", "F>"), __RΦ$o$2.m("rt:t", () => __RΦ$o$2.a(23))], "render");
	    react.useEffect(__RΦ$o$2.f(() => {
	        frame.current = requestAnimationFrame(render);
	        return __RΦ$o$2.f(() => cancelAnimationFrame(frame.current), [__RΦ$o$2.m("rt:p", []), __RΦ$o$2.m("rt:f", "F>"), __RΦ$o$2.m("rt:t", () => __RΦ$o$2.a(23))], "");
	    }, [__RΦ$o$2.m("rt:p", []), __RΦ$o$2.m("rt:f", "F>"), __RΦ$o$2.m("rt:t", () => __RΦ$o$2.a(234))], ""), []);
	    return [framesPerSecond, time];
	}
	__RΦ$o$2.m("rt:p", [])(useRequestAnimationFrame);
	__RΦ$o$2.m("rt:f", "F")(useRequestAnimationFrame);
	__RΦ$o$2.m("rt:t", () => __RΦ$o$2.a(246))(useRequestAnimationFrame);

	const __RΦ$n$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$n$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$n$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$n$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [21]: { LΦ: t => Boolean } } };
	var IΦdefault$9$2 = { name: "IStoppable", prototype: {}, identity: Symbol("IStoppable (interface)") };
	(t => __RΦ$n$2.t[256] = t)(IΦdefault$9$2);
	__RΦ$n$2.m("rt:P", [])(IΦdefault$9$2);
	__RΦ$n$2.m("rt:m", ["stop"])(IΦdefault$9$2);
	__RΦ$n$2.m("rt:f", "Ie")(IΦdefault$9$2);
	__RΦ$n$2.m("rt:p", [])(IΦdefault$9$2.prototype, "stop");
	__RΦ$n$2.m("rt:f", "M")(IΦdefault$9$2.prototype, "stop");
	__RΦ$n$2.m("rt:t", () => __RΦ$n$2.a(23))(IΦdefault$9$2.prototype, "stop");
	__RΦ$n$2.m("rt:p", [])(IΦdefault$9$2.prototype, "stop");
	__RΦ$n$2.m("rt:f", "M")(IΦdefault$9$2.prototype, "stop");
	__RΦ$n$2.m("rt:t", () => __RΦ$n$2.a(23))(IΦdefault$9$2.prototype, "stop");
	function isStoppable$2(object) {
	    return 'stop' in object && typeof object.stop === 'function';
	}
	__RΦ$n$2.m("rt:p", [{ n: "object", t: () => __RΦ$n$2.a(1), v: null }])(isStoppable$2);
	__RΦ$n$2.m("rt:f", "F")(isStoppable$2);
	__RΦ$n$2.m("rt:t", () => __RΦ$n$2.a(21))(isStoppable$2);

	const __RΦ$m$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$m$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$m$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$m$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	class Angle$2 {
	    /**
	     * Конвертация угла из радиан в градусы.
	     * @param value
	     */
	    static toDegree(value) {
	        return value / Math.PI * 180;
	    }
	    /**
	     * Конвертация угла из градусов в радианы.
	     * @param value
	     */
	    static toRadian(value) {
	        return value * Math.PI / 180;
	    }
	}
	(t => __RΦ$m$2.t[771] = t)(Angle$2);
	__RΦ$m$2.m("rt:SP", [])(Angle$2);
	__RΦ$m$2.m("rt:P", [])(Angle$2);
	__RΦ$m$2.m("rt:Sm", ["toDegree", "toRadian"])(Angle$2);
	__RΦ$m$2.m("rt:m", [])(Angle$2);
	__RΦ$m$2.m("rt:f", "Ce")(Angle$2);
	__RΦ$m$2.m("rt:f", "M$S.")(Angle$2["toDegree"]);
	((t, p) => __RΦ$m$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle$2, "toDegree");
	__RΦ$m$2.m("rt:p", [{ n: "value", t: () => __RΦ$m$2.a(15), v: null }])(Angle$2, "toDegree");
	__RΦ$m$2.m("rt:f", "M$S.")(Angle$2, "toDegree");
	__RΦ$m$2.m("rt:t", () => __RΦ$m$2.a(15))(Angle$2, "toDegree");
	__RΦ$m$2.m("rt:f", "M$S.")(Angle$2["toRadian"]);
	((t, p) => __RΦ$m$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle$2, "toRadian");
	__RΦ$m$2.m("rt:p", [{ n: "value", t: () => __RΦ$m$2.a(15), v: null }])(Angle$2, "toRadian");
	__RΦ$m$2.m("rt:f", "M$S.")(Angle$2, "toRadian");
	__RΦ$m$2.m("rt:t", () => __RΦ$m$2.a(15))(Angle$2, "toRadian");

	const __RΦ$l$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$l$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$l$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$l$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	var IΦdefault$8$2 = { name: "IPoint", prototype: {}, identity: Symbol("IPoint (interface)") };
	(t => __RΦ$l$2.t[247] = t)(IΦdefault$8$2);
	__RΦ$l$2.m("rt:P", ["x", "y"])(IΦdefault$8$2);
	__RΦ$l$2.m("rt:m", [])(IΦdefault$8$2);
	__RΦ$l$2.m("rt:f", "Ie")(IΦdefault$8$2);
	__RΦ$l$2.m("rt:t", () => __RΦ$l$2.a(15))(IΦdefault$8$2.prototype, "x");
	__RΦ$l$2.m("rt:f", "P")(IΦdefault$8$2.prototype, "x");
	__RΦ$l$2.m("rt:t", () => __RΦ$l$2.a(15))(IΦdefault$8$2.prototype, "y");
	__RΦ$l$2.m("rt:f", "P")(IΦdefault$8$2.prototype, "y");
	__RΦ$l$2.m("rt:t", () => __RΦ$l$2.a(15))(IΦdefault$8$2.prototype, "x");
	__RΦ$l$2.m("rt:f", "P")(IΦdefault$8$2.prototype, "x");
	__RΦ$l$2.m("rt:t", () => __RΦ$l$2.a(15))(IΦdefault$8$2.prototype, "y");
	__RΦ$l$2.m("rt:f", "P")(IΦdefault$8$2.prototype, "y");

	const __RΦ$k$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$k$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$k$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$k$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [247]: { LΦ: t => IΦdefault$8$2 }, [745]: { TΦ: "5", name: "default" }, [21]: { LΦ: t => Boolean }, [768]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$k$2.a(15), __RΦ$k$2.a(745)] }) }, [769]: { RΦ: t => ({ TΦ: "[", e: __RΦ$k$2.a(15) }) }, [14]: { LΦ: t => String } } };
	/*
	 * Увеличить длину вектора можно так:
	 * Vector.translate(Vector.identity.scale(length))
	 *
	 */
	/**
	 * Вектор.
	 * @unmutable
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/vector/Vector.js
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/Point.js
	 */
	class Vector$2 {
	    x;
	    y;
	    /**
	     * Расстояние от начала координат до точки.
	     */
	    static distance(point) {
	        // noinspection JSSuspiciousNameCombination
	        return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
	    }
	    /**
	     * Создать вектор на основе угла и длины.
	     */
	    static create(angle, length) {
	        return new Vector$2(length * Math.cos(angle), length * Math.sin(angle));
	    }
	    /**
	     * Угол между вектором и положительной осью.
	     * Принимает значение от -Math.PI до Math.PI радиан.
	     */
	    get angle() {
	        return Math.atan2(this.y, this.x);
	    }
	    /**
	     * Модуль (длина) вектора.
	     */
	    get length() {
	        return Vector$2.distance(this);
	    }
	    /**
	     * Возвращает true, если вектор является нулевым.
	     */
	    get isNull() {
	        return this.x === 0 && this.y === 0;
	    }
	    /**
	     * Конструктор вектора.
	     * @param x
	     * @param y
	     */
	    constructor(x = 0, y = 0) {
	        this.x = x;
	        this.y = y;
	    }
	    /**
	     * Получить единичный вектор, равный по направлению исходному.
	     * Он же направляющий вектор (единичный, равный по направлению).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get identity() {
	        return (new Vector$2(Math.cos(this.angle), Math.sin(this.angle)));
	    }
	    /**
	     * Получить обратный вектор (инверсия вектора).
	     */
	    get inverse() {
	        return new Vector$2(-this.x, -this.y);
	    }
	    /**
	     * Нормаль вектора (единичный вектор, перпендикулярный исходному).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get normal() {
	        return this.clone().rotate(Math.PI / 2).identity;
	        // TODO Проверить эту формулу нахождения перпендикулярного вектора.
	        /*
	            a: 1 / parallel.x(),
	            b: -1 / parallel.y(),
	        */
	    }
	    /**
	     * Сложение векторов.
	     * @param vector
	     */
	    translate(vector) {
	        return new Vector$2(this.x + vector.x, this.y + vector.y);
	    }
	    /**
	     * Вращение вектора.
	     * @param angle
	     */
	    rotate(angle) {
	        return new Vector$2(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle));
	    }
	    /**
	     * Умножение на число или масштабирование вектором.
	     * @param scale
	     */
	    scale(scale) {
	        return (scale instanceof Vector$2
	            ? new Vector$2(this.x * scale.x, this.y * scale.y)
	            : new Vector$2(this.x * scale, this.y * scale));
	    }
	    /**
	     * Скалярное произведение векторов.
	     *
	     * Скалярным произведением двух векторов называется число (скаляр),
	     * равное произведению длин этих векторов на косинус угла между ними.
	     * Длина вектора является его модулем.
	     * @param vector
	     */
	    multiply(vector) {
	        Object.defineProperty(this, 'Эту строку удалить после реализации метода', { value: vector });
	        throw new Error('Метод не реализован Vector.multiply()');
	    }
	    /**
	     * Взятие остатка от деления.
	     * @param vector
	     */
	    mod(vector) {
	        return new Vector$2(this.x % vector.x, this.y % vector.y);
	    }
	    clone() {
	        return new Vector$2(this.x, this.y);
	    }
	    toArray() {
	        return [this.x, this.y];
	    }
	    toString(digits = 2) {
	        return `[${this.x.toFixed(digits)}, ${this.y.toFixed(digits)}]`;
	    }
	}
	(t => __RΦ$k$2.t[745] = t)(Vector$2);
	__RΦ$k$2.m("rt:SP", [])(Vector$2);
	__RΦ$k$2.m("rt:P", ["angle", "length", "isNull", "x", "y", "identity", "inverse", "normal"])(Vector$2);
	__RΦ$k$2.m("rt:Sm", ["distance", "create"])(Vector$2);
	__RΦ$k$2.m("rt:m", ["translate", "rotate", "scale", "scale", "scale", "multiply", "mod", "clone", "toArray", "toString"])(Vector$2);
	__RΦ$k$2.m("rt:p", [{ n: "x", t: () => __RΦ$k$2.a(15), v: function () { return 0; }, f: "$R" }, { n: "y", t: () => __RΦ$k$2.a(15), v: function () { return 0; }, f: "$R" }])(Vector$2);
	__RΦ$k$2.m("rt:i", [() => undefined])(Vector$2);
	__RΦ$k$2.m("rt:f", "Ce")(Vector$2);
	__RΦ$k$2.m("rt:f", "M$S")(Vector$2["distance"]);
	((t, p) => __RΦ$k$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$2, "distance");
	__RΦ$k$2.m("rt:p", [{ n: "point", t: () => __RΦ$k$2.a(247), v: null }])(Vector$2, "distance");
	__RΦ$k$2.m("rt:f", "M$S")(Vector$2, "distance");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(15))(Vector$2, "distance");
	__RΦ$k$2.m("rt:f", "M$S")(Vector$2["create"]);
	((t, p) => __RΦ$k$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$2, "create");
	__RΦ$k$2.m("rt:p", [{ n: "angle", t: () => __RΦ$k$2.a(15), v: null }, { n: "length", t: () => __RΦ$k$2.a(15), v: null }])(Vector$2, "create");
	__RΦ$k$2.m("rt:f", "M$S")(Vector$2, "create");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(745))(Vector$2, "create");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(15))(Vector$2.prototype, "angle");
	__RΦ$k$2.m("rt:f", "P$")(Vector$2.prototype, "angle");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(15))(Vector$2.prototype, "length");
	__RΦ$k$2.m("rt:f", "P$")(Vector$2.prototype, "length");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(21))(Vector$2.prototype, "isNull");
	__RΦ$k$2.m("rt:f", "P$")(Vector$2.prototype, "isNull");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(745))(Vector$2.prototype, "identity");
	__RΦ$k$2.m("rt:f", "P$")(Vector$2.prototype, "identity");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(745))(Vector$2.prototype, "inverse");
	__RΦ$k$2.m("rt:f", "P$")(Vector$2.prototype, "inverse");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(745))(Vector$2.prototype, "normal");
	__RΦ$k$2.m("rt:f", "P$")(Vector$2.prototype, "normal");
	__RΦ$k$2.m("rt:f", "M$")(Vector$2.prototype["translate"]);
	((t, p) => __RΦ$k$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$2.prototype, "translate");
	__RΦ$k$2.m("rt:p", [{ n: "vector", t: () => __RΦ$k$2.a(745), v: null }])(Vector$2.prototype, "translate");
	__RΦ$k$2.m("rt:f", "M$")(Vector$2.prototype, "translate");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(745))(Vector$2.prototype, "translate");
	__RΦ$k$2.m("rt:f", "M$.")(Vector$2.prototype["rotate"]);
	((t, p) => __RΦ$k$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$2.prototype, "rotate");
	__RΦ$k$2.m("rt:p", [{ n: "angle", t: () => __RΦ$k$2.a(15), v: null }])(Vector$2.prototype, "rotate");
	__RΦ$k$2.m("rt:f", "M$.")(Vector$2.prototype, "rotate");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(745))(Vector$2.prototype, "rotate");
	__RΦ$k$2.m("rt:f", "M$")(Vector$2.prototype["scale"]);
	((t, p) => __RΦ$k$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$2.prototype, "scale");
	__RΦ$k$2.m("rt:p", [{ n: "scale", t: () => __RΦ$k$2.a(15), v: null }])(Vector$2.prototype, "scale");
	__RΦ$k$2.m("rt:f", "M$")(Vector$2.prototype, "scale");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(745))(Vector$2.prototype, "scale");
	__RΦ$k$2.m("rt:f", "M$")(Vector$2.prototype["scale"]);
	((t, p) => __RΦ$k$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$2.prototype, "scale");
	__RΦ$k$2.m("rt:p", [{ n: "scale", t: () => __RΦ$k$2.a(745), v: null }])(Vector$2.prototype, "scale");
	__RΦ$k$2.m("rt:f", "M$")(Vector$2.prototype, "scale");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(745))(Vector$2.prototype, "scale");
	__RΦ$k$2.m("rt:f", "M$")(Vector$2.prototype["scale"]);
	((t, p) => __RΦ$k$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$2.prototype, "scale");
	__RΦ$k$2.m("rt:p", [{ n: "scale", t: () => __RΦ$k$2.a(768), v: null }])(Vector$2.prototype, "scale");
	__RΦ$k$2.m("rt:f", "M$")(Vector$2.prototype, "scale");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(745))(Vector$2.prototype, "scale");
	__RΦ$k$2.m("rt:f", "M$")(Vector$2.prototype["multiply"]);
	((t, p) => __RΦ$k$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$2.prototype, "multiply");
	__RΦ$k$2.m("rt:p", [{ n: "vector", t: () => __RΦ$k$2.a(745), v: null }])(Vector$2.prototype, "multiply");
	__RΦ$k$2.m("rt:f", "M$")(Vector$2.prototype, "multiply");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(15))(Vector$2.prototype, "multiply");
	__RΦ$k$2.m("rt:f", "M$")(Vector$2.prototype["mod"]);
	((t, p) => __RΦ$k$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$2.prototype, "mod");
	__RΦ$k$2.m("rt:p", [{ n: "vector", t: () => __RΦ$k$2.a(745), v: null }])(Vector$2.prototype, "mod");
	__RΦ$k$2.m("rt:f", "M$")(Vector$2.prototype, "mod");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(745))(Vector$2.prototype, "mod");
	__RΦ$k$2.m("rt:f", "M$.")(Vector$2.prototype["clone"]);
	((t, p) => __RΦ$k$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$2.prototype, "clone");
	__RΦ$k$2.m("rt:p", [])(Vector$2.prototype, "clone");
	__RΦ$k$2.m("rt:f", "M$.")(Vector$2.prototype, "clone");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(745))(Vector$2.prototype, "clone");
	__RΦ$k$2.m("rt:f", "M$.")(Vector$2.prototype["toArray"]);
	((t, p) => __RΦ$k$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$2.prototype, "toArray");
	__RΦ$k$2.m("rt:p", [])(Vector$2.prototype, "toArray");
	__RΦ$k$2.m("rt:f", "M$.")(Vector$2.prototype, "toArray");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(769))(Vector$2.prototype, "toArray");
	__RΦ$k$2.m("rt:f", "M$.")(Vector$2.prototype["toString"]);
	((t, p) => __RΦ$k$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$2.prototype, "toString");
	__RΦ$k$2.m("rt:p", [{ n: "digits", t: () => __RΦ$k$2.a(15), v: function () { return 2; } }])(Vector$2.prototype, "toString");
	__RΦ$k$2.m("rt:f", "M$.")(Vector$2.prototype, "toString");
	__RΦ$k$2.m("rt:t", () => __RΦ$k$2.a(14))(Vector$2.prototype, "toString");

	const __RΦ$j$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$j$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$j$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$j$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [103]: { RΦ: t => ({ TΦ: "[", e: __RΦ$j$2.a(14) }) }, [14]: { LΦ: t => String }, [745]: { LΦ: t => Vector$2 }, [776]: { RΦ: t => ({ TΦ: "t" }) }, [15]: { LΦ: t => Number } } };
	class Transform {
	    transforms = [];
	    scale({ x, y }) {
	        this.transforms.push(`scale(${x}, ${y})`);
	        return this;
	    }
	    rotate(angle) {
	        this.transforms.push(`rotate(${Angle$2.toDegree(angle)})`);
	        return this;
	    }
	    translate({ x, y }) {
	        this.transforms.push(`translate(${x}, ${y})`);
	        return this;
	    }
	    toString() {
	        return this.transforms.join(', ');
	    }
	}
	(t => __RΦ$j$2.t[775] = t)(Transform);
	__RΦ$j$2.m("rt:SP", [])(Transform);
	__RΦ$j$2.m("rt:P", ["transforms"])(Transform);
	__RΦ$j$2.m("rt:Sm", [])(Transform);
	__RΦ$j$2.m("rt:m", ["scale", "rotate", "translate", "toString"])(Transform);
	__RΦ$j$2.m("rt:f", "Ce")(Transform);
	__RΦ$j$2.m("rt:t", () => __RΦ$j$2.a(103))(Transform.prototype, "transforms");
	__RΦ$j$2.m("rt:f", "P#")(Transform.prototype, "transforms");
	__RΦ$j$2.m("rt:f", "M$")(Transform.prototype["scale"]);
	((t, p) => __RΦ$j$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Transform.prototype, "scale");
	__RΦ$j$2.m("rt:p", [{ n: "{x, y}", t: () => __RΦ$j$2.a(745), v: null }])(Transform.prototype, "scale");
	__RΦ$j$2.m("rt:f", "M$")(Transform.prototype, "scale");
	__RΦ$j$2.m("rt:t", () => __RΦ$j$2.a(776))(Transform.prototype, "scale");
	__RΦ$j$2.m("rt:f", "M$")(Transform.prototype["rotate"]);
	((t, p) => __RΦ$j$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Transform.prototype, "rotate");
	__RΦ$j$2.m("rt:p", [{ n: "angle", t: () => __RΦ$j$2.a(15), v: null }])(Transform.prototype, "rotate");
	__RΦ$j$2.m("rt:f", "M$")(Transform.prototype, "rotate");
	__RΦ$j$2.m("rt:t", () => __RΦ$j$2.a(776))(Transform.prototype, "rotate");
	__RΦ$j$2.m("rt:f", "M$")(Transform.prototype["translate"]);
	((t, p) => __RΦ$j$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Transform.prototype, "translate");
	__RΦ$j$2.m("rt:p", [{ n: "{x, y}", t: () => __RΦ$j$2.a(745), v: null }])(Transform.prototype, "translate");
	__RΦ$j$2.m("rt:f", "M$")(Transform.prototype, "translate");
	__RΦ$j$2.m("rt:t", () => __RΦ$j$2.a(776))(Transform.prototype, "translate");
	__RΦ$j$2.m("rt:f", "M$")(Transform.prototype["toString"]);
	((t, p) => __RΦ$j$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Transform.prototype, "toString");
	__RΦ$j$2.m("rt:p", [])(Transform.prototype, "toString");
	__RΦ$j$2.m("rt:f", "M$")(Transform.prototype, "toString");
	__RΦ$j$2.m("rt:t", () => __RΦ$j$2.a(14))(Transform.prototype, "toString");

	const __RΦ$i$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$i$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$i$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$i$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$7$2 = { name: "IStartable", prototype: {}, identity: Symbol("IStartable (interface)") };
	(t => __RΦ$i$2.t[255] = t)(IΦdefault$7$2);
	__RΦ$i$2.m("rt:P", [])(IΦdefault$7$2);
	__RΦ$i$2.m("rt:m", ["start"])(IΦdefault$7$2);
	__RΦ$i$2.m("rt:f", "Ie")(IΦdefault$7$2);
	__RΦ$i$2.m("rt:p", [])(IΦdefault$7$2.prototype, "start");
	__RΦ$i$2.m("rt:f", "M")(IΦdefault$7$2.prototype, "start");
	__RΦ$i$2.m("rt:t", () => __RΦ$i$2.a(23))(IΦdefault$7$2.prototype, "start");
	__RΦ$i$2.m("rt:p", [])(IΦdefault$7$2.prototype, "start");
	__RΦ$i$2.m("rt:f", "M")(IΦdefault$7$2.prototype, "start");
	__RΦ$i$2.m("rt:t", () => __RΦ$i$2.a(23))(IΦdefault$7$2.prototype, "start");

	/**
	 * Состояния таймера.
	 */
	var ETimerState$2;
	(function (ETimerState) {
	    ETimerState["Started"] = "started";
	    ETimerState["Paused"] = "paused";
	    ETimerState["Stopped"] = "stopped";
	})(ETimerState$2 || (ETimerState$2 = {}));

	const __RΦ$h$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$h$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$h$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$h$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [785]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$h$2.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [786]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$h$2.a(4) }] }) }, [787]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$h$2.a(4) }] }) } } };
	var IΦdefault$6$2 = { name: "IStateHandlers", prototype: {}, identity: Symbol("IStateHandlers (interface)") };
	(t => __RΦ$h$2.t[788] = t)(IΦdefault$6$2);
	__RΦ$h$2.m("rt:P", ["started", "paused", "stopped"])(IΦdefault$6$2);
	__RΦ$h$2.m("rt:m", [])(IΦdefault$6$2);
	__RΦ$h$2.m("rt:f", "Ie")(IΦdefault$6$2);
	__RΦ$h$2.m("rt:t", () => __RΦ$h$2.a(785))(IΦdefault$6$2.prototype, "started");
	__RΦ$h$2.m("rt:f", "P?")(IΦdefault$6$2.prototype, "started");
	__RΦ$h$2.m("rt:t", () => __RΦ$h$2.a(786))(IΦdefault$6$2.prototype, "paused");
	__RΦ$h$2.m("rt:f", "P?")(IΦdefault$6$2.prototype, "paused");
	__RΦ$h$2.m("rt:t", () => __RΦ$h$2.a(787))(IΦdefault$6$2.prototype, "stopped");
	__RΦ$h$2.m("rt:f", "P?")(IΦdefault$6$2.prototype, "stopped");
	__RΦ$h$2.m("rt:t", () => __RΦ$h$2.a(785))(IΦdefault$6$2.prototype, "started");
	__RΦ$h$2.m("rt:f", "P?")(IΦdefault$6$2.prototype, "started");
	__RΦ$h$2.m("rt:t", () => __RΦ$h$2.a(786))(IΦdefault$6$2.prototype, "paused");
	__RΦ$h$2.m("rt:f", "P?")(IΦdefault$6$2.prototype, "paused");
	__RΦ$h$2.m("rt:t", () => __RΦ$h$2.a(787))(IΦdefault$6$2.prototype, "stopped");
	__RΦ$h$2.m("rt:f", "P?")(IΦdefault$6$2.prototype, "stopped");

	const __RΦ$g$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$g$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$g$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$g$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [808]: { RΦ: t => ({ TΦ: "e", e: ETimerState$2 }) }, [792]: { RΦ: t => ({ TΦ: "g", t: __RΦ$g$2.a(788), p: [__RΦ$g$2.a(791)] }) }, [788]: { LΦ: t => IΦdefault$6$2 }, [791]: { LΦ: t => Object }, [809]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$g$2.a(10), __RΦ$g$2.a(791)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	/**
	 * Запустить определенный скрипт в зависимости от состояния таймера.
	 * @param state Текущее состояние таймера.
	 * @param stateHandlers Массив скриптов (ключ - имя состояния, значение - скрипт).
	 */
	function handleByState$2(state, stateHandlers) {
	    switch (state) {
	        case ETimerState$2.Started: return stateHandlers.started ? stateHandlers.started() : undefined;
	        case ETimerState$2.Paused: return stateHandlers.paused ? stateHandlers.paused() : undefined;
	        case ETimerState$2.Stopped: return stateHandlers.stopped ? stateHandlers.stopped() : undefined;
	    }
	}
	__RΦ$g$2.m("rt:p", [{ n: "state", t: () => __RΦ$g$2.a(808), v: null }, { n: "stateHandlers", t: () => __RΦ$g$2.a(792), v: null }])(handleByState$2);
	__RΦ$g$2.m("rt:f", "F")(handleByState$2);
	__RΦ$g$2.m("rt:t", () => __RΦ$g$2.a(809))(handleByState$2);

	const __RΦ$f$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$f$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$f$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$f$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [1718]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$f$2.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [751]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$f$2.a(10), __RΦ$f$2.a(15)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [808]: { RΦ: t => ({ TΦ: "e", e: ETimerState$2 }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Простая реализация таймера.
	 */
	class Timer$2 {
	    timeout;
	    action;
	    timerId;
	    /**
	     * Время запуска таймера. В миллисекундах.
	     * @private
	     */
	    time = 0;
	    /**
	     * Время постановки на паузу. В миллисекундах.
	     * @private
	     */
	    pauseTime = 0;
	    /**
	     * Общее время остановки таймера. В миллисекундах.
	     * @private
	     */
	    _pauseInterval = 0;
	    get pauseInterval() {
	        return this._pauseInterval;
	    }
	    /**
	     * Текущее состояние таймера
	     * @private
	     */
	    state = ETimerState$2.Stopped;
	    /**
	     * Внимание, внутри action определена this как Timer.
	     * @param timeout
	     * @param action
	     */
	    constructor(timeout, action) {
	        this.timeout = timeout;
	        this.action = action;
	    }
	    /**
	     * Запуск таймера.
	     * Стартовать таймер сначала или продолжить с паузы.
	     */
	    start() {
	        handleByState$2(this.state, {
	            paused: __RΦ$f$2.f(() => {
	                this.state = ETimerState$2.Started;
	                this._pauseInterval += Date.now() - this.pauseTime;
	            }, [__RΦ$f$2.m("rt:p", []), __RΦ$f$2.m("rt:f", "F>"), __RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(23))], "paused"),
	            stopped: __RΦ$f$2.f(() => {
	                this.state = ETimerState$2.Started;
	                this.timerId = window.setInterval(this.tick.bind(this), this.timeout);
	                this.time = Date.now();
	            }, [__RΦ$f$2.m("rt:p", []), __RΦ$f$2.m("rt:f", "F>"), __RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(23))], "stopped")
	        });
	    }
	    /**
	     * Поставить на паузу таймер.
	     * Состояние сохраняется, счет приостанавливается.
	     */
	    pause() {
	        handleByState$2(this.state, {
	            started: __RΦ$f$2.f(() => {
	                this.state = ETimerState$2.Paused;
	                this.pauseTime = Date.now();
	            }, [__RΦ$f$2.m("rt:p", []), __RΦ$f$2.m("rt:f", "F>"), __RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(23))], "started")
	        });
	    }
	    /**
	     * Остановить таймер.
	     * Полный сброс таймера.
	     */
	    stop() {
	        const stop = __RΦ$f$2.f(() => {
	            this.state = ETimerState$2.Stopped;
	            clearInterval(this.timerId);
	            this.timerId = undefined;
	            this.time = 0;
	        }, [__RΦ$f$2.m("rt:p", []), __RΦ$f$2.m("rt:f", "F>"), __RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(23))], "stop");
	        handleByState$2(this.state, {
	            started: stop,
	            paused: stop
	        });
	    }
	    /**
	     * Количество миллисекунд с начала старта таймера.
	     * С учетом всех пауз.
	     */
	    get interval() {
	        const result = handleByState$2(this.state, {
	            started: () => Date.now() - this.time - this.pauseTime,
	            paused: () => this.time - this.pauseTime,
	            stopped: () => 0
	        });
	        return result === undefined ? 0 : result;
	    }
	    /**
	     * Выполняемая нагрузка таймера.
	     * @private
	     */
	    tick() {
	        handleByState$2(this.state, {
	            started: __RΦ$f$2.f(() => this.action.call(this), [__RΦ$f$2.m("rt:p", []), __RΦ$f$2.m("rt:f", "F>"), __RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(23))], "started")
	        });
	    }
	}
	(t => __RΦ$f$2.t[811] = t)(Timer$2);
	__RΦ$f$2.m("rt:SP", [])(Timer$2);
	__RΦ$f$2.m("rt:P", ["timerId", "time", "pauseTime", "_pauseInterval", "pauseInterval", "state", "timeout", "action", "interval"])(Timer$2);
	__RΦ$f$2.m("rt:Sm", [])(Timer$2);
	__RΦ$f$2.m("rt:m", ["start", "pause", "stop", "tick"])(Timer$2);
	__RΦ$f$2.m("rt:p", [{ n: "timeout", t: () => __RΦ$f$2.a(15), v: null, f: "#" }, { n: "action", t: () => __RΦ$f$2.a(1718), v: null, f: "#" }])(Timer$2);
	__RΦ$f$2.m("rt:i", [() => undefined, () => undefined])(Timer$2);
	__RΦ$f$2.m("rt:f", "Ce")(Timer$2);
	__RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(751))(Timer$2.prototype, "timerId");
	__RΦ$f$2.m("rt:f", "P#")(Timer$2.prototype, "timerId");
	__RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(15))(Timer$2.prototype, "time");
	__RΦ$f$2.m("rt:f", "P#")(Timer$2.prototype, "time");
	__RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(15))(Timer$2.prototype, "pauseTime");
	__RΦ$f$2.m("rt:f", "P#")(Timer$2.prototype, "pauseTime");
	__RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(15))(Timer$2.prototype, "_pauseInterval");
	__RΦ$f$2.m("rt:f", "P#")(Timer$2.prototype, "_pauseInterval");
	__RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(15))(Timer$2.prototype, "pauseInterval");
	__RΦ$f$2.m("rt:f", "P$")(Timer$2.prototype, "pauseInterval");
	__RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(808))(Timer$2.prototype, "state");
	__RΦ$f$2.m("rt:f", "P#")(Timer$2.prototype, "state");
	__RΦ$f$2.m("rt:f", "M$.")(Timer$2.prototype["start"]);
	((t, p) => __RΦ$f$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$2.prototype, "start");
	__RΦ$f$2.m("rt:p", [])(Timer$2.prototype, "start");
	__RΦ$f$2.m("rt:f", "M$.")(Timer$2.prototype, "start");
	__RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(23))(Timer$2.prototype, "start");
	__RΦ$f$2.m("rt:f", "M$.")(Timer$2.prototype["pause"]);
	((t, p) => __RΦ$f$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$2.prototype, "pause");
	__RΦ$f$2.m("rt:p", [])(Timer$2.prototype, "pause");
	__RΦ$f$2.m("rt:f", "M$.")(Timer$2.prototype, "pause");
	__RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(23))(Timer$2.prototype, "pause");
	__RΦ$f$2.m("rt:f", "M$.")(Timer$2.prototype["stop"]);
	((t, p) => __RΦ$f$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$2.prototype, "stop");
	__RΦ$f$2.m("rt:p", [])(Timer$2.prototype, "stop");
	__RΦ$f$2.m("rt:f", "M$.")(Timer$2.prototype, "stop");
	__RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(23))(Timer$2.prototype, "stop");
	__RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(15))(Timer$2.prototype, "interval");
	__RΦ$f$2.m("rt:f", "P$")(Timer$2.prototype, "interval");
	__RΦ$f$2.m("rt:f", "M#.")(Timer$2.prototype["tick"]);
	((t, p) => __RΦ$f$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$2.prototype, "tick");
	__RΦ$f$2.m("rt:p", [])(Timer$2.prototype, "tick");
	__RΦ$f$2.m("rt:f", "M#.")(Timer$2.prototype, "tick");
	__RΦ$f$2.m("rt:t", () => __RΦ$f$2.a(23))(Timer$2.prototype, "tick");

	const __RΦ$e$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$e$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$e$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$e$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1722]: { LΦ: t => Object } } };
	var IΦdefault$5$2 = { name: "ICreator", prototype: {}, identity: Symbol("ICreator (interface)") };
	(t => __RΦ$e$2.t[1723] = t)(IΦdefault$5$2);
	__RΦ$e$2.m("rt:P", [])(IΦdefault$5$2);
	__RΦ$e$2.m("rt:m", ["create"])(IΦdefault$5$2);
	__RΦ$e$2.m("rt:f", "Ie")(IΦdefault$5$2);
	__RΦ$e$2.m("rt:p", [])(IΦdefault$5$2.prototype, "create");
	__RΦ$e$2.m("rt:f", "M")(IΦdefault$5$2.prototype, "create");
	__RΦ$e$2.m("rt:t", () => __RΦ$e$2.a(1722))(IΦdefault$5$2.prototype, "create");
	__RΦ$e$2.m("rt:p", [])(IΦdefault$5$2.prototype, "create");
	__RΦ$e$2.m("rt:f", "M")(IΦdefault$5$2.prototype, "create");
	__RΦ$e$2.m("rt:t", () => __RΦ$e$2.a(1722))(IΦdefault$5$2.prototype, "create");

	const __RΦ$d$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$d$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$d$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$d$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1725]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$d$3.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1733]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$d$3.a(10), __RΦ$d$3.a(1727)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1727]: { LΦ: t => Object }, [1730]: { RΦ: t => ({ TΦ: "g", t: __RΦ$d$3.a(1723), p: [__RΦ$d$3.a(1727)] }) }, [1723]: { LΦ: t => IΦdefault$5$2 } } };
	/**
	 * Отложенная инициализация.
	 * @link https://metanit.com/sharp/tutorial/20.1.php
	 * @link https://docs.microsoft.com/ru-ru/dotnet/api/system.lazy-1?view=net-5.0
	 */
	class Lazy$2 {
	    #value;
	    #creator;
	    constructor(createFn) {
	        this.#creator = {
	            create() {
	                return createFn();
	            }
	        };
	    }
	    get value() {
	        if (!this.#value) {
	            this.#value = this.#creator.create();
	        }
	        return this.#value;
	    }
	}
	(t => __RΦ$d$3.t[1726] = t)(Lazy$2);
	__RΦ$d$3.m("rt:SP", [])(Lazy$2);
	__RΦ$d$3.m("rt:P", ["#value", "#creator", "value"])(Lazy$2);
	__RΦ$d$3.m("rt:Sm", [])(Lazy$2);
	__RΦ$d$3.m("rt:m", [])(Lazy$2);
	__RΦ$d$3.m("rt:p", [{ n: "createFn", t: () => __RΦ$d$3.a(1725), v: null }])(Lazy$2);
	__RΦ$d$3.m("rt:f", "Ce")(Lazy$2);
	__RΦ$d$3.m("rt:t", () => __RΦ$d$3.a(1733))(Lazy$2.prototype, "#value");
	__RΦ$d$3.m("rt:f", "P")(Lazy$2.prototype, "#value");
	__RΦ$d$3.m("rt:t", () => __RΦ$d$3.a(1730))(Lazy$2.prototype, "#creator");
	__RΦ$d$3.m("rt:f", "P")(Lazy$2.prototype, "#creator");
	__RΦ$d$3.m("rt:t", () => __RΦ$d$3.a(1727))(Lazy$2.prototype, "value");
	__RΦ$d$3.m("rt:f", "P")(Lazy$2.prototype, "value");

	const __RΦ$c$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$c$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$c$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$c$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [257]: { LΦ: t => Object }, [258]: { LΦ: t => Object } } };
	var IΦdefault$4$2 = { name: "IKeyValueObject", prototype: {}, identity: Symbol("IKeyValueObject (interface)") };
	(t => __RΦ$c$3.t[259] = t)(IΦdefault$4$2);
	__RΦ$c$3.m("rt:P", ["key", "value"])(IΦdefault$4$2);
	__RΦ$c$3.m("rt:m", [])(IΦdefault$4$2);
	__RΦ$c$3.m("rt:f", "Ie")(IΦdefault$4$2);
	__RΦ$c$3.m("rt:t", () => __RΦ$c$3.a(257))(IΦdefault$4$2.prototype, "key");
	__RΦ$c$3.m("rt:f", "P")(IΦdefault$4$2.prototype, "key");
	__RΦ$c$3.m("rt:t", () => __RΦ$c$3.a(258))(IΦdefault$4$2.prototype, "value");
	__RΦ$c$3.m("rt:f", "P")(IΦdefault$4$2.prototype, "value");
	__RΦ$c$3.m("rt:t", () => __RΦ$c$3.a(257))(IΦdefault$4$2.prototype, "key");
	__RΦ$c$3.m("rt:f", "P")(IΦdefault$4$2.prototype, "key");
	__RΦ$c$3.m("rt:t", () => __RΦ$c$3.a(258))(IΦdefault$4$2.prototype, "value");
	__RΦ$c$3.m("rt:f", "P")(IΦdefault$4$2.prototype, "value");

	const __RΦ$b$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$b$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$b$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$b$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1918]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$3.a(262), p: [__RΦ$b$3.a(1916), __RΦ$b$3.a(1917)] }) }, [262]: { LΦ: t => Map }, [1916]: { LΦ: t => Object }, [1917]: { LΦ: t => Object }, [1922]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$3.a(1926) }) }, [1926]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$3.a(259), p: [__RΦ$b$3.a(1916), __RΦ$b$3.a(1925)] }) }, [259]: { LΦ: t => IΦdefault$4$2 }, [1925]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b$3.a(10), __RΦ$b$3.a(1917)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1929]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b$3.a(1930), p: [__RΦ$b$3.a(1927), __RΦ$b$3.a(1928)] }) }, [1930]: { LΦ: t => Object }, [1927]: { LΦ: t => Object }, [1928]: { LΦ: t => Object }, [1934]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$3.a(1936) }) }, [1936]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$3.a(259), p: [__RΦ$b$3.a(1927), __RΦ$b$3.a(1928)] }) }, [1755]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b$3.a(1748), __RΦ$b$3.a(1753)] }) }, [1748]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$3.a(262), p: [__RΦ$b$3.a(1737), __RΦ$b$3.a(1738)] }) }, [1737]: { LΦ: t => Object }, [1738]: { LΦ: t => Object }, [1753]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b$3.a(1754), p: [__RΦ$b$3.a(1737), __RΦ$b$3.a(1738)] }) }, [1754]: { LΦ: t => Object }, [1739]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$3.a(1742) }) }, [1742]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$3.a(259), p: [__RΦ$b$3.a(1737), __RΦ$b$3.a(1738)] }) }, [15]: { LΦ: t => Number } } };
	/**
	 * Конвертация разнообразных значений.
	 */
	class Convert$2 {
	    static toArray(object) {
	        const result = [];
	        if (object instanceof Map) {
	            for (const [key, value] of object) {
	                result.push({ key, value });
	            }
	        }
	        else {
	            for (const key in object) {
	                if (!object.hasOwnProperty(key))
	                    continue;
	                result.push({ key, value: Reflect.get(object, key) });
	            }
	        }
	        return result;
	    }
	    /**
	     * Конвертировать миллисекунды в секунды.
	     * @param millisecond
	     */
	    static toSecond(millisecond) {
	        return millisecond / 1000;
	    }
	}
	(t => __RΦ$b$3.t[1914] = t)(Convert$2);
	__RΦ$b$3.m("rt:SP", [])(Convert$2);
	__RΦ$b$3.m("rt:P", [])(Convert$2);
	__RΦ$b$3.m("rt:Sm", ["toArray", "toArray", "toArray", "toSecond"])(Convert$2);
	__RΦ$b$3.m("rt:m", [])(Convert$2);
	__RΦ$b$3.m("rt:f", "Ce")(Convert$2);
	__RΦ$b$3.m("rt:f", "M$S")(Convert$2["toArray"]);
	((t, p) => __RΦ$b$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$2, "toArray");
	__RΦ$b$3.m("rt:p", [{ n: "object", t: () => __RΦ$b$3.a(1918), v: null }])(Convert$2, "toArray");
	__RΦ$b$3.m("rt:f", "M$S")(Convert$2, "toArray");
	__RΦ$b$3.m("rt:t", () => __RΦ$b$3.a(1922))(Convert$2, "toArray");
	__RΦ$b$3.m("rt:f", "M$S")(Convert$2["toArray"]);
	((t, p) => __RΦ$b$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$2, "toArray");
	__RΦ$b$3.m("rt:p", [{ n: "object", t: () => __RΦ$b$3.a(1929), v: null }])(Convert$2, "toArray");
	__RΦ$b$3.m("rt:f", "M$S")(Convert$2, "toArray");
	__RΦ$b$3.m("rt:t", () => __RΦ$b$3.a(1934))(Convert$2, "toArray");
	__RΦ$b$3.m("rt:f", "M$S")(Convert$2["toArray"]);
	((t, p) => __RΦ$b$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$2, "toArray");
	__RΦ$b$3.m("rt:p", [{ n: "object", t: () => __RΦ$b$3.a(1755), v: null }])(Convert$2, "toArray");
	__RΦ$b$3.m("rt:f", "M$S")(Convert$2, "toArray");
	__RΦ$b$3.m("rt:t", () => __RΦ$b$3.a(1739))(Convert$2, "toArray");
	__RΦ$b$3.m("rt:f", "M$S.")(Convert$2["toSecond"]);
	((t, p) => __RΦ$b$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$2, "toSecond");
	__RΦ$b$3.m("rt:p", [{ n: "millisecond", t: () => __RΦ$b$3.a(15), v: null }])(Convert$2, "toSecond");
	__RΦ$b$3.m("rt:f", "M$S.")(Convert$2, "toSecond");
	__RΦ$b$3.m("rt:t", () => __RΦ$b$3.a(15))(Convert$2, "toSecond");

	const __RΦ$a$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$a$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$a$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$a$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1960]: { LΦ: t => 60 }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [15]: { LΦ: t => Number }, [1956]: { LΦ: t => "update" }, [1962]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$3.a(4) }] }) }, [1938]: { RΦ: t => ({ TΦ: "t" }) }, [1958]: { LΦ: t => "render" }, [1963]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$3.a(4) }] }) }, [249]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$a$3.a(14), __RΦ$a$3.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1940]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$3.a(4) }] }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * http://gs-studio.com/news-about-it/30703----javascript
	 * https://eatdog.com.ua/assets/gamedev-slides/
	 * https://www.youtube.com/watch?v=-gsjAz9jR3Y
	 */
	class GameLoop$2 {
	    framePerSecond;
	    eventEmitter = new EventEmitter__default$2["default"];
	    time = 0;
	    timeInterval = 0;
	    renderTime = 0;
	    renderTimeInterval = 0;
	    /**
	     * Текущий FPS отрисовки игровой сцены.
	     */
	    get renderFramePerSecond() {
	        return 1 / (this.renderTimeInterval / 1000);
	    }
	    /**
	     * Временной шаг, с которым вызывается функция update для вычисления игровой логики.
	     * Измеряется в миллисекундах.
	     */
	    get step() {
	        return (1 / this.framePerSecond) / 1000;
	    }
	    constructor(
	    /**
	     * Частота обновления игровой логики (генерации события update).
	     * @private
	     */
	    framePerSecond = 60 // TODO Переименовать в updatePerSecond?
	    ) {
	        this.framePerSecond = framePerSecond;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	    start() {
	        this.time = performance.now();
	        this.timeInterval = 0;
	        requestAnimationFrame(this.frame.bind(this));
	    }
	    stop() {
	    }
	    pause() {
	    }
	    frame() {
	        // Обработка логики игры.
	        {
	            const currentTime = performance.now();
	            // Исправление проблемы неактивных вкладок.
	            // Разрешить максимальную задержку между вызовами не более, чем 1 секунда.
	            this.timeInterval = this.timeInterval + Math.min(1000, currentTime - this.time);
	            while (this.timeInterval > this.step) {
	                this.timeInterval = this.timeInterval - this.step;
	                this.eventEmitter.emit('update', this.step);
	            }
	            this.time = currentTime;
	        }
	        // Обработка отрисовки сцены игры.
	        {
	            const renderCurrentTime = performance.now();
	            this.renderTimeInterval = renderCurrentTime - this.renderTime;
	            this.renderTime = renderCurrentTime;
	            this.eventEmitter.emit('render', this.timeInterval);
	        }
	        requestAnimationFrame(this.frame.bind(this));
	    }
	}
	(t => __RΦ$a$3.t[1937] = t)(GameLoop$2);
	__RΦ$a$3.m("rt:SP", [])(GameLoop$2);
	__RΦ$a$3.m("rt:P", ["eventEmitter", "time", "timeInterval", "renderTime", "renderTimeInterval", "renderFramePerSecond", "step", "framePerSecond"])(GameLoop$2);
	__RΦ$a$3.m("rt:Sm", [])(GameLoop$2);
	__RΦ$a$3.m("rt:m", ["on", "on", "on", "start", "stop", "pause", "frame"])(GameLoop$2);
	__RΦ$a$3.m("rt:p", [{ n: "framePerSecond", t: () => __RΦ$a$3.a(1960), v: function () { return 60 // TODO Переименовать в updatePerSecond?
	        ; }, f: "#R" }])(GameLoop$2);
	__RΦ$a$3.m("rt:i", [() => undefined, () => undefined])(GameLoop$2);
	__RΦ$a$3.m("rt:f", "Ce")(GameLoop$2);
	__RΦ$a$3.m("rt:t", () => __RΦ$a$3.a(4))(GameLoop$2.prototype, "eventEmitter");
	__RΦ$a$3.m("rt:f", "P#R")(GameLoop$2.prototype, "eventEmitter");
	__RΦ$a$3.m("rt:t", () => __RΦ$a$3.a(15))(GameLoop$2.prototype, "time");
	__RΦ$a$3.m("rt:f", "P#")(GameLoop$2.prototype, "time");
	__RΦ$a$3.m("rt:t", () => __RΦ$a$3.a(15))(GameLoop$2.prototype, "timeInterval");
	__RΦ$a$3.m("rt:f", "P#")(GameLoop$2.prototype, "timeInterval");
	__RΦ$a$3.m("rt:t", () => __RΦ$a$3.a(15))(GameLoop$2.prototype, "renderTime");
	__RΦ$a$3.m("rt:f", "P#")(GameLoop$2.prototype, "renderTime");
	__RΦ$a$3.m("rt:t", () => __RΦ$a$3.a(15))(GameLoop$2.prototype, "renderTimeInterval");
	__RΦ$a$3.m("rt:f", "P#")(GameLoop$2.prototype, "renderTimeInterval");
	__RΦ$a$3.m("rt:t", () => __RΦ$a$3.a(15))(GameLoop$2.prototype, "renderFramePerSecond");
	__RΦ$a$3.m("rt:f", "P$")(GameLoop$2.prototype, "renderFramePerSecond");
	__RΦ$a$3.m("rt:t", () => __RΦ$a$3.a(15))(GameLoop$2.prototype, "step");
	__RΦ$a$3.m("rt:f", "P$")(GameLoop$2.prototype, "step");
	__RΦ$a$3.m("rt:f", "M")(GameLoop$2.prototype["on"]);
	((t, p) => __RΦ$a$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$2.prototype, "on");
	__RΦ$a$3.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$3.a(1956), v: null }, { n: "update", t: () => __RΦ$a$3.a(1962), v: null }])(GameLoop$2.prototype, "on");
	__RΦ$a$3.m("rt:f", "M")(GameLoop$2.prototype, "on");
	__RΦ$a$3.m("rt:t", () => __RΦ$a$3.a(1938))(GameLoop$2.prototype, "on");
	__RΦ$a$3.m("rt:f", "M")(GameLoop$2.prototype["on"]);
	((t, p) => __RΦ$a$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$2.prototype, "on");
	__RΦ$a$3.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$3.a(1958), v: null }, { n: "render", t: () => __RΦ$a$3.a(1963), v: null }])(GameLoop$2.prototype, "on");
	__RΦ$a$3.m("rt:f", "M")(GameLoop$2.prototype, "on");
	__RΦ$a$3.m("rt:t", () => __RΦ$a$3.a(1938))(GameLoop$2.prototype, "on");
	__RΦ$a$3.m("rt:f", "M")(GameLoop$2.prototype["on"]);
	((t, p) => __RΦ$a$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$2.prototype, "on");
	__RΦ$a$3.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$3.a(249), v: null }, { n: "listener", t: () => __RΦ$a$3.a(1940), v: null }])(GameLoop$2.prototype, "on");
	__RΦ$a$3.m("rt:f", "M")(GameLoop$2.prototype, "on");
	__RΦ$a$3.m("rt:t", () => __RΦ$a$3.a(1938))(GameLoop$2.prototype, "on");
	__RΦ$a$3.m("rt:f", "M$")(GameLoop$2.prototype["start"]);
	((t, p) => __RΦ$a$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$2.prototype, "start");
	__RΦ$a$3.m("rt:p", [])(GameLoop$2.prototype, "start");
	__RΦ$a$3.m("rt:f", "M$")(GameLoop$2.prototype, "start");
	__RΦ$a$3.m("rt:t", () => __RΦ$a$3.a(23))(GameLoop$2.prototype, "start");
	__RΦ$a$3.m("rt:f", "M$")(GameLoop$2.prototype["stop"]);
	((t, p) => __RΦ$a$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$2.prototype, "stop");
	__RΦ$a$3.m("rt:p", [])(GameLoop$2.prototype, "stop");
	__RΦ$a$3.m("rt:f", "M$")(GameLoop$2.prototype, "stop");
	__RΦ$a$3.m("rt:t", () => __RΦ$a$3.a(23))(GameLoop$2.prototype, "stop");
	__RΦ$a$3.m("rt:f", "M$")(GameLoop$2.prototype["pause"]);
	((t, p) => __RΦ$a$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$2.prototype, "pause");
	__RΦ$a$3.m("rt:p", [])(GameLoop$2.prototype, "pause");
	__RΦ$a$3.m("rt:f", "M$")(GameLoop$2.prototype, "pause");
	__RΦ$a$3.m("rt:t", () => __RΦ$a$3.a(23))(GameLoop$2.prototype, "pause");
	__RΦ$a$3.m("rt:f", "M#.")(GameLoop$2.prototype["frame"]);
	((t, p) => __RΦ$a$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$2.prototype, "frame");
	__RΦ$a$3.m("rt:p", [])(GameLoop$2.prototype, "frame");
	__RΦ$a$3.m("rt:f", "M#.")(GameLoop$2.prototype, "frame");
	__RΦ$a$3.m("rt:t", () => __RΦ$a$3.a(23))(GameLoop$2.prototype, "frame");

	const __RΦ$9$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$9$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$9$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$9$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1967]: { RΦ: t => ({ TΦ: "g", t: __RΦ$9$3.a(262), p: [__RΦ$9$3.a(14), __RΦ$9$3.a(21)] }) }, [262]: { LΦ: t => Map }, [14]: { LΦ: t => String }, [21]: { LΦ: t => Boolean }, [1970]: { LΦ: t => KeyboardEvent }, [1977]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$3.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1980]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$3.a(4) }] }) }, [1984]: { LΦ: t => Function }, [1983]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$3.a(4) }] }) }, [1985]: { LΦ: t => Function } } };
	/**
	 * Вместо KeyUpDownProcessor используйте Shortcut.
	 * @deprecated
	 * @link http://khusamov.github.io/tutorial/csharp/key-down-up-process
	 */
	class KeyUpDownProcessor$2 {
	    /**
	     * Данный словарь хранит информацию о том, была ли нажата клавиша.
	     * В качестве ключа выступает номер клавиши,
	     * а значение это флаг (была или не была нажата клавиша).
	     * @private
	     * @link https://learn.javascript.ru/keyboard-events
	     */
	    static #theKeyWasDown = new Map;
	    static onKeyDown(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.#theKeyWasDown.has(keyCode)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.#theKeyWasDown.set(keyCode, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.#theKeyWasDown.get(keyCode)) {
	            // Помечаем что она нажата.
	            this.#theKeyWasDown.set(keyCode, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            action();
	        }
	    }
	    static onKeyUp(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Помечаем что она уже не нажата.
	        this.#theKeyWasDown.set(keyCode, false);
	        // Выполняем действие при отжатии клавиши.
	        action();
	    }
	}
	(t => __RΦ$9$3.t[1965] = t)(KeyUpDownProcessor$2);
	__RΦ$9$3.m("rt:SP", ["#theKeyWasDown"])(KeyUpDownProcessor$2);
	__RΦ$9$3.m("rt:P", [])(KeyUpDownProcessor$2);
	__RΦ$9$3.m("rt:Sm", ["onKeyDown", "onKeyUp"])(KeyUpDownProcessor$2);
	__RΦ$9$3.m("rt:m", [])(KeyUpDownProcessor$2);
	__RΦ$9$3.m("rt:f", "Ce")(KeyUpDownProcessor$2);
	__RΦ$9$3.m("rt:t", () => __RΦ$9$3.a(1967))(KeyUpDownProcessor$2, "#theKeyWasDown");
	__RΦ$9$3.m("rt:f", "P")(KeyUpDownProcessor$2, "#theKeyWasDown");
	__RΦ$9$3.m("rt:f", "M$S.")(KeyUpDownProcessor$2["onKeyDown"]);
	((t, p) => __RΦ$9$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor$2, "onKeyDown");
	__RΦ$9$3.m("rt:p", [{ n: "event", t: () => __RΦ$9$3.a(1970), v: null }, { n: "action", t: () => __RΦ$9$3.a(1977), v: null }])(KeyUpDownProcessor$2, "onKeyDown");
	__RΦ$9$3.m("rt:f", "M$S.")(KeyUpDownProcessor$2, "onKeyDown");
	__RΦ$9$3.m("rt:t", () => __RΦ$9$3.a(23))(KeyUpDownProcessor$2, "onKeyDown");
	__RΦ$9$3.m("rt:f", "M$S.")(KeyUpDownProcessor$2["onKeyUp"]);
	((t, p) => __RΦ$9$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor$2, "onKeyUp");
	__RΦ$9$3.m("rt:p", [{ n: "event", t: () => __RΦ$9$3.a(1970), v: null }, { n: "action", t: () => __RΦ$9$3.a(1977), v: null }])(KeyUpDownProcessor$2, "onKeyUp");
	__RΦ$9$3.m("rt:f", "M$S.")(KeyUpDownProcessor$2, "onKeyUp");
	__RΦ$9$3.m("rt:t", () => __RΦ$9$3.a(23))(KeyUpDownProcessor$2, "onKeyUp");
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyDown$2(listener) {
	    return __RΦ$9$3.f((event) => {
	        KeyUpDownProcessor$2.onKeyDown(event, __RΦ$9$3.f(() => {
	            listener(event);
	        }, [__RΦ$9$3.m("rt:p", []), __RΦ$9$3.m("rt:f", "F>"), __RΦ$9$3.m("rt:t", () => __RΦ$9$3.a(23))], ""));
	    }, [__RΦ$9$3.m("rt:p", [{ n: "event", t: () => __RΦ$9$3.a(1970), v: null }]), __RΦ$9$3.m("rt:f", "F>"), __RΦ$9$3.m("rt:t", () => __RΦ$9$3.a(23))], "");
	}
	__RΦ$9$3.m("rt:p", [{ n: "listener", t: () => __RΦ$9$3.a(1980), v: null }])(onKeyDown$2);
	__RΦ$9$3.m("rt:f", "F")(onKeyDown$2);
	__RΦ$9$3.m("rt:t", () => __RΦ$9$3.a(1984))(onKeyDown$2);
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyUp$2(listener) {
	    return __RΦ$9$3.f((event) => {
	        KeyUpDownProcessor$2.onKeyUp(event, __RΦ$9$3.f(() => {
	            listener(event);
	        }, [__RΦ$9$3.m("rt:p", []), __RΦ$9$3.m("rt:f", "F>"), __RΦ$9$3.m("rt:t", () => __RΦ$9$3.a(23))], ""));
	    }, [__RΦ$9$3.m("rt:p", [{ n: "event", t: () => __RΦ$9$3.a(1970), v: null }]), __RΦ$9$3.m("rt:f", "F>"), __RΦ$9$3.m("rt:t", () => __RΦ$9$3.a(23))], "");
	}
	__RΦ$9$3.m("rt:p", [{ n: "listener", t: () => __RΦ$9$3.a(1983), v: null }])(onKeyUp$2);
	__RΦ$9$3.m("rt:f", "F")(onKeyUp$2);
	__RΦ$9$3.m("rt:t", () => __RΦ$9$3.a(1985))(onKeyUp$2);

	const __RΦ$8$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$8$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$8$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$8$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$3$2 = { name: "IDisposable", prototype: {}, identity: Symbol("IDisposable (interface)") };
	(t => __RΦ$8$3.t[253] = t)(IΦdefault$3$2);
	__RΦ$8$3.m("rt:P", [])(IΦdefault$3$2);
	__RΦ$8$3.m("rt:m", ["dispose"])(IΦdefault$3$2);
	__RΦ$8$3.m("rt:f", "Ie")(IΦdefault$3$2);
	__RΦ$8$3.m("rt:p", [])(IΦdefault$3$2.prototype, "dispose");
	__RΦ$8$3.m("rt:f", "M")(IΦdefault$3$2.prototype, "dispose");
	__RΦ$8$3.m("rt:t", () => __RΦ$8$3.a(23))(IΦdefault$3$2.prototype, "dispose");
	__RΦ$8$3.m("rt:p", [])(IΦdefault$3$2.prototype, "dispose");
	__RΦ$8$3.m("rt:f", "M")(IΦdefault$3$2.prototype, "dispose");
	__RΦ$8$3.m("rt:t", () => __RΦ$8$3.a(23))(IΦdefault$3$2.prototype, "dispose");

	const __RΦ$7$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$7$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$7$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$7$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1986]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$7$3.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) } } };
	var IΦdefault$2$2 = { name: "IKeyboardListeners", prototype: {}, identity: Symbol("IKeyboardListeners (interface)") };
	(t => __RΦ$7$3.t[1987] = t)(IΦdefault$2$2);
	__RΦ$7$3.m("rt:P", ["down", "up"])(IΦdefault$2$2);
	__RΦ$7$3.m("rt:m", [])(IΦdefault$2$2);
	__RΦ$7$3.m("rt:f", "Ie")(IΦdefault$2$2);
	__RΦ$7$3.m("rt:t", () => __RΦ$7$3.a(1986))(IΦdefault$2$2.prototype, "down");
	__RΦ$7$3.m("rt:f", "P")(IΦdefault$2$2.prototype, "down");
	__RΦ$7$3.m("rt:t", () => __RΦ$7$3.a(1986))(IΦdefault$2$2.prototype, "up");
	__RΦ$7$3.m("rt:f", "P")(IΦdefault$2$2.prototype, "up");
	__RΦ$7$3.m("rt:t", () => __RΦ$7$3.a(1986))(IΦdefault$2$2.prototype, "down");
	__RΦ$7$3.m("rt:f", "P")(IΦdefault$2$2.prototype, "down");
	__RΦ$7$3.m("rt:t", () => __RΦ$7$3.a(1986))(IΦdefault$2$2.prototype, "up");
	__RΦ$7$3.m("rt:f", "P")(IΦdefault$2$2.prototype, "up");

	const __RΦ$6$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$6$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$6$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$6$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [828]: { LΦ: t => Object }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1988]: { TΦ: "5", name: "default" }, [2241]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$3.a(262), p: [__RΦ$6$3.a(14), __RΦ$6$3.a(1987)] }) }, [262]: { LΦ: t => Map }, [1987]: { LΦ: t => IΦdefault$2$2 }, [1986]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$6$3.a(4) }] }) }, [1967]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$3.a(262), p: [__RΦ$6$3.a(14), __RΦ$6$3.a(21)] }) }, [21]: { LΦ: t => Boolean }, [253]: { LΦ: t => IΦdefault$3$2 }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1970]: { LΦ: t => KeyboardEvent } } };
	const codeOf$2 = __RΦ$6$3.f((key) => 'Key' + key.toUpperCase(), [__RΦ$6$3.m("rt:p", [{ n: "key", t: () => __RΦ$6$3.a(14), v: null }]), __RΦ$6$3.m("rt:f", "F>"), __RΦ$6$3.m("rt:t", () => __RΦ$6$3.a(14))], "codeOf");
	class ShortcutDispatcher$2 {
	    static instanceHolder = new Lazy$2(() => new ShortcutDispatcher$2);
	    static get instance() {
	        return this.instanceHolder.value;
	    }
	    host;
	    listeners = new Map;
	    keyDownListenerBinded;
	    keyUpListenerBinded;
	    theKeyWasDown = new Map;
	    constructor(host = document) {
	        this.host = host;
	        this.keyDownListenerBinded = this.keyDownListener.bind(this);
	        this.keyUpListenerBinded = this.keyUpListener.bind(this);
	        this.host.addEventListener('keydown', this.keyDownListenerBinded);
	        this.host.addEventListener('keyup', this.keyUpListenerBinded);
	    }
	    register(key, listeners) {
	        this.listeners.set(key, listeners);
	        return {
	            dispose: __RΦ$6$3.f(() => {
	                this.listeners.delete(key);
	                this.theKeyWasDown.delete(codeOf$2(key));
	            }, [__RΦ$6$3.m("rt:p", []), __RΦ$6$3.m("rt:f", "F>"), __RΦ$6$3.m("rt:t", () => __RΦ$6$3.a(23))], "dispose")
	        };
	    }
	    keyDownListener(event) {
	        const code = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.theKeyWasDown.has(code)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.theKeyWasDown.set(code, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.theKeyWasDown.get(code)) {
	            // Помечаем что она нажата.
	            this.theKeyWasDown.set(code, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            for (const [key, listeners] of this.listeners.entries()) {
	                if (code === codeOf$2(key)) {
	                    listeners.down(event);
	                }
	            }
	        }
	    }
	    keyUpListener(event) {
	        // Из события извлекаем номер нажатой клавиши.
	        const code = event.code;
	        // Помечаем что она уже не нажата.
	        this.theKeyWasDown.set(code, false);
	        // Выполняем действие при отжатии клавиши.
	        for (const [key, listeners] of this.listeners.entries()) {
	            if (code === codeOf$2(key)) {
	                listeners.up(event);
	            }
	        }
	    }
	    dispose() {
	        this.host.removeEventListener('keydown', this.keyDownListenerBinded);
	        this.host.removeEventListener('keyup', this.keyUpListenerBinded);
	    }
	}
	(t => __RΦ$6$3.t[1988] = t)(ShortcutDispatcher$2);
	__RΦ$6$3.m("rt:SP", ["instanceHolder", "instance"])(ShortcutDispatcher$2);
	__RΦ$6$3.m("rt:P", ["host", "listeners", "keyDownListenerBinded", "keyUpListenerBinded", "theKeyWasDown"])(ShortcutDispatcher$2);
	__RΦ$6$3.m("rt:Sm", [])(ShortcutDispatcher$2);
	__RΦ$6$3.m("rt:m", ["register", "keyDownListener", "keyUpListener", "dispose"])(ShortcutDispatcher$2);
	__RΦ$6$3.m("rt:p", [{ n: "host", t: () => __RΦ$6$3.a(828), v: function () { return document; } }])(ShortcutDispatcher$2);
	__RΦ$6$3.m("rt:i", [() => undefined])(ShortcutDispatcher$2);
	__RΦ$6$3.m("rt:f", "Ce")(ShortcutDispatcher$2);
	__RΦ$6$3.m("rt:t", () => __RΦ$6$3.a(4))(ShortcutDispatcher$2, "instanceHolder");
	__RΦ$6$3.m("rt:f", "P#R")(ShortcutDispatcher$2, "instanceHolder");
	__RΦ$6$3.m("rt:t", () => __RΦ$6$3.a(1988))(ShortcutDispatcher$2, "instance");
	__RΦ$6$3.m("rt:f", "P$")(ShortcutDispatcher$2, "instance");
	__RΦ$6$3.m("rt:t", () => __RΦ$6$3.a(828))(ShortcutDispatcher$2.prototype, "host");
	__RΦ$6$3.m("rt:f", "P#R")(ShortcutDispatcher$2.prototype, "host");
	__RΦ$6$3.m("rt:t", () => __RΦ$6$3.a(2241))(ShortcutDispatcher$2.prototype, "listeners");
	__RΦ$6$3.m("rt:f", "P#R")(ShortcutDispatcher$2.prototype, "listeners");
	__RΦ$6$3.m("rt:t", () => __RΦ$6$3.a(1986))(ShortcutDispatcher$2.prototype, "keyDownListenerBinded");
	__RΦ$6$3.m("rt:f", "P#R")(ShortcutDispatcher$2.prototype, "keyDownListenerBinded");
	__RΦ$6$3.m("rt:t", () => __RΦ$6$3.a(1986))(ShortcutDispatcher$2.prototype, "keyUpListenerBinded");
	__RΦ$6$3.m("rt:f", "P#R")(ShortcutDispatcher$2.prototype, "keyUpListenerBinded");
	__RΦ$6$3.m("rt:t", () => __RΦ$6$3.a(1967))(ShortcutDispatcher$2.prototype, "theKeyWasDown");
	__RΦ$6$3.m("rt:f", "P#R")(ShortcutDispatcher$2.prototype, "theKeyWasDown");
	__RΦ$6$3.m("rt:f", "M$")(ShortcutDispatcher$2.prototype["register"]);
	((t, p) => __RΦ$6$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$2.prototype, "register");
	__RΦ$6$3.m("rt:p", [{ n: "key", t: () => __RΦ$6$3.a(14), v: null }, { n: "listeners", t: () => __RΦ$6$3.a(1987), v: null }])(ShortcutDispatcher$2.prototype, "register");
	__RΦ$6$3.m("rt:f", "M$")(ShortcutDispatcher$2.prototype, "register");
	__RΦ$6$3.m("rt:t", () => __RΦ$6$3.a(253))(ShortcutDispatcher$2.prototype, "register");
	__RΦ$6$3.m("rt:f", "M#.")(ShortcutDispatcher$2.prototype["keyDownListener"]);
	((t, p) => __RΦ$6$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$2.prototype, "keyDownListener");
	__RΦ$6$3.m("rt:p", [{ n: "event", t: () => __RΦ$6$3.a(1970), v: null }])(ShortcutDispatcher$2.prototype, "keyDownListener");
	__RΦ$6$3.m("rt:f", "M#.")(ShortcutDispatcher$2.prototype, "keyDownListener");
	__RΦ$6$3.m("rt:t", () => __RΦ$6$3.a(23))(ShortcutDispatcher$2.prototype, "keyDownListener");
	__RΦ$6$3.m("rt:f", "M#.")(ShortcutDispatcher$2.prototype["keyUpListener"]);
	((t, p) => __RΦ$6$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$2.prototype, "keyUpListener");
	__RΦ$6$3.m("rt:p", [{ n: "event", t: () => __RΦ$6$3.a(1970), v: null }])(ShortcutDispatcher$2.prototype, "keyUpListener");
	__RΦ$6$3.m("rt:f", "M#.")(ShortcutDispatcher$2.prototype, "keyUpListener");
	__RΦ$6$3.m("rt:t", () => __RΦ$6$3.a(23))(ShortcutDispatcher$2.prototype, "keyUpListener");
	__RΦ$6$3.m("rt:f", "M$.")(ShortcutDispatcher$2.prototype["dispose"]);
	((t, p) => __RΦ$6$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$2.prototype, "dispose");
	__RΦ$6$3.m("rt:p", [])(ShortcutDispatcher$2.prototype, "dispose");
	__RΦ$6$3.m("rt:f", "M$.")(ShortcutDispatcher$2.prototype, "dispose");
	__RΦ$6$3.m("rt:t", () => __RΦ$6$3.a(23))(ShortcutDispatcher$2.prototype, "dispose");

	const __RΦ$5$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$5$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$5$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$5$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [1987]: { LΦ: t => IΦdefault$2$2 }, [253]: { LΦ: t => IΦdefault$3$2 } } };
	class Shortcut$2 {
	    static register(key, listeners) {
	        return ShortcutDispatcher$2.instance.register(key, listeners);
	    }
	}
	(t => __RΦ$5$3.t[2270] = t)(Shortcut$2);
	__RΦ$5$3.m("rt:SP", [])(Shortcut$2);
	__RΦ$5$3.m("rt:P", [])(Shortcut$2);
	__RΦ$5$3.m("rt:Sm", ["register"])(Shortcut$2);
	__RΦ$5$3.m("rt:m", [])(Shortcut$2);
	__RΦ$5$3.m("rt:f", "Ce")(Shortcut$2);
	__RΦ$5$3.m("rt:f", "M$S")(Shortcut$2["register"]);
	((t, p) => __RΦ$5$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Shortcut$2, "register");
	__RΦ$5$3.m("rt:p", [{ n: "key", t: () => __RΦ$5$3.a(14), v: null }, { n: "listeners", t: () => __RΦ$5$3.a(1987), v: null }])(Shortcut$2, "register");
	__RΦ$5$3.m("rt:f", "M$S")(Shortcut$2, "register");
	__RΦ$5$3.m("rt:t", () => __RΦ$5$3.a(253))(Shortcut$2, "register");

	const __RΦ$4$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$4$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$4$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$4$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [272]: { RΦ: t => ({ TΦ: "[", e: __RΦ$4$3.a(271) }) }, [271]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [274]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$4$3.a(10), __RΦ$4$3.a(273)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [273]: { LΦ: t => Object }, [283]: { RΦ: t => ({ TΦ: "g", t: __RΦ$4$3.a(77), p: [__RΦ$4$3.a(273)] }) }, [77]: { LΦ: t => Object } } };
	var IΦdefault$1$2 = { name: "IQueue", prototype: {}, identity: Symbol("IQueue (interface)") };
	(t => __RΦ$4$3.t[284] = t)(IΦdefault$1$2);
	__RΦ$4$3.m("rt:P", ["items"])(IΦdefault$1$2);
	__RΦ$4$3.m("rt:m", ["enqueue", "dequeue"])(IΦdefault$1$2);
	__RΦ$4$3.m("rt:f", "Ie")(IΦdefault$1$2);
	__RΦ$4$3.m("rt:p", [{ n: "items", t: () => __RΦ$4$3.a(272), v: null }])(IΦdefault$1$2.prototype, "enqueue");
	__RΦ$4$3.m("rt:f", "M")(IΦdefault$1$2.prototype, "enqueue");
	__RΦ$4$3.m("rt:t", () => __RΦ$4$3.a(23))(IΦdefault$1$2.prototype, "enqueue");
	__RΦ$4$3.m("rt:p", [])(IΦdefault$1$2.prototype, "dequeue");
	__RΦ$4$3.m("rt:f", "M")(IΦdefault$1$2.prototype, "dequeue");
	__RΦ$4$3.m("rt:t", () => __RΦ$4$3.a(274))(IΦdefault$1$2.prototype, "dequeue");
	__RΦ$4$3.m("rt:t", () => __RΦ$4$3.a(283))(IΦdefault$1$2.prototype, "items");
	__RΦ$4$3.m("rt:f", "PR")(IΦdefault$1$2.prototype, "items");
	__RΦ$4$3.m("rt:p", [{ n: "items", t: () => __RΦ$4$3.a(272), v: null }])(IΦdefault$1$2.prototype, "enqueue");
	__RΦ$4$3.m("rt:f", "M")(IΦdefault$1$2.prototype, "enqueue");
	__RΦ$4$3.m("rt:t", () => __RΦ$4$3.a(23))(IΦdefault$1$2.prototype, "enqueue");
	__RΦ$4$3.m("rt:p", [])(IΦdefault$1$2.prototype, "dequeue");
	__RΦ$4$3.m("rt:f", "M")(IΦdefault$1$2.prototype, "dequeue");
	__RΦ$4$3.m("rt:t", () => __RΦ$4$3.a(274))(IΦdefault$1$2.prototype, "dequeue");
	__RΦ$4$3.m("rt:t", () => __RΦ$4$3.a(283))(IΦdefault$1$2.prototype, "items");
	__RΦ$4$3.m("rt:f", "PR")(IΦdefault$1$2.prototype, "items");

	const __RΦ$3$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$3$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$3$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$3$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [291]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$3.a(288) }) }, [288]: { LΦ: t => Object }, [296]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$3.a(286) }) }, [286]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [303]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$3$3.a(10), __RΦ$3$3.a(288)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [304]: { RΦ: t => ({ TΦ: "g", t: __RΦ$3$3.a(77), p: [__RΦ$3$3.a(288)] }) }, [77]: { LΦ: t => Object } } };
	/**
	 * О́чередь — абстрактный тип данных с дисциплиной доступа к элементам «первый пришёл — первый вышел»
	 * (FIFO, англ. first in, first out).
	 *
	 * Добавление элемента (принято обозначать словом enqueue — поставить в очередь) возможно лишь
	 * в конец очереди, выборка — только из начала очереди (что принято называть словом dequeue — убрать из очереди),
	 * при этом выбранный элемент из очереди удаляется.
	 *
	 * @link https://bit.ly/3tPM13G
	 */
	class Queue$2 {
	    storage = [];
	    enqueue(...items) {
	        this.storage.push(...items);
	    }
	    dequeue() {
	        return this.storage.shift();
	    }
	    get items() {
	        return this.storage;
	    }
	}
	(t => __RΦ$3$3.t[287] = t)(Queue$2);
	__RΦ$3$3.m("rt:SP", [])(Queue$2);
	__RΦ$3$3.m("rt:P", ["storage", "items"])(Queue$2);
	__RΦ$3$3.m("rt:Sm", [])(Queue$2);
	__RΦ$3$3.m("rt:m", ["enqueue", "dequeue"])(Queue$2);
	__RΦ$3$3.m("rt:i", [() => undefined])(Queue$2);
	__RΦ$3$3.m("rt:f", "Ce")(Queue$2);
	__RΦ$3$3.m("rt:t", () => __RΦ$3$3.a(291))(Queue$2.prototype, "storage");
	__RΦ$3$3.m("rt:f", "P#")(Queue$2.prototype, "storage");
	__RΦ$3$3.m("rt:f", "M$")(Queue$2.prototype["enqueue"]);
	((t, p) => __RΦ$3$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue$2.prototype, "enqueue");
	__RΦ$3$3.m("rt:p", [{ n: "items", t: () => __RΦ$3$3.a(296), v: null }])(Queue$2.prototype, "enqueue");
	__RΦ$3$3.m("rt:f", "M$")(Queue$2.prototype, "enqueue");
	__RΦ$3$3.m("rt:t", () => __RΦ$3$3.a(23))(Queue$2.prototype, "enqueue");
	__RΦ$3$3.m("rt:f", "M$")(Queue$2.prototype["dequeue"]);
	((t, p) => __RΦ$3$3.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue$2.prototype, "dequeue");
	__RΦ$3$3.m("rt:p", [])(Queue$2.prototype, "dequeue");
	__RΦ$3$3.m("rt:f", "M$")(Queue$2.prototype, "dequeue");
	__RΦ$3$3.m("rt:t", () => __RΦ$3$3.a(303))(Queue$2.prototype, "dequeue");
	__RΦ$3$3.m("rt:t", () => __RΦ$3$3.a(304))(Queue$2.prototype, "items");
	__RΦ$3$3.m("rt:f", "P$")(Queue$2.prototype, "items");

	const __RΦ$2$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$2$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$2$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$2$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [482]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$4.a(479) }) }, [479]: { LΦ: t => Object }, [349]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$4.a(284), p: [__RΦ$2$4.a(306)] }) }, [284]: { LΦ: t => IΦdefault$1$2 }, [306]: { LΦ: t => Object }, [481]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$4.a(478), p: [__RΦ$2$4.a(306)] }) }, [478]: { TΦ: "5", name: "ILog" }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [697]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$4.a(284), p: [__RΦ$2$4.a(696)] }) }, [696]: { LΦ: t => Object }, [699]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$2$4.a(697) }, { t: __RΦ$2$4.a(698) }] }) }, [698]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$4.a(305), p: [__RΦ$2$4.a(696)] }) }, [305]: { TΦ: "5", name: "default" }, [249]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$4.a(14), __RΦ$2$4.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [472]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [700]: { LΦ: t => Function }, [483]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$4.a(306) }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [477]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [701]: { LΦ: t => Function }, [503]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$4.a(10), __RΦ$2$4.a(306)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	var IΦILog$2 = { name: "ILog", prototype: {}, identity: Symbol("ILog (interface)") };
	(t => __RΦ$2$4.t[478] = t)(IΦILog$2);
	__RΦ$2$4.m("rt:P", ["enqueue", "dequeue"])(IΦILog$2);
	__RΦ$2$4.m("rt:m", [])(IΦILog$2);
	__RΦ$2$4.m("rt:f", "I")(IΦILog$2);
	__RΦ$2$4.m("rt:t", () => __RΦ$2$4.a(482))(IΦILog$2.prototype, "enqueue");
	__RΦ$2$4.m("rt:f", "P")(IΦILog$2.prototype, "enqueue");
	__RΦ$2$4.m("rt:t", () => __RΦ$2$4.a(482))(IΦILog$2.prototype, "dequeue");
	__RΦ$2$4.m("rt:f", "P")(IΦILog$2.prototype, "dequeue");
	__RΦ$2$4.m("rt:t", () => __RΦ$2$4.a(482))(IΦILog$2.prototype, "enqueue");
	__RΦ$2$4.m("rt:f", "P")(IΦILog$2.prototype, "enqueue");
	__RΦ$2$4.m("rt:t", () => __RΦ$2$4.a(482))(IΦILog$2.prototype, "dequeue");
	__RΦ$2$4.m("rt:f", "P")(IΦILog$2.prototype, "dequeue");
	class QueueLog$2 {
	    queue;
	    queueProxy;
	    log = {
	        enqueue: [],
	        dequeue: []
	    };
	    get sourceQueue() {
	        return this.queue;
	    }
	    get loggedQueue() {
	        return this.queueProxy;
	    }
	    static create(queue) {
	        const queueLog = new QueueLog$2(queue);
	        return [queueLog.loggedQueue, queueLog];
	    }
	    constructor(queue) {
	        this.queue = queue;
	        this.queueProxy = (new Proxy(queue, {
	            get: this.proxyHandlerGet.bind(this)
	        }));
	    }
	    proxyHandlerGet(target, property, receiver) {
	        const origin = Reflect.get(target, property, receiver);
	        switch (property) {
	            case 'enqueue': return this.createEnqueue(target, origin);
	            case 'dequeue': return this.createDequeue(target, origin);
	            default: return origin;
	        }
	    }
	    createEnqueue(target, origin) {
	        return (__RΦ$2$4.f((...items) => {
	            this.log.enqueue.push(...items);
	            origin.call(target, ...items);
	        }, [__RΦ$2$4.m("rt:p", [{ n: "items", t: () => __RΦ$2$4.a(483), v: null }]), __RΦ$2$4.m("rt:f", "F>"), __RΦ$2$4.m("rt:t", () => __RΦ$2$4.a(23))], ""));
	    }
	    createDequeue(target, origin) {
	        return (__RΦ$2$4.f(() => {
	            const item = origin.call(target);
	            if (item) {
	                this.log.dequeue.push(item);
	            }
	            return item;
	        }, [__RΦ$2$4.m("rt:p", []), __RΦ$2$4.m("rt:f", "F>"), __RΦ$2$4.m("rt:t", () => __RΦ$2$4.a(503))], ""));
	    }
	}
	(t => __RΦ$2$4.t[305] = t)(QueueLog$2);
	__RΦ$2$4.m("rt:SP", [])(QueueLog$2);
	__RΦ$2$4.m("rt:P", ["queueProxy", "log", "sourceQueue", "loggedQueue", "queue"])(QueueLog$2);
	__RΦ$2$4.m("rt:Sm", ["create"])(QueueLog$2);
	__RΦ$2$4.m("rt:m", ["proxyHandlerGet", "createEnqueue", "createDequeue"])(QueueLog$2);
	__RΦ$2$4.m("rt:p", [{ n: "queue", t: () => __RΦ$2$4.a(349), v: null, f: "#" }])(QueueLog$2);
	__RΦ$2$4.m("rt:f", "Ce")(QueueLog$2);
	__RΦ$2$4.m("rt:t", () => __RΦ$2$4.a(349))(QueueLog$2.prototype, "queueProxy");
	__RΦ$2$4.m("rt:f", "P#R")(QueueLog$2.prototype, "queueProxy");
	__RΦ$2$4.m("rt:t", () => __RΦ$2$4.a(481))(QueueLog$2.prototype, "log");
	__RΦ$2$4.m("rt:f", "P#")(QueueLog$2.prototype, "log");
	__RΦ$2$4.m("rt:t", () => __RΦ$2$4.a(4))(QueueLog$2.prototype, "sourceQueue");
	__RΦ$2$4.m("rt:f", "P$")(QueueLog$2.prototype, "sourceQueue");
	__RΦ$2$4.m("rt:t", () => __RΦ$2$4.a(4))(QueueLog$2.prototype, "loggedQueue");
	__RΦ$2$4.m("rt:f", "P$")(QueueLog$2.prototype, "loggedQueue");
	__RΦ$2$4.m("rt:f", "M$S")(QueueLog$2["create"]);
	((t, p) => __RΦ$2$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$2, "create");
	__RΦ$2$4.m("rt:p", [{ n: "queue", t: () => __RΦ$2$4.a(697), v: null }])(QueueLog$2, "create");
	__RΦ$2$4.m("rt:f", "M$S")(QueueLog$2, "create");
	__RΦ$2$4.m("rt:t", () => __RΦ$2$4.a(699))(QueueLog$2, "create");
	__RΦ$2$4.m("rt:f", "M#")(QueueLog$2.prototype["proxyHandlerGet"]);
	((t, p) => __RΦ$2$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$2.prototype, "proxyHandlerGet");
	__RΦ$2$4.m("rt:p", [{ n: "target", t: () => __RΦ$2$4.a(349), v: null }, { n: "property", t: () => __RΦ$2$4.a(249), v: null }, { n: "receiver", t: () => __RΦ$2$4.a(1), v: null }])(QueueLog$2.prototype, "proxyHandlerGet");
	__RΦ$2$4.m("rt:f", "M#")(QueueLog$2.prototype, "proxyHandlerGet");
	__RΦ$2$4.m("rt:t", () => __RΦ$2$4.a(1))(QueueLog$2.prototype, "proxyHandlerGet");
	__RΦ$2$4.m("rt:f", "M#.")(QueueLog$2.prototype["createEnqueue"]);
	((t, p) => __RΦ$2$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$2.prototype, "createEnqueue");
	__RΦ$2$4.m("rt:p", [{ n: "target", t: () => __RΦ$2$4.a(349), v: null }, { n: "origin", t: () => __RΦ$2$4.a(472), v: null }])(QueueLog$2.prototype, "createEnqueue");
	__RΦ$2$4.m("rt:f", "M#.")(QueueLog$2.prototype, "createEnqueue");
	__RΦ$2$4.m("rt:t", () => __RΦ$2$4.a(700))(QueueLog$2.prototype, "createEnqueue");
	__RΦ$2$4.m("rt:f", "M#.")(QueueLog$2.prototype["createDequeue"]);
	((t, p) => __RΦ$2$4.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$2.prototype, "createDequeue");
	__RΦ$2$4.m("rt:p", [{ n: "target", t: () => __RΦ$2$4.a(349), v: null }, { n: "origin", t: () => __RΦ$2$4.a(477), v: null }])(QueueLog$2.prototype, "createDequeue");
	__RΦ$2$4.m("rt:f", "M#.")(QueueLog$2.prototype, "createDequeue");
	__RΦ$2$4.m("rt:t", () => __RΦ$2$4.a(701))(QueueLog$2.prototype, "createDequeue");

	const __RΦ$1$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$1$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$1$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$1$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [249]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$1$4.a(14), __RΦ$1$4.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [250]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$1$4.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [252]: { RΦ: t => ({ TΦ: "t" }) } } };
	var IΦdefault$g = { name: "IEventEmitter", prototype: {}, identity: Symbol("IEventEmitter (interface)") };
	(t => __RΦ$1$4.t[251] = t)(IΦdefault$g);
	__RΦ$1$4.m("rt:P", [])(IΦdefault$g);
	__RΦ$1$4.m("rt:m", ["on"])(IΦdefault$g);
	__RΦ$1$4.m("rt:f", "Ie")(IΦdefault$g);
	__RΦ$1$4.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$4.a(249), v: null }, { n: "listener", t: () => __RΦ$1$4.a(250), v: null }])(IΦdefault$g.prototype, "on");
	__RΦ$1$4.m("rt:f", "M")(IΦdefault$g.prototype, "on");
	__RΦ$1$4.m("rt:t", () => __RΦ$1$4.a(252))(IΦdefault$g.prototype, "on");
	__RΦ$1$4.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$4.a(249), v: null }, { n: "listener", t: () => __RΦ$1$4.a(250), v: null }])(IΦdefault$g.prototype, "on");
	__RΦ$1$4.m("rt:f", "M")(IΦdefault$g.prototype, "on");
	__RΦ$1$4.m("rt:t", () => __RΦ$1$4.a(252))(IΦdefault$g.prototype, "on");

	const __RΦ$D = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$D.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$D.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$D.t[id] = t = l;
	        }
	        return t;
	    }, t: { [4]: { RΦ: t => ({ TΦ: "~" }) }, [712]: { RΦ: t => ({ TΦ: "[", e: __RΦ$D.a(702) }) }, [702]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [729]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$D.a(10), __RΦ$D.a(704)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [704]: { LΦ: t => Object }, [249]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$D.a(14), __RΦ$D.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [733]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$D.a(4) }] }) }, [705]: { RΦ: t => ({ TΦ: "t" }) } } };
	class QueueWithEventEmitter$2 extends Queue$2 {
	    eventEmitter = new EventEmitter__default$2["default"];
	    enqueue(...items) {
	        this.eventEmitter.emit('before-enqueue', this, ...items);
	        super.enqueue(...items);
	        this.eventEmitter.emit('enqueue', this, ...items);
	    }
	    dequeue() {
	        const removed = super.dequeue();
	        this.eventEmitter.emit('dequeue', this, removed);
	        return removed;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	}
	(t => __RΦ$D.t[703] = t)(QueueWithEventEmitter$2);
	__RΦ$D.m("rt:SP", [])(QueueWithEventEmitter$2);
	__RΦ$D.m("rt:P", ["eventEmitter"])(QueueWithEventEmitter$2);
	__RΦ$D.m("rt:Sm", [])(QueueWithEventEmitter$2);
	__RΦ$D.m("rt:m", ["enqueue", "dequeue", "on"])(QueueWithEventEmitter$2);
	__RΦ$D.m("rt:i", [() => undefined])(QueueWithEventEmitter$2);
	__RΦ$D.m("rt:f", "Ce")(QueueWithEventEmitter$2);
	__RΦ$D.m("rt:t", () => __RΦ$D.a(4))(QueueWithEventEmitter$2.prototype, "eventEmitter");
	__RΦ$D.m("rt:f", "P#")(QueueWithEventEmitter$2.prototype, "eventEmitter");
	__RΦ$D.m("rt:f", "M$")(QueueWithEventEmitter$2.prototype["enqueue"]);
	((t, p) => __RΦ$D.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$2.prototype, "enqueue");
	__RΦ$D.m("rt:p", [{ n: "items", t: () => __RΦ$D.a(712), v: null }])(QueueWithEventEmitter$2.prototype, "enqueue");
	__RΦ$D.m("rt:f", "M$")(QueueWithEventEmitter$2.prototype, "enqueue");
	__RΦ$D.m("rt:t", () => __RΦ$D.a(23))(QueueWithEventEmitter$2.prototype, "enqueue");
	__RΦ$D.m("rt:f", "M$")(QueueWithEventEmitter$2.prototype["dequeue"]);
	((t, p) => __RΦ$D.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$2.prototype, "dequeue");
	__RΦ$D.m("rt:p", [])(QueueWithEventEmitter$2.prototype, "dequeue");
	__RΦ$D.m("rt:f", "M$")(QueueWithEventEmitter$2.prototype, "dequeue");
	__RΦ$D.m("rt:t", () => __RΦ$D.a(729))(QueueWithEventEmitter$2.prototype, "dequeue");
	__RΦ$D.m("rt:f", "M$")(QueueWithEventEmitter$2.prototype["on"]);
	((t, p) => __RΦ$D.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$2.prototype, "on");
	__RΦ$D.m("rt:p", [{ n: "eventName", t: () => __RΦ$D.a(249), v: null }, { n: "listener", t: () => __RΦ$D.a(733), v: null }])(QueueWithEventEmitter$2.prototype, "on");
	__RΦ$D.m("rt:f", "M$")(QueueWithEventEmitter$2.prototype, "on");
	__RΦ$D.m("rt:t", () => __RΦ$D.a(705))(QueueWithEventEmitter$2.prototype, "on");

	dist$3.Angle = Angle$2;
	dist$3.Convert = Convert$2;
	dist$3.GameLoop = GameLoop$2;
	dist$3.KeyUpDownProcessor = KeyUpDownProcessor$2;
	dist$3.Lazy = Lazy$2;
	dist$3.Queue = Queue$2;
	dist$3.QueueLog = QueueLog$2;
	dist$3.QueueWithEventEmitter = QueueWithEventEmitter$2;
	dist$3.Shortcut = Shortcut$2;
	dist$3.ShortcutDispatcher = ShortcutDispatcher$2;
	dist$3.Timer = Timer$2;
	dist$3.Transform = Transform;
	var Vector_1 = dist$3.Vector = Vector$2;
	dist$3.execActionScript = execActionScript$2;
	dist$3.execFunctionScript = execFunctionScript$2;
	dist$3.isBrowser = isBrowser$2;
	dist$3.isStoppable = isStoppable$2;
	dist$3.onKeyDown = onKeyDown$2;
	dist$3.onKeyUp = onKeyUp$2;
	dist$3.toOneLine = toOneLine$2;
	dist$3.useRequestAnimationFrame = useRequestAnimationFrame;

	const __RΦ$C = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$C.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$C.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$C.t[id] = t = l;
	        }
	        return t;
	    }, t: { [2390]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$C.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [2389]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$C.a(2388) }, { t: __RΦ$C.a(127) }] }) }, [2388]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [127]: { LΦ: t => dist$3["IΦdefault"] } } };
	/**
	 * Вычисление размером игрового поля.
	 * @param onResize
	 */
	function useResizeCanvas(onResize) {
	    const [size, setSize] = react$1.exports.useState({ width: 0, height: 0 });
	    // Здесь ref выдается на HTMLDivElement, то есть SVGSVGElement не поддерживается.
	    // Заявка на исправление этого недоразумения подана и принята автором:
	    // https://github.com/ZeeCoder/use-resize-observer/issues/91
	    const { ref } = useResizeObserver({
	        onResize({ width = 0, height = 0 }) {
	            setSize({ width, height });
	            if (onResize) {
	                onResize({ width, height });
	            }
	        }
	    });
	    return [ref, size];
	}
	__RΦ$C.m("rt:p", [{ n: "onResize", t: () => __RΦ$C.a(2390), v: null, f: "?" }])(useResizeCanvas);
	__RΦ$C.m("rt:f", "F")(useResizeCanvas);
	__RΦ$C.m("rt:t", () => __RΦ$C.a(2389))(useResizeCanvas);

	var css_248z$4 = "div.Canvas-module_Wrap__OnTb6 {\n  width: 100%;\n  height: 100%; }\n  div.Canvas-module_Wrap__OnTb6 svg.Canvas-module_Canvas__wnheN {\n    display: block;\n    width: 100%;\n    height: 100%; }\n    div.Canvas-module_Wrap__OnTb6 svg.Canvas-module_Canvas__wnheN * {\n      vector-effect: non-scaling-stroke; }\n";
	var styles$3 = {"Wrap":"Canvas-module_Wrap__OnTb6","Canvas":"Canvas-module_Canvas__wnheN"};
	styleInject(css_248z$4);

	const __RΦ$B = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$B.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$B.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$B.t[id] = t = l;
	        }
	        return t;
	    }, t: { [2390]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$B.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [604]: { LΦ: t => Vector$5 }, [2396]: { RΦ: t => ({ TΦ: "&", t: [__RΦ$B.a(2395), __RΦ$B.a(2393)] }) }, [2395]: { TΦ: "5", name: "ICanvasProps" }, [2393]: { RΦ: t => ({ TΦ: "O", m: [{ n: "children", f: "?", t: __RΦ$B.a(2105) }] }) }, [2105]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$B.a(10), __RΦ$B.a(13), __RΦ$B.a(14), __RΦ$B.a(15), __RΦ$B.a(18), __RΦ$B.a(20), __RΦ$B.a(2101), __RΦ$B.a(2102), __RΦ$B.a(2103)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [13]: { RΦ: t => ({ TΦ: "n" }) }, [14]: { LΦ: t => String }, [15]: { LΦ: t => Number }, [18]: { RΦ: t => ({ TΦ: "0" }) }, [20]: { RΦ: t => ({ TΦ: "1" }) }, [2101]: { RΦ: t => ({ TΦ: "g", t: __RΦ$B.a(175), p: [__RΦ$B.a(1), __RΦ$B.a(2043)] }) }, [175]: { LΦ: t => LΦ_1__namespace.IΦReactElement }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [2043]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$B.a(14), __RΦ$B.a(1650), __RΦ$B.a(1651)] }) }, [1650]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$B.a(4) }] }) }, [1651]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__new", f: "", t: __RΦ$B.a(4) }] }) }, [2102]: { RΦ: t => ({ TΦ: "g", t: __RΦ$B.a(432), p: [__RΦ$B.a(2105)] }) }, [432]: { LΦ: t => Object }, [2103]: { LΦ: t => LΦ_1__namespace.IΦReactPortal }, [174]: { LΦ: t => LΦ_1__namespace.IΦElement } } };
	const CanvasSizeContext = react$1.exports.createContext({ width: 0, height: 0 });
	// const data = 'M 10 10 L 100 100'
	// <path d={data} transform='rotate(0)'/>
	const svgProps = {
	    version: '1.1',
	    xmlns: 'http://www.w3.org/2000/svg',
	    className: styles$3.Canvas
	};
	var IΦICanvasProps = { name: "ICanvasProps", prototype: {}, identity: Symbol("ICanvasProps (interface)") };
	(t => __RΦ$B.t[2395] = t)(IΦICanvasProps);
	__RΦ$B.m("rt:P", ["onResize", "offset", "scale"])(IΦICanvasProps);
	__RΦ$B.m("rt:m", [])(IΦICanvasProps);
	__RΦ$B.m("rt:f", "Ie")(IΦICanvasProps);
	__RΦ$B.m("rt:t", () => __RΦ$B.a(2390))(IΦICanvasProps.prototype, "onResize");
	__RΦ$B.m("rt:f", "P?")(IΦICanvasProps.prototype, "onResize");
	__RΦ$B.m("rt:t", () => __RΦ$B.a(604))(IΦICanvasProps.prototype, "offset");
	__RΦ$B.m("rt:f", "P?")(IΦICanvasProps.prototype, "offset");
	__RΦ$B.m("rt:t", () => __RΦ$B.a(604))(IΦICanvasProps.prototype, "scale");
	__RΦ$B.m("rt:f", "P?")(IΦICanvasProps.prototype, "scale");
	__RΦ$B.m("rt:t", () => __RΦ$B.a(2390))(IΦICanvasProps.prototype, "onResize");
	__RΦ$B.m("rt:f", "P?")(IΦICanvasProps.prototype, "onResize");
	__RΦ$B.m("rt:t", () => __RΦ$B.a(604))(IΦICanvasProps.prototype, "offset");
	__RΦ$B.m("rt:f", "P?")(IΦICanvasProps.prototype, "offset");
	__RΦ$B.m("rt:t", () => __RΦ$B.a(604))(IΦICanvasProps.prototype, "scale");
	__RΦ$B.m("rt:f", "P?")(IΦICanvasProps.prototype, "scale");
	/**
	 * Пока просто выводим кружочек, обозначающий местоположение корабля.
	 */
	function Canvas({ children, onResize, offset = new Vector$5, scale = new Vector$5(1, 1) }) {
	    const [ref, size] = useResizeCanvas(onResize);
	    const transform = (new Transform$2()
	        // Начало координат ставим в центр экрана.
	        .translate(new Vector$5(size.width / 2, size.height / 2))
	        // Масштабирование камеры.
	        .scale(scale)
	        // Смещение камеры.
	        .translate(offset));
	    return (jsxRuntime.exports.jsx("div", { ref: ref, className: styles$3.Wrap, children: jsxRuntime.exports.jsx(CanvasSizeContext.Provider, { value: size, children: jsxRuntime.exports.jsx("svg", { ...svgProps, children: jsxRuntime.exports.jsx("g", { transform: transform.toString(), children: children }) }) }) }));
	}
	__RΦ$B.m("rt:p", [{ n: "{children, onResize, offset = new Vector, scale = new Vector(1, 1)}", t: () => __RΦ$B.a(2396), v: null }])(Canvas);
	__RΦ$B.m("rt:f", "F")(Canvas);
	__RΦ$B.m("rt:t", () => __RΦ$B.a(174))(Canvas);

	var css_248z$3 = "@charset \"UTF-8\";\n/**\n * Выравнивание по центру.\n * @link https://habr.com/ru/post/189696/\n */\n.Params-module_Params__l9WE3 {\n  position: absolute;\n  margin: auto;\n  width: fit-content;\n  left: 0;\n  bottom: 20px;\n  right: 0;\n  padding: 10px;\n  background-color: rgba(255, 255, 255, 0.9);\n  box-shadow: 4px 4px 29px -2px #e3e3e3;\n  border-radius: 5px; }\n  .Params-module_Params__l9WE3 table td {\n    white-space: nowrap;\n    padding: 5px; }\n";
	var styles$2 = {"Params":"Params-module_Params__l9WE3"};
	styleInject(css_248z$3);

	const __RΦ$A = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$A.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$A.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$A.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [87]: { LΦ: t => undefined }, [2237]: { RΦ: t => ({ TΦ: "[", e: __RΦ$A.a(2236) }) }, [2236]: { TΦ: "5", name: "IParam" }, [2229]: { TΦ: "5", name: "IParamsProps" }, [2173]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$A.a(13), __RΦ$A.a(174)] }) }, [13]: { RΦ: t => ({ TΦ: "n" }) }, [174]: { LΦ: t => LΦ_1__namespace.IΦElement }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [601]: { LΦ: t => undefined } } };
	var IΦIParam = { name: "IParam", prototype: {}, identity: Symbol("IParam (interface)") };
	(t => __RΦ$A.t[2236] = t)(IΦIParam);
	__RΦ$A.m("rt:P", ["title", "value", "unit", "color", "valueAlt"])(IΦIParam);
	__RΦ$A.m("rt:m", [])(IΦIParam);
	__RΦ$A.m("rt:f", "I")(IΦIParam);
	__RΦ$A.m("rt:t", () => __RΦ$A.a(14))(IΦIParam.prototype, "title");
	__RΦ$A.m("rt:f", "P")(IΦIParam.prototype, "title");
	__RΦ$A.m("rt:t", () => __RΦ$A.a(14))(IΦIParam.prototype, "value");
	__RΦ$A.m("rt:f", "P")(IΦIParam.prototype, "value");
	__RΦ$A.m("rt:t", () => __RΦ$A.a(14))(IΦIParam.prototype, "unit");
	__RΦ$A.m("rt:f", "P")(IΦIParam.prototype, "unit");
	__RΦ$A.m("rt:t", () => __RΦ$A.a(14))(IΦIParam.prototype, "color");
	__RΦ$A.m("rt:f", "P?")(IΦIParam.prototype, "color");
	__RΦ$A.m("rt:t", () => __RΦ$A.a(14))(IΦIParam.prototype, "valueAlt");
	__RΦ$A.m("rt:f", "P?")(IΦIParam.prototype, "valueAlt");
	__RΦ$A.m("rt:t", () => __RΦ$A.a(14))(IΦIParam.prototype, "title");
	__RΦ$A.m("rt:f", "P")(IΦIParam.prototype, "title");
	__RΦ$A.m("rt:t", () => __RΦ$A.a(14))(IΦIParam.prototype, "value");
	__RΦ$A.m("rt:f", "P")(IΦIParam.prototype, "value");
	__RΦ$A.m("rt:t", () => __RΦ$A.a(14))(IΦIParam.prototype, "unit");
	__RΦ$A.m("rt:f", "P")(IΦIParam.prototype, "unit");
	__RΦ$A.m("rt:t", () => __RΦ$A.a(14))(IΦIParam.prototype, "color");
	__RΦ$A.m("rt:f", "P?")(IΦIParam.prototype, "color");
	__RΦ$A.m("rt:t", () => __RΦ$A.a(14))(IΦIParam.prototype, "valueAlt");
	__RΦ$A.m("rt:f", "P?")(IΦIParam.prototype, "valueAlt");
	var IΦIParamsProps = { name: "IParamsProps", prototype: {}, identity: Symbol("IParamsProps (interface)") };
	(t => __RΦ$A.t[2229] = t)(IΦIParamsProps);
	__RΦ$A.m("rt:P", ["object", "additionalParameters"])(IΦIParamsProps);
	__RΦ$A.m("rt:m", [])(IΦIParamsProps);
	__RΦ$A.m("rt:f", "I")(IΦIParamsProps);
	__RΦ$A.m("rt:t", () => __RΦ$A.a(87))(IΦIParamsProps.prototype, "object");
	__RΦ$A.m("rt:f", "P")(IΦIParamsProps.prototype, "object");
	__RΦ$A.m("rt:t", () => __RΦ$A.a(2237))(IΦIParamsProps.prototype, "additionalParameters");
	__RΦ$A.m("rt:f", "P?")(IΦIParamsProps.prototype, "additionalParameters");
	__RΦ$A.m("rt:t", () => __RΦ$A.a(87))(IΦIParamsProps.prototype, "object");
	__RΦ$A.m("rt:f", "P")(IΦIParamsProps.prototype, "object");
	__RΦ$A.m("rt:t", () => __RΦ$A.a(2237))(IΦIParamsProps.prototype, "additionalParameters");
	__RΦ$A.m("rt:f", "P?")(IΦIParamsProps.prototype, "additionalParameters");
	function Params({ object, additionalParameters = [] }) {
	    const gameObject = new GameObjectAdapter(object);
	    if (gameObject.kind.includes('IMovable')) {
	        const movable = new MovableAdapter(object);
	        const params = [...getMovableParams(movable), ...additionalParameters];
	        return (jsxRuntime.exports.jsx("div", { className: styles$2.Params, children: jsxRuntime.exports.jsx("table", { children: params.map(__RΦ$A.f(param => (jsxRuntime.exports.jsxs("tr", { style: { color: param.color }, children: [jsxRuntime.exports.jsxs("td", { children: [param.title, ":"] }), jsxRuntime.exports.jsx("td", { children: param.value }), jsxRuntime.exports.jsx("td", { children: param.valueAlt }), jsxRuntime.exports.jsx("td", { children: param.unit })] })), [__RΦ$A.m("rt:p", [{ n: "param", t: () => __RΦ$A.a(4), v: null }]), __RΦ$A.m("rt:f", "F>"), __RΦ$A.m("rt:t", () => __RΦ$A.a(174))], "")) }) }));
	    }
	    return null;
	}
	__RΦ$A.m("rt:p", [{ n: "{object, additionalParameters = []}", t: () => __RΦ$A.a(2229), v: null }])(Params);
	__RΦ$A.m("rt:f", "F")(Params);
	__RΦ$A.m("rt:t", () => __RΦ$A.a(2173))(Params);
	function getMovableParams(movable) {
	    return [{
	            title: 'Координаты',
	            value: movable.position.toString(),
	            unit: 'Метры'
	        }, {
	            title: 'Скорость',
	            value: movable.linearVelocity.toString(),
	            valueAlt: movable.linearVelocity.length.toFixed(2),
	            unit: 'Метры в секунду',
	            color: 'blue'
	        }, {
	            title: 'Ускорение',
	            value: movable.linearAcceleration.toString(),
	            valueAlt: movable.linearAcceleration.length.toFixed(2),
	            unit: 'Метры в секунду в квадрате'
	        }, {
	            title: 'Сила',
	            value: `${movable.appliedForce.length.toFixed(2)} / ${Angle$5.toDegree(movable.appliedForce.angle).toFixed(2)}`,
	            unit: 'Ньютон / Градус',
	            color: 'red'
	        }];
	}
	__RΦ$A.m("rt:p", [{ n: "movable", t: () => __RΦ$A.a(601), v: null }])(getMovableParams);
	__RΦ$A.m("rt:f", "F")(getMovableParams);
	__RΦ$A.m("rt:t", () => __RΦ$A.a(2237))(getMovableParams);

	var css_248z$2 = ".Star-module_Star__8eyQn {\n  stroke: #ff0000;\n  fill: transparent; }\n";
	var styles$1 = {"Star":"Star-module_Star__8eyQn"};
	styleInject(css_248z$2);

	const __RΦ$z = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$z.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$z.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$z.t[id] = t = l;
	        }
	        return t;
	    }, t: { [87]: { LΦ: t => undefined }, [2222]: { TΦ: "5", name: "IStarProps" }, [174]: { LΦ: t => LΦ_1__namespace.IΦElement } } };
	var IΦIStarProps = { name: "IStarProps", prototype: {}, identity: Symbol("IStarProps (interface)") };
	(t => __RΦ$z.t[2222] = t)(IΦIStarProps);
	__RΦ$z.m("rt:P", ["object"])(IΦIStarProps);
	__RΦ$z.m("rt:m", [])(IΦIStarProps);
	__RΦ$z.m("rt:f", "I")(IΦIStarProps);
	__RΦ$z.m("rt:t", () => __RΦ$z.a(87))(IΦIStarProps.prototype, "object");
	__RΦ$z.m("rt:f", "P")(IΦIStarProps.prototype, "object");
	__RΦ$z.m("rt:t", () => __RΦ$z.a(87))(IΦIStarProps.prototype, "object");
	__RΦ$z.m("rt:f", "P")(IΦIStarProps.prototype, "object");
	const radius = 1;
	function Star({ object }) {
	    const transformable = new TransformableAdapter(object);
	    const transform = (new Transform$2()
	        .translate(transformable.position)
	        .scale(transformable.scale));
	    return (jsxRuntime.exports.jsx("circle", { className: styles$1.Star, transform: transform.toString(), r: radius, cx: 0, cy: 0 }));
	}
	__RΦ$z.m("rt:p", [{ n: "{object}", t: () => __RΦ$z.a(2222), v: null }])(Star);
	__RΦ$z.m("rt:f", "F")(Star);
	__RΦ$z.m("rt:t", () => __RΦ$z.a(174))(Star);

	var css_248z$1 = ".Application-module_Application__Lxo1s {\n  width: 100%;\n  height: 100%;\n  position: relative; }\n";
	var styles = {"Application":"Application-module_Application__Lxo1s"};
	styleInject(css_248z$1);

	const __RΦ$y = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$y.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$y.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$y.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1204]: { LΦ: t => LΦ_1__namespace.IΦElement }, [1252]: { LΦ: t => Vector$5 }, [21]: { LΦ: t => Boolean }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1213]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$y.a(13), __RΦ$y.a(1204)] }) }, [13]: { RΦ: t => ({ TΦ: "n" }) }, [1216]: { RΦ: t => ({ TΦ: "[", e: __RΦ$y.a(1213) }) } } };
	const renderableMap = {
	    Spaceship,
	    Star
	};
	function Application() {
	    const [fps] = useRequestAnimationFrame$1();
	    const gameObjectList = resolve('GameObjectList');
	    const selectedGameObject = resolve('SelectedGameObject');
	    const selectedGameObjectMovable = new MovableAdapter(selectedGameObject);
	    const theGameWorld = (new ToroidalSurfaceAdapter(resolve('GameObject', {
	        type: 'GameObject',
	        name: 'theGameWorld'
	    })));
	    const additionalParameters = [{
	            title: 'FPS',
	            unit: 'Кадры в секунды',
	            value: fps.toFixed(0)
	        }];
	    const offset = selectedGameObjectMovable.position.inverse; // Камера движется за кораблем.
	    return (jsxRuntime.exports.jsxs("div", { className: styles.Application, children: [jsxRuntime.exports.jsx(Params, { object: selectedGameObject, additionalParameters: additionalParameters }), jsxRuntime.exports.jsx(Canvas, { offset: offset, scale: new Vector$5(2, 2), children: jsxRuntime.exports.jsx(CanvasSizeContext.Consumer, { children: __RΦ$y.f(canvasSize => (gameObjectList.map(__RΦ$y.f(object => {
	                        const gameObject = new GameObjectAdapter(object);
	                        if (gameObject.kind.includes('IRenderable')) {
	                            const renderable = new RenderableAdapter(object);
	                            const RenderComponent = renderableMap[renderable.renderComponent];
	                            if (!RenderComponent) {
	                                throw new Error(`Не найден компонент '${renderable.renderComponent}'`);
	                            }
	                            const movable = new MovableAdapter(object);
	                            const isVisible = __RΦ$y.f((position) => {
	                                // Внимание, в SVG.transform действия производится задом наперед!
	                                position = position
	                                    .translate(offset)
	                                    .scale(new Vector$5(2, 2))
	                                    .translate(new Vector$5(canvasSize.width / 2, canvasSize.height / 2));
	                                return (position.x >= 0 && position.x <= canvasSize.width &&
	                                    position.y >= 0 && position.y <= canvasSize.height);
	                            }, [__RΦ$y.m("rt:p", [{ n: "position", t: () => __RΦ$y.a(1252), v: null }]), __RΦ$y.m("rt:f", "F>"), __RΦ$y.m("rt:t", () => __RΦ$y.a(21))], "isVisible");
	                            return (jsxRuntime.exports.jsx(ToroidalRender, { isVisible: isVisible, position: movable.position, toroidalSurfaceSize: theGameWorld.size, children: jsxRuntime.exports.jsx(RenderComponent, { object: object }) }));
	                        }
	                        return null;
	                    }, [__RΦ$y.m("rt:p", [{ n: "object", t: () => __RΦ$y.a(4), v: null }]), __RΦ$y.m("rt:f", "F>"), __RΦ$y.m("rt:t", () => __RΦ$y.a(1213))], ""))), [__RΦ$y.m("rt:p", [{ n: "canvasSize", t: () => __RΦ$y.a(4), v: null }]), __RΦ$y.m("rt:f", "F>"), __RΦ$y.m("rt:t", () => __RΦ$y.a(1216))], "") }) })] }));
	}
	__RΦ$y.m("rt:p", [])(Application);
	__RΦ$y.m("rt:f", "F")(Application);
	__RΦ$y.m("rt:t", () => __RΦ$y.a(1204))(Application);

	var css_248z = "html {\n  padding: 0;\n  margin: 0;\n  width: 100%;\n  height: 100%; }\n  html body {\n    padding: 0;\n    margin: 0;\n    width: 100%;\n    height: 100%; }\n    html body > div {\n      padding: 0;\n      margin: 0;\n      width: 100%;\n      height: 100%; }\n";
	styleInject(css_248z);

	const F_READONLY = 'R';
	const F_ABSTRACT = 'A';
	const F_PUBLIC = '$';
	const F_PRIVATE = '#';
	const F_PROTECTED = '@';
	const F_PROPERTY = 'P';
	const F_METHOD = 'M';
	const F_CLASS = 'C';
	const F_INTERFACE = 'I';
	const F_FUNCTION = 'F';
	const F_OPTIONAL = '?';
	const F_ASYNC = 'a';
	const F_EXPORTED = 'e';
	const F_INFERRED = '.';
	const T_UNION = '|';
	const T_INTERSECTION = '&';
	const T_ANY = '~';
	const T_UNKNOWN = 'U';
	const T_VOID = 'V';
	const T_UNDEFINED = 'u';
	const T_NULL = 'n';
	const T_TUPLE = 'T';
	const T_ARRAY = '[';
	const T_GENERIC = 'g';
	const T_MAPPED = 'm';
	const T_TRUE = '1';
	const T_FALSE = '0';
	const T_OBJECT = 'O';
	const T_ENUM = 'e';

	/**
	 * Original from https://github.com/goatslacker/get-parameter-names/blob/master/index.js
	 */
	const COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
	const DEFAULT_PARAMS = /=[^,]+/mg;
	const FAT_ARROWS = /=>.*$/mg;
	function getParameterNames(fn) {
	    const code = fn.toString()
	        .replace(COMMENTS, '')
	        .replace(FAT_ARROWS, '')
	        .replace(DEFAULT_PARAMS, '');
	    const result = code.slice(code.indexOf('(') + 1, code.indexOf(')'))
	        .match(/([^\s,]+)/g);
	    return result === null ? [] : result;
	}

	function Sealed() {
	    return (target) => {
	        Object.seal(target);
	        return target;
	    };
	}

	var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (undefined && undefined.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var ReflectedClass_1;
	const NotProvided = Symbol();
	function isCallSite(callSite) {
	    return (callSite === null || callSite === void 0 ? void 0 : callSite.TΦ) === 'c';
	}
	function Flag(value) {
	    return (target, propertyKey) => {
	        if (!target.flagToProperty)
	            target.flagToProperty = {};
	        if (!target.propertyToFlag)
	            target.propertyToFlag = {};
	        target.flagToProperty[value] = propertyKey;
	        target.propertyToFlag[propertyKey] = value;
	    };
	}
	const TYPE_REF_KIND_EXPANSION = {
	    [T_UNKNOWN]: 'unknown',
	    [T_ANY]: 'any',
	    [T_UNION]: 'union',
	    [T_INTERSECTION]: 'intersection',
	    [T_TUPLE]: 'tuple',
	    [T_ARRAY]: 'array',
	    [T_GENERIC]: 'generic',
	    [T_VOID]: 'void',
	    [T_NULL]: 'null',
	    [T_UNDEFINED]: 'undefined',
	    [T_MAPPED]: 'mapped',
	    [T_ENUM]: 'enum',
	    [T_FALSE]: 'false',
	    [T_TRUE]: 'true',
	    [T_OBJECT]: 'object'
	};
	class ReflectedTypeRef {
	    /** @internal */
	    constructor(_ref) {
	        this._ref = _ref;
	    }
	    toString() {
	        return `[${this.kind} type]`;
	    }
	    /** @internal */
	    static Kind(kind) {
	        return (target) => {
	            ReflectedTypeRef.kinds[kind] = target;
	        };
	    }
	    /**
	     * Check if the given value matches this type reference. Collects any errors into the `errors` list.
	     * @param value
	     * @param errors
	     * @param context
	     * @returns
	     */
	    matchesValue(value, errors, context) {
	        errors.push(new Error(`No validation available for type with kind '${this.kind}'`));
	        return false;
	    }
	    /**
	     * Check if the given type reference is equivalent to this type reference.
	     * @param ref
	     * @returns
	     */
	    equals(ref) {
	        if (this === ref)
	            return true;
	        if (ref.constructor !== this.constructor)
	            return false;
	        return this.matches(ref);
	    }
	    matches(ref) {
	        return true;
	    }
	    get kind() {
	        let ref = this._ref;
	        if (ref === null || ['string', 'number'].includes(typeof ref))
	            return 'literal';
	        if (typeof ref === 'object' && 'TΦ' in ref)
	            return TYPE_REF_KIND_EXPANSION[ref.TΦ];
	        if (typeof ref === 'object')
	            return 'interface';
	        return 'class';
	    }
	    /** @internal */
	    get ref() {
	        return this._ref;
	    }
	    /**
	     * Checks if this type reference is a Promise, optionally a Promise of a specific type.
	     * If the type reference does not specify a type of Promise but you have provided a type
	     * to check for, this will return false.
	     * @param klass The type of promise to check for. Would be String when looking for Promise<string>
	     */
	    isPromise(klass) {
	        if (this.isClass(Promise))
	            return !klass;
	        if (this.isGeneric(Promise)) {
	            if (this.typeParameters.length === 0)
	                return !klass;
	            return this.typeParameters[0].isClass(klass);
	        }
	        return false;
	    }
	    /**
	     * Checks if this type reference is a class. Note: If the class reference has type parameters,
	     * (ie it is generic) this check will fail, and instead isGeneric() will succeed.
	     * @param klass
	     */
	    isClass(klass) {
	        let literalTypes = {
	            'string': String,
	            'number': Number,
	            'boolean': Boolean,
	            'object': Object
	        };
	        if (this.kind === 'literal')
	            return literalTypes[typeof this.ref] === klass;
	        if (this.kind === 'null')
	            return Object === klass;
	        if (['true', 'false'].includes(this.kind))
	            return Boolean === klass;
	        return this.kind === 'class' && (!klass || this.ref === klass);
	    }
	    isInterface(interfaceType) {
	        if (interfaceType)
	            return this.isInterface() && this.ref.identity === interfaceType.identity;
	        else
	            return this.kind === 'interface';
	    }
	    isLiteral(value = NotProvided) {
	        if (value === null)
	            return this.isNull();
	        if (value === true)
	            return this.isTrue();
	        if (value === false)
	            return this.isFalse();
	        return this.kind === 'literal' && (value === NotProvided || this.ref === value);
	    }
	    is(kind) {
	        if (typeof kind === 'function')
	            return this instanceof kind;
	        else if (typeof kind === 'string')
	            return this.kind === kind;
	    }
	    as(subclass) {
	        if (typeof subclass === 'function' && !(this instanceof subclass))
	            throw new TypeError(`Value of type ${this.constructor.name} cannot be converted to ${subclass.name}`);
	        else if (typeof subclass === 'string' && this.kind !== subclass)
	            throw new TypeError(`Type has kind ${this.kind}, expected ${subclass}`);
	        return this;
	    }
	    isVoid() { return this.kind === 'void'; }
	    isNull() { return this.kind === 'null'; }
	    isUndefined() { return this.kind === 'undefined'; }
	    isTrue() { return this.kind === 'true'; }
	    isFalse() { return this.kind === 'false'; }
	    isStringLiteral() { return this.kind === 'literal' && typeof this.ref === 'string'; }
	    isNumberLiteral() { return this.kind === 'literal' && typeof this.ref === 'number'; }
	    isBooleanLiteral() { return this.isTrue() || this.isFalse(); }
	    /**
	     * Check if this type reference is a generic type, optionally checking if the generic's
	     * base type is the given class. For instance isGeneric(Promise) is true for Promise<string>.
	     * @param klass
	     */
	    isGeneric(klass) {
	        if (this.kind === 'generic') {
	            let rtGeneric = this.ref;
	            if (!rtGeneric.t['TΦ']) { // this is a class
	                return !klass || rtGeneric.t === klass;
	            }
	            return true;
	        }
	        return false;
	    }
	    isUnion(elementDiscriminator) {
	        return elementDiscriminator
	            ? this.isUnion() && this.types.every(e => elementDiscriminator(e))
	            : this.kind === 'union';
	    }
	    isIntersection(elementDiscriminator) {
	        return elementDiscriminator
	            ? this.isIntersection() && this.types.every(e => elementDiscriminator(e))
	            : this.kind === 'intersection';
	    }
	    isArray(elementDiscriminator) {
	        return elementDiscriminator
	            ? this.isArray() && elementDiscriminator(this.elementType)
	            : this.kind === 'array';
	    }
	    isTuple(elementDiscriminators) {
	        return elementDiscriminators
	            ? this.isTuple() && this.elements.every((e, i) => elementDiscriminators[i](e))
	            : this.kind === 'tuple';
	    }
	    isUnknown() {
	        return this.kind === 'unknown';
	    }
	    isAny() {
	        return this.kind === 'any';
	    }
	    /**
	     * Creates an "unknown"
	     * @internal
	     */
	    static createUnknown() {
	        return this.createFromRtRef({ TΦ: T_UNKNOWN });
	    }
	    /** @internal */
	    static createFromRtRef(ref) {
	        let kind;
	        if (ref === null || !['object', 'function'].includes(typeof ref))
	            kind = 'literal';
	        else if (typeof ref === 'object' && 'TΦ' in ref)
	            kind = TYPE_REF_KIND_EXPANSION[ref.TΦ];
	        else if (typeof ref === 'object')
	            kind = 'interface';
	        else
	            kind = 'class';
	        return new (ReflectedTypeRef.kinds[kind] || ReflectedTypeRef)(ref);
	    }
	}
	ReflectedTypeRef.kinds = {};
	let ReflectedClassRef = class ReflectedClassRef extends ReflectedTypeRef {
	    get kind() { return 'class'; }
	    get class() { return this.ref; }
	    get reflectedClass() { return ReflectedClass.for(this.class); }
	    toString() { return `class ${this.class.name}`; }
	    matches(ref) {
	        return this.class === ref.class;
	    }
	    matchesValue(value, errors = [], context) {
	        if (this.ref === String)
	            return typeof value === 'string';
	        else if (this.ref === Number)
	            return typeof value === 'number';
	        else if (this.ref === Boolean)
	            return typeof value === 'boolean';
	        else if (this.ref === Object)
	            return typeof value === 'object';
	        else if (this.ref === Function)
	            return typeof value === 'function';
	        else if (this.ref === Symbol)
	            return typeof value === 'symbol';
	        return ReflectedClass.for(this.ref).matchesValue(value);
	    }
	};
	ReflectedClassRef = __decorate([
	    ReflectedTypeRef.Kind('class')
	], ReflectedClassRef);
	class ReflectedObjectMember {
	    constructor(ref) {
	        this.ref = ref;
	        this.name = ref.n;
	        this.type = ReflectedTypeRef.createFromRtRef(this.ref.t);
	    }
	    get flags() {
	        if (!this._flags)
	            this._flags = new ReflectedFlags(this.ref.f);
	        return this._flags;
	    }
	    get isOptional() { return this.flags.isOptional; }
	    equals(member) {
	        return this.name === member.name && this.type.equals(member.type);
	    }
	    toString() { var _a, _b; return `${this.name}: ${(_b = (_a = this.type) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '<error>'}`; }
	}
	let ReflectedObjectRef = class ReflectedObjectRef extends ReflectedTypeRef {
	    get kind() { return 'object'; }
	    get members() {
	        if (!this._members)
	            this._members = this.ref.m.map(m => new ReflectedObjectMember(m));
	        return this._members;
	    }
	    toString() { return `{ ${this.members.map(m => m.toString()).join(', ')} }`; }
	    matches(ref) {
	        if (this.members.length !== ref.members.length)
	            return false;
	        for (let member of this.members) {
	            let matchingMember = ref.members.find(x => x.name);
	            if (!member.equals(matchingMember))
	                return false;
	        }
	        return true;
	    }
	    matchesValue(value, errors = [], context) {
	        if (typeof value !== 'object')
	            return false;
	        let matches = true;
	        for (let member of this.members) {
	            let hasValue = member.name in value;
	            if (!hasValue) {
	                if (!member.isOptional) {
	                    errors.push(new TypeError(`Missing value for member ${member.toString()}`));
	                    matches = false;
	                }
	                continue;
	            }
	            let memberValue = value[member.name];
	            let memberErrors = [];
	            if (!member.type.matchesValue(memberValue, memberErrors, context)) {
	                errors.push(new TypeError(`Value for member ${member.toString()} is invalid`));
	                errors.push(...memberErrors);
	                matches = false;
	            }
	        }
	        return matches;
	    }
	};
	ReflectedObjectRef = __decorate([
	    ReflectedTypeRef.Kind('object')
	], ReflectedObjectRef);
	let ReflectedInterfaceRef = class ReflectedInterfaceRef extends ReflectedTypeRef {
	    get kind() { return 'interface'; }
	    get token() { return this.ref; }
	    get reflectedInterface() { return ReflectedClass.for(this.token); }
	    toString() { return `interface ${this.token.name}`; }
	    matches(ref) {
	        return this.token === ref.token;
	    }
	    matchesValue(value, errors = [], context) {
	        return ReflectedClass.for(this.ref).matchesValue(value);
	    }
	};
	ReflectedInterfaceRef = __decorate([
	    ReflectedTypeRef.Kind('interface')
	], ReflectedInterfaceRef);
	let ReflectedLiteralRef = class ReflectedLiteralRef extends ReflectedTypeRef {
	    get kind() { return 'literal'; }
	    get value() { return this.ref; }
	    toString() { return JSON.stringify(this.value); }
	    matches(ref) {
	        return this.value === ref.value;
	    }
	    matchesValue(value, errors, context) {
	        return this.ref === value;
	    }
	};
	ReflectedLiteralRef = __decorate([
	    ReflectedTypeRef.Kind('literal')
	], ReflectedLiteralRef);
	let ReflectedUnionRef = class ReflectedUnionRef extends ReflectedTypeRef {
	    get kind() { return 'union'; }
	    toString() { return `[${this.types.join(' | ')}]`; }
	    get types() {
	        if (this._types)
	            return this._types;
	        return this._types = (this.ref.t || []).map(t => ReflectedTypeRef.createFromRtRef(t));
	    }
	    matches(ref) {
	        if (this.types.length !== ref.types.length)
	            return false;
	        for (let type of this.types) {
	            if (!ref.types.some(x => type.equals(x)))
	                return false;
	        }
	        return true;
	    }
	    matchesValue(value, errors = [], context) {
	        return this.types.some(t => t.matchesValue(value, errors, context));
	    }
	};
	ReflectedUnionRef = __decorate([
	    ReflectedTypeRef.Kind('union')
	], ReflectedUnionRef);
	let ReflectedIntersectionRef = class ReflectedIntersectionRef extends ReflectedTypeRef {
	    get kind() { return 'intersection'; }
	    toString() { return `${this.types.join(' & ')}`; }
	    get types() {
	        if (this._types)
	            return this._types;
	        return this._types = (this.ref.t || []).map(t => ReflectedTypeRef.createFromRtRef(t));
	    }
	    matches(ref) {
	        if (this.types.length !== ref.types.length)
	            return false;
	        for (let type of this.types) {
	            if (!ref.types.some(x => type.equals(x)))
	                return false;
	        }
	        return true;
	    }
	    matchesValue(value, errors = [], context) {
	        return this.types.every(t => t.matchesValue(value, errors, context));
	    }
	};
	ReflectedIntersectionRef = __decorate([
	    ReflectedTypeRef.Kind('intersection')
	], ReflectedIntersectionRef);
	let ReflectedArrayRef = class ReflectedArrayRef extends ReflectedTypeRef {
	    get kind() { return 'array'; }
	    toString() { return `${this.elementType}[]`; }
	    get elementType() {
	        if (this._elementType)
	            return this._elementType;
	        return this._elementType = ReflectedTypeRef.createFromRtRef(this.ref.e);
	    }
	    matches(ref) {
	        return this.elementType.equals(ref.elementType);
	    }
	    matchesValue(value, errors, context) {
	        if (!Array.isArray(value)) {
	            errors.push(new TypeError(`Value should be an array`));
	            return false;
	        }
	        return value.every(value => this.elementType.matchesValue(value, errors, context));
	    }
	};
	ReflectedArrayRef = __decorate([
	    ReflectedTypeRef.Kind('array')
	], ReflectedArrayRef);
	let ReflectedVoidRef = class ReflectedVoidRef extends ReflectedTypeRef {
	    get kind() { return 'void'; }
	    toString() { return `void`; }
	    matchesValue(value, errors, context) {
	        if (value !== void 0) {
	            errors.push(new Error(`Value must not be present`));
	            return false;
	        }
	        return true;
	    }
	};
	ReflectedVoidRef = __decorate([
	    ReflectedTypeRef.Kind('void')
	], ReflectedVoidRef);
	let ReflectedNullRef = class ReflectedNullRef extends ReflectedTypeRef {
	    get kind() { return 'null'; }
	    toString() { return `null`; }
	    matchesValue(value, errors, context) {
	        return value === null;
	    }
	};
	ReflectedNullRef = __decorate([
	    ReflectedTypeRef.Kind('null')
	], ReflectedNullRef);
	let ReflectedUndefinedRef = class ReflectedUndefinedRef extends ReflectedTypeRef {
	    get kind() { return 'undefined'; }
	    toString() { return `undefined`; }
	    matchesValue(value, errors, context) {
	        return value === undefined;
	    }
	};
	ReflectedUndefinedRef = __decorate([
	    ReflectedTypeRef.Kind('undefined')
	], ReflectedUndefinedRef);
	let ReflectedFalseRef = class ReflectedFalseRef extends ReflectedTypeRef {
	    get kind() { return 'false'; }
	    toString() { return `false`; }
	    matchesValue(value, errors, context) {
	        return value === false;
	    }
	};
	ReflectedFalseRef = __decorate([
	    ReflectedTypeRef.Kind('false')
	], ReflectedFalseRef);
	let ReflectedTrueRef = class ReflectedTrueRef extends ReflectedTypeRef {
	    get kind() { return 'true'; }
	    toString() { return `true`; }
	    matchesValue(value, errors, context) {
	        return value === true;
	    }
	};
	ReflectedTrueRef = __decorate([
	    ReflectedTypeRef.Kind('true')
	], ReflectedTrueRef);
	let ReflectedUnknownRef = class ReflectedUnknownRef extends ReflectedTypeRef {
	    get kind() { return 'unknown'; }
	    toString() { return `unknown`; }
	    matchesValue(value, errors, context) {
	        return true;
	    }
	};
	ReflectedUnknownRef = __decorate([
	    ReflectedTypeRef.Kind('unknown')
	], ReflectedUnknownRef);
	let ReflectedAnyRef = class ReflectedAnyRef extends ReflectedTypeRef {
	    get kind() { return 'any'; }
	    toString() { return `any`; }
	    matchesValue(value, errors, context) {
	        return true;
	    }
	};
	ReflectedAnyRef = __decorate([
	    ReflectedTypeRef.Kind('any')
	], ReflectedAnyRef);
	let ReflectedTupleRef = class ReflectedTupleRef extends ReflectedTypeRef {
	    get kind() { return 'tuple'; }
	    toString() { return `[${this.elements.join(', ')}]`; }
	    get elements() {
	        if (this._elements)
	            return this._elements;
	        return this._elements = (this.ref.e || []).map(e => new ReflectedTupleElement(e));
	    }
	    matches(ref) {
	        if (this.elements.length !== ref.elements.length)
	            return false;
	        return this.elements.every((x, i) => x.name === ref.elements[i].name && x.type.equals(ref.elements[i].type));
	    }
	    matchesValue(value, errors, context) {
	        if (!Array.isArray(value)) {
	            errors.push(new Error(`Value must be an array`));
	            return false;
	        }
	        let array = value;
	        if (array.length !== this.elements.length) {
	            errors.push(new Error(`Array must have ${this.elements.length} values to match tuple type`));
	            return false;
	        }
	        return this.elements.every((v, i) => v.type.matchesValue(array[i], errors, context));
	    }
	};
	ReflectedTupleRef = __decorate([
	    ReflectedTypeRef.Kind('tuple')
	], ReflectedTupleRef);
	let ReflectedGenericRef = class ReflectedGenericRef extends ReflectedTypeRef {
	    get kind() { return 'generic'; }
	    toString() { return `${this.baseType}<${this.typeParameters.join(', ')}>`; }
	    get baseType() {
	        if (this._baseType)
	            return this._baseType;
	        return this._baseType = ReflectedTypeRef.createFromRtRef(this.ref.t);
	    }
	    get typeParameters() {
	        if (this._typeParameters)
	            return this._typeParameters;
	        return this._typeParameters = this.ref.p.map(p => ReflectedTypeRef.createFromRtRef(p));
	    }
	    matches(ref) {
	        if (this.typeParameters.length !== ref.typeParameters.length)
	            return false;
	        return this.typeParameters.every((x, i) => x.equals(ref.typeParameters[i]));
	    }
	    matchesValue(value, errors, context) {
	        return this.baseType.matchesValue(value, errors, context);
	    }
	};
	ReflectedGenericRef = __decorate([
	    ReflectedTypeRef.Kind('generic')
	], ReflectedGenericRef);
	let ReflectedEnumRef = class ReflectedEnumRef extends ReflectedTypeRef {
	    get kind() { return 'enum'; }
	    toString() { return `enum`; } // TODO: name of enum?
	    get enum() {
	        if (!this._enum)
	            this._enum = this.ref.e;
	        return this._enum;
	    }
	    get values() {
	        if (!this._values) {
	            this._values = Object.keys(this.enum)
	                .filter(x => !/^\d+$/.test(x))
	                .map(name => ({ name, value: this.enum[name] }));
	        }
	        return this._values;
	    }
	    matches(ref) {
	        return this.enum === ref.enum;
	    }
	    matchesValue(value, errors, context) {
	        return value in this.enum;
	    }
	};
	ReflectedEnumRef = __decorate([
	    ReflectedTypeRef.Kind('enum')
	], ReflectedEnumRef);
	let ReflectedMappedRef = class ReflectedMappedRef extends ReflectedTypeRef {
	    get kind() { return 'mapped'; }
	    toString() { return `${this.baseType}<${this.typeParameters.join(', ')}>`; }
	    get baseType() {
	        if (this._baseType)
	            return this._baseType;
	        return this._baseType = ReflectedTypeRef.createFromRtRef(this.ref.t);
	    }
	    get typeParameters() {
	        if (this._typeParameters)
	            return this._typeParameters;
	        return this._typeParameters = this.ref.p.map(p => ReflectedTypeRef.createFromRtRef(p));
	    }
	    matches(ref) {
	        if (this.typeParameters.length !== ref.typeParameters.length)
	            return false;
	        return this.typeParameters.every((x, i) => x.equals(ref.typeParameters[i]));
	    }
	    matchesValue(value, errors, context) {
	        return this.baseType.matchesValue(value, errors, context);
	    }
	};
	ReflectedMappedRef = __decorate([
	    ReflectedTypeRef.Kind('mapped')
	], ReflectedMappedRef);
	class ReflectedTupleElement {
	    constructor(ref) {
	        this.ref = ref;
	    }
	    toString() {
	        return `${this.name} : ${this.type}`;
	    }
	    get name() {
	        return this.ref.n;
	    }
	    get type() {
	        if (this._type)
	            return this._type;
	        return this._type = ReflectedTypeRef.createFromRtRef(this.ref.t);
	    }
	}
	class ReflectedFlags {
	    constructor(flags) {
	        if (!flags)
	            flags = '';
	        Object.keys(this.flagToProperty)
	            .forEach(flag => this[this.flagToProperty[flag]] = flags.includes(flag));
	    }
	    toString() {
	        return Object.keys(this.propertyToFlag)
	            .map(property => this[property] ? this.propertyToFlag[property] : '')
	            .join('');
	    }
	}
	__decorate([
	    Flag(F_READONLY),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isReadonly", void 0);
	__decorate([
	    Flag(F_ABSTRACT),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isAbstract", void 0);
	__decorate([
	    Flag(F_PUBLIC),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isPublic", void 0);
	__decorate([
	    Flag(F_PRIVATE),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isPrivate", void 0);
	__decorate([
	    Flag(F_PROTECTED),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isProtected", void 0);
	__decorate([
	    Flag(F_PROPERTY),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isProperty", void 0);
	__decorate([
	    Flag(F_METHOD),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isMethod", void 0);
	__decorate([
	    Flag(F_CLASS),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isClass", void 0);
	__decorate([
	    Flag(F_INTERFACE),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isInterface", void 0);
	__decorate([
	    Flag(F_OPTIONAL),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isOptional", void 0);
	__decorate([
	    Flag(F_ASYNC),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isAsync", void 0);
	__decorate([
	    Flag(F_EXPORTED),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isExported", void 0);
	__decorate([
	    Flag(F_INFERRED),
	    __metadata("design:type", Boolean)
	], ReflectedFlags.prototype, "isInferred", void 0);
	/**
	 * Reflection data for a parameter
	 */
	class ReflectedParameter {
	    constructor(rawMetadata, index) {
	        this.rawMetadata = rawMetadata;
	        this.index = index;
	    }
	    /**
	     * Get the unmangled original name for this parameter
	     */
	    get name() {
	        return this.rawMetadata.n;
	    }
	    /**
	     * Get the reflected type of this parameter
	     */
	    get type() {
	        if (this._type)
	            return this._type;
	        return this._type = ReflectedTypeRef.createFromRtRef(this.rawMetadata.t());
	    }
	    /**
	     * Get flags that define aspects of this property.
	     */
	    get flags() {
	        if (this._flags)
	            return this._flags;
	        return this._flags = new ReflectedFlags(this.rawMetadata.f);
	    }
	    /**
	     * True if this parameter is optional
	     */
	    get isOptional() {
	        return this.flags.isOptional;
	    }
	    /**
	     * Retrieve the initializer for this parameter. Invoking the initializer produces the
	     * default value for the parameter. Caution: The initializer depends on the value of 'this'.
	     * Use evaluateInitializer() to properly invoke the initializer.
	     */
	    get initializer() {
	        return this.rawMetadata.v;
	    }
	    /**
	     * Evaluate the initializer for this parameter with the given value for 'this'. If not provided,
	     * 'this' is an empty object. This is suitable for constructor parameters but instance method parameters
	     * may reference properties of the object, and so getting the correct value may require passing an
	     * appropriate instance.
	     *
	     * @param thisObject
	     * @returns
	     */
	    evaluateInitializer(thisObject = {}) {
	        return this.initializer.apply(thisObject, []);
	    }
	}
	/**
	 * Reflection data for a method parameter
	 */
	class ReflectedMethodParameter extends ReflectedParameter {
	    constructor(method, rawMetadata, index) {
	        super(rawMetadata, index);
	        this.method = method;
	        this.rawMetadata = rawMetadata;
	        this.index = index;
	    }
	    get parent() { return this.method; }
	    get class() { return this.method.class; }
	}
	/**
	 * Reflection data for a method parameter
	 */
	class ReflectedFunctionParameter extends ReflectedParameter {
	    constructor(func, rawMetadata, index) {
	        super(rawMetadata, index);
	        this.func = func;
	        this.rawMetadata = rawMetadata;
	        this.index = index;
	    }
	    get parent() { return this.func; }
	}
	/**
	 * Reflection data for a constructor parameter
	 */
	class ReflectedConstructorParameter extends ReflectedParameter {
	    constructor(reflectedClass, rawMetadata, index) {
	        super(rawMetadata, index);
	        this.reflectedClass = reflectedClass;
	        this.rawMetadata = rawMetadata;
	        this.index = index;
	        this._class = reflectedClass;
	    }
	    get parent() { return this.class; }
	    /**
	     * Retrieve the reflected class that this constructor parameter is defined on.
	     */
	    get class() {
	        return this._class;
	    }
	    /**
	     * True if this constructor parameter is declared readonly, meaning it is
	     * also an instance property of the class.
	     */
	    get isReadonly() {
	        return this.flags.isReadonly;
	    }
	    /**
	     * True if this constructor parameter is declared public, meaning it is
	     * also an instance property of the class.
	     */
	    get isPublic() {
	        return this.flags.isPublic;
	    }
	    /**
	     * True if this constructor parameter is declared protected, meaning it is
	     * also an instance property of the class.
	     */
	    get isProtected() {
	        return this.flags.isProtected;
	    }
	    /**
	     * True if this constructor parameter is declared private, meaning it is
	     * also an instance property of the class.
	     */
	    get isPrivate() {
	        return this.flags.isPrivate;
	    }
	    /**
	     * Get visibility of this constructor parameter. If the constructor
	     * parameter has no visibility modifiers, this is null.
	     */
	    get visibility() {
	        return this.isPublic ? 'public'
	            : this.isProtected ? 'protected'
	                : this.isPrivate ? 'private'
	                    : null;
	    }
	    /**
	     * True if the constructor parameter is also a property.
	     */
	    get isProperty() {
	        return this.visibility !== null || this.isReadonly;
	    }
	}
	/**
	 * Reflection data for a class member
	 */
	class ReflectedMember {
	    constructor(reflectedClass, name, isStatic) {
	        this.name = name;
	        this.isStatic = isStatic;
	        this._class = reflectedClass;
	    }
	    /**
	     * Get the given metadata key for this member. This is equivalent to
	     * Reflect.getMetadata(key, this.host, this.name)
	     * @param key
	     * @returns
	     */
	    getMetadata(key) {
	        return Reflect.getMetadata(key, this.host, this.name);
	    }
	    /**
	     * Define a metadata key for this member. This is equivalent to
	     * Reflect.defineMetadata(key, value, this.host, this.name)
	     * @param key
	     * @returns
	     */
	    defineMetadata(key, value) {
	        Reflect.defineMetadata(key, value, this.host, this.name);
	        return value;
	    }
	    /**
	     * Get or define a metadata item for this member. If the key already exists, its
	     * value is returned without calling the passed function. Otherwise the passed function
	     * is called and its value is saved to the given metadata key.
	     *
	     * @param key The metadata key to fetch
	     * @param definer A function which will define the value of the metadata
	     * @returns The value of the existing metadata key or the new value returned by the definer function
	     *          which will also be defined as the appropriate metadata item on this member.
	     */
	    metadata(key, definer) {
	        if (this.hasMetadata(key))
	            return this.getMetadata(key);
	        let value = definer();
	        this.defineMetadata(key, value);
	        return value;
	    }
	    /**
	     * Check if a metadata key exists for this member. This is equivalent to
	     * Reflect.hasMetadata(key, this.host, this.name)
	     * @param key
	     * @returns
	     */
	    hasMetadata(key) {
	        return Reflect.hasMetadata(key, this.host, this.name);
	    }
	    /**
	     * Get the host object for this method. For static members this is the
	     * class constructor. For instance members this is the class's prototype.
	     */
	    get host() {
	        return this.isStatic ? this.class.class : this.class.prototype;
	    }
	    /**
	     * Get the reflected class that hosts this member
	     */
	    get class() {
	        return this._class;
	    }
	    /**
	     * Get the flags for this member. Includes modifiers and other properties about
	     * the member.
	     */
	    get flags() {
	        if (this._flags)
	            return this._flags;
	        return this._flags = new ReflectedFlags(this.getMetadata('rt:f'));
	    }
	    /**
	     * True if this member is abstract.
	     */
	    get isAbstract() {
	        return this.flags.isAbstract;
	    }
	    /**
	     * True if this member has private visibility.
	     */
	    get isPrivate() {
	        return this.flags.isPrivate;
	    }
	    /**
	     * True if this member has public visibility.
	     */
	    get isPublic() {
	        return this.visibility === 'public';
	    }
	    /**
	     * True if this member is specifically marked as public
	     * (as opposed to default visibility).
	     */
	    get isMarkedPublic() {
	        return this.flags.isPublic;
	    }
	    /**
	     * True if this member has protected visibility.
	     */
	    get isProtected() {
	        return this.flags.isProtected;
	    }
	    /**
	     * Get the visibility (accessibility) of this member.
	     * Can be 'public', 'protected', or 'private'
	     */
	    get visibility() {
	        return this.isMarkedPublic ? 'public'
	            : this.isProtected ? 'protected'
	                : this.isPrivate ? 'private'
	                    : 'public';
	    }
	    /**
	     * Whether this member is marked as optional.
	     */
	    get isOptional() {
	        return this.flags.isOptional;
	    }
	}
	class ReflectedFunction {
	    constructor(func) {
	        this.func = func;
	    }
	    static for(func) {
	        if (typeof func !== 'function')
	            throw new TypeError(`Passed value is not a function`);
	        let existing = this.reflectedFunctions.get(func);
	        if (!existing) {
	            this.reflectedFunctions.set(func, existing = new ReflectedFunction(func));
	        }
	        return existing;
	    }
	    /**
	     * Create a new ReflectedClass instance for the given type without sharing. Used during testing.
	     * @internal
	     **/
	    static new(func) {
	        return new ReflectedFunction(func);
	    }
	    matchesValue(object, errors = [], context) {
	        return object === this.func;
	    }
	    /**
	     * Check if the function has the given metadata key defined. This is equivalent
	     * to Reflect.hasMetadata(key, value, this.func)
	     * @param key
	     * @returns
	     */
	    hasMetadata(key) {
	        return Reflect.hasMetadata(key, this.func);
	    }
	    /**
	     * Get the specified metadata key for this function. This is equivalent
	     * to Reflect.getMetadata(key, value, this.func)
	     * @param key
	     * @returns
	     */
	    getMetadata(key) {
	        return Reflect.getMetadata(key, this.func);
	    }
	    /**
	     * Define a metadata key for this function. This is equivalent
	     * to Reflect.defineMetadata(key, value, this.func)
	     * @param key The metadata key to define.
	     * @param value
	     */
	    defineMetadata(key, value) {
	        Reflect.defineMetadata(key, value, this.func);
	        return value;
	    }
	    /**
	     * Get or define a metadata item for this function. If the key already exists, its
	     * value is returned without calling the passed function. Otherwise the passed function
	     * is called and its value is saved to the given metadata key.
	     *
	     * @param key The metadata key to fetch
	     * @param definer A function which will define the value of the metadata
	     * @returns The value of the existing metadata key or the new value returned by the definer function
	     *          which will also be defined as the appropriate metadata item on this function.
	     */
	    metadata(key, definer) {
	        if (this.hasMetadata(key))
	            return this.getMetadata(key);
	        let value = definer();
	        this.defineMetadata(key, value);
	        return value;
	    }
	    /**
	     * Get the flags for this function.
	     */
	    get flags() {
	        if (this._flags)
	            return this._flags;
	        return this._flags = new ReflectedFlags(this.getMetadata('rt:f'));
	    }
	    /**
	     * @internal
	     */
	    get rawParameterMetadata() {
	        if (this._rawParameterMetadata)
	            return this._rawParameterMetadata;
	        return this._rawParameterMetadata = this.getMetadata('rt:p');
	    }
	    /**
	     * Names of the parameters for this function.
	     */
	    get parameterNames() {
	        return this.rawParameterMetadata.map(x => x.n);
	    }
	    /**
	     * Types for the parameter types of this function.
	     */
	    get parameterTypes() {
	        if (this._parameterTypes !== undefined)
	            return this._parameterTypes;
	        if (this.rawParameterMetadata !== undefined) {
	            return this._parameterTypes = this.rawParameterMetadata.map(param => {
	                return param.t ? ReflectedTypeRef.createFromRtRef(param.t()) : ReflectedTypeRef.createUnknown();
	            });
	        }
	        else if (this.hasMetadata('design:paramtypes')) {
	            let params = this.getMetadata('design:paramtypes');
	            return this._parameterTypes = (params || []).map(t => ReflectedTypeRef.createFromRtRef(() => t));
	        }
	        return [];
	    }
	    /**
	     * Retrieve the set of reflected parameters for this method.
	     */
	    get parameters() {
	        if (this._parameters)
	            return this._parameters;
	        return this._parameters = this.rawParameterMetadata.map((x, i) => new ReflectedFunctionParameter(this, x, i));
	    }
	    /**
	     * Get the parameter with the specified name
	     * @param name
	     * @returns The reflected parameter
	     */
	    getParameter(name) {
	        return this.parameters.find(x => x.name === name);
	    }
	    /**
	     * Retrieve the return type of this function.
	     */
	    get returnType() {
	        if (this._returnType !== undefined)
	            return this._returnType;
	        let typeResolver = this.getMetadata('rt:t');
	        if (!typeResolver && this.hasMetadata('design:returntype')) {
	            let designReturnType = this.getMetadata('design:returntype');
	            typeResolver = () => (designReturnType || null);
	        }
	        if (!typeResolver)
	            return ReflectedTypeRef.createUnknown();
	        return this._returnType = ReflectedTypeRef.createFromRtRef(typeResolver());
	    }
	    /**
	     * True if the return type was inferred using the Typescript type checker. False if
	     * the return type was defined explicitly.
	     */
	    get returnTypeInferred() {
	        return this.flags.isInferred;
	    }
	    /**
	     * True if this function is declared as async.
	     */
	    get isAsync() {
	        return this.flags.isAsync;
	    }
	}
	ReflectedFunction.reflectedFunctions = new WeakMap();
	/**
	 * Reflection data for a class method
	 */
	class ReflectedMethod extends ReflectedMember {
	    matchesValue(object, errors = [], context) {
	        return object === this.func;
	    }
	    get func() {
	        if (this.isStatic)
	            return this.class[this.name];
	        else
	            return this.class.prototype[this.name];
	    }
	    /**
	     * @internal
	     */
	    get rawParameterMetadata() {
	        if (this._rawParameterMetadata)
	            return this._rawParameterMetadata;
	        return this._rawParameterMetadata = this.getMetadata('rt:p');
	    }
	    /**
	     * Retrieve the reflected method for the given method function.
	     * If the function is not a method, a TypeError is thrown.
	     * @param method
	     */
	    static for(method) {
	        if (!hasAnyFlag(method, [F_METHOD]))
	            throw new TypeError(`The function is not a method, or the class is not annotated with runtime type metadata`);
	        if (!Reflect.hasMetadata('rt:h', method))
	            throw new TypeError(`The function is a method, but is not annotated with a host class`);
	        let host = Reflect.getMetadata('rt:h', method);
	        if (!host)
	            throw new TypeError(`The method has a defined host, but it is null/undefined`);
	        return ReflectedClass.for(host()).getMethod(method.name);
	    }
	    /**
	     * Retrieve an array with the parameter names for this method.
	     */
	    get parameterNames() {
	        return this.rawParameterMetadata.map(x => x.n);
	    }
	    /**
	     * Retrieve an array with the parameter types for this method.
	     */
	    get parameterTypes() {
	        if (this._parameterTypes !== undefined)
	            return this._parameterTypes;
	        if (this.rawParameterMetadata !== undefined) {
	            return this._parameterTypes = this.rawParameterMetadata.map(param => {
	                return param.t ? ReflectedTypeRef.createFromRtRef(param.t()) : ReflectedTypeRef.createUnknown();
	            });
	        }
	        else if (this.hasMetadata('design:paramtypes')) {
	            let params = this.getMetadata('design:paramtypes');
	            return this._parameterTypes = (params || []).map(t => ReflectedTypeRef.createFromRtRef(() => t));
	        }
	        return [];
	    }
	    /**
	     * Retrieve the set of reflected parameters for this method.
	     */
	    get parameters() {
	        if (this._parameters)
	            return this._parameters;
	        return this._parameters = this.rawParameterMetadata.map((x, i) => new ReflectedMethodParameter(this, x, i));
	    }
	    /**
	     * Get a reflected parameter by name
	     * @param name
	     * @returns The reflected parameter
	     */
	    getParameter(name) {
	        return this.parameters.find(x => x.name === name);
	    }
	    /**
	     * Get the return type of this method.
	     */
	    get returnType() {
	        if (this._returnType !== undefined)
	            return this._returnType;
	        let typeResolver = this.getMetadata('rt:t');
	        if (!typeResolver && this.hasMetadata('design:returntype')) {
	            let designReturnType = this.getMetadata('design:returntype');
	            typeResolver = () => (designReturnType || null);
	        }
	        if (!typeResolver)
	            return ReflectedTypeRef.createUnknown();
	        return this._returnType = ReflectedTypeRef.createFromRtRef(typeResolver());
	    }
	    /**
	     * True if the return type was inferred using the Typescript type checker. False if
	     * the return type was defined explicitly.
	     */
	    get returnTypeInferred() {
	        return this.flags.isInferred;
	    }
	    /**
	     * True if this method is declared as async.
	     */
	    get isAsync() {
	        return this.flags.isAsync;
	    }
	}
	/**
	 * Represents a reflected property of a class or interface.
	 */
	class ReflectedProperty extends ReflectedMember {
	    /**
	     * Get the type of this property.
	     */
	    get type() {
	        if (this._type !== undefined)
	            return this._type;
	        let typeResolver;
	        if (this.hasMetadata('rt:t')) {
	            typeResolver = this.getMetadata('rt:t');
	        }
	        else if (this.hasMetadata('design:type')) {
	            let designType = this.getMetadata('design:type');
	            typeResolver = () => designType;
	        }
	        if (!typeResolver)
	            return this._type = ReflectedTypeRef.createUnknown();
	        return this._type = ReflectedTypeRef.createFromRtRef(typeResolver());
	    }
	    /**
	     * True if this property is marked readonly.
	     */
	    get isReadonly() {
	        return this.flags.isReadonly;
	    }
	    /**
	     * Check if the given value matches the type of this property, and would
	     * thus be a valid assignment.
	     * @param object
	     * @param errors
	     * @returns
	     */
	    matchesValue(object, errors = []) {
	        return this.type.matchesValue(object, errors);
	    }
	}
	function getFlags(value) {
	    if (!Reflect.hasMetadata('rt:f', value))
	        return '';
	    let flagsValue = Reflect.getMetadata('rt:f', value);
	    if (typeof flagsValue === 'string')
	        return flagsValue;
	    return '';
	}
	function hasAnyFlag(value, desiredFlags) {
	    let flags = getFlags(value);
	    return desiredFlags.some(x => flags.includes(x));
	}
	/**
	 * Provides access to the known runtime type metadata for a particular class
	 * or Interface value (as obtained by reify<InterfaceT>()).
	 */
	let ReflectedClass = ReflectedClass_1 = class ReflectedClass {
	    /**
	     * Constructs a new ReflectedClass. Use ReflectedClass.for() to obtain a ReflectedClass.
	     */
	    constructor(klass) {
	        this._hasPropertyNamesMeta = false;
	        this._hasStaticPropertyNameMeta = false;
	        this._dynamicStaticProperties = new Map();
	        this._dynamicProperties = new Map();
	        this._class = klass;
	    }
	    /**
	     * Obtain a ReflectedClass for the given class constructor, Interface value or instance.
	     * @param constructorOrValue Can be a class constructor, Interface, or an instance of a class (in which case the
	     *                           instance's constructor will be used)
	     * @returns The ReflectedClass.
	     */
	    static for(constructorOrValue) {
	        let flags = getFlags(constructorOrValue);
	        if (flags.includes(F_INTERFACE))
	            return this.forConstructorOrInterface(constructorOrValue);
	        else if (flags.includes(F_CLASS))
	            return this.forConstructorOrInterface(constructorOrValue);
	        else if (flags.includes(F_FUNCTION))
	            throw new TypeError(`Value is a function, use ReflectedFunction.for() or reflect(func) instead`);
	        // Heuristic based on shape
	        if (typeof constructorOrValue === 'function' || ('name' in constructorOrValue && 'prototype' in constructorOrValue && typeof constructorOrValue.identity === 'symbol'))
	            return this.forConstructorOrInterface(constructorOrValue);
	        // Assume it's an instance of a class
	        return this.forConstructorOrInterface(constructorOrValue.constructor);
	    }
	    /**
	     * Create a new ReflectedClass instance for the given type without sharing. Used during testing.
	     * @internal
	     **/
	    static new(constructorOrInterface) {
	        return new ReflectedClass_1(constructorOrInterface);
	    }
	    static forConstructorOrInterface(constructorOrInterface) {
	        let existing = this.reflectedClasses.get(constructorOrInterface);
	        if (!existing) {
	            this.reflectedClasses.set(constructorOrInterface, existing = new ReflectedClass_1(constructorOrInterface));
	        }
	        return existing;
	    }
	    /**
	     * Get the interfaces that this class implements.
	     */
	    get interfaces() {
	        if (this._interfaces !== undefined)
	            return this._interfaces;
	        if (this.hasMetadata('rt:i')) {
	            return this._interfaces = this.getMetadata('rt:i')
	                .map(resolver => resolver())
	                .filter(x => !!x)
	                .map(ref => ReflectedTypeRef.createFromRtRef(ref));
	        }
	        return [];
	    }
	    /**
	     * Check if this class implements the given interface. The parameter can be a reified interface
	     * reference or a class reference. Note that implementing a class is not the same as extending a class.
	     *
	     * @param interfaceType
	     * @returns boolean
	     */
	    implements(interfaceType) {
	        return !!this.interfaces.find(i => typeof interfaceType === 'function' ? i.isClass(interfaceType) : i.isInterface(interfaceType));
	    }
	    /**
	     * Check if the given value matches the shape of this type, and thus would be a valid assignment.
	     * @param object
	     * @param errors
	     * @returns
	     */
	    matchesValue(object, errors = []) {
	        if (object === null || object === void 0) {
	            errors.push(new Error(`Value is undefined`));
	            return false;
	        }
	        if (typeof object !== 'object') {
	            errors.push(new Error(`Value must be an object`));
	            return false;
	        }
	        let matches = true;
	        if (globalThis.RTTI_TRACE === true)
	            console.log(`Type checking value against type '${this.class.name}'`);
	        for (let prop of this.properties) {
	            let hasValue = prop.name in object;
	            let value = object[prop.name];
	            if (!hasValue && !prop.isOptional) {
	                errors.push(new Error(`Property '${prop.name}' is missing in value`));
	                matches = false;
	            }
	            if (!hasValue)
	                continue;
	            let propMatch = prop.matchesValue(value, errors);
	            if (globalThis.RTTI_TRACE === true)
	                console.log(` - ${this.class.name}#${prop.name} : ${prop.type} | valid(${JSON.stringify(value)}) => ${propMatch}`);
	            matches && (matches = propMatch);
	        }
	        return matches;
	    }
	    /**
	     * Get the prototype object for this reflected class.
	     */
	    get prototype() {
	        return this._class.prototype;
	    }
	    /**
	     * Get the class constructor for this reflected class.
	     */
	    get class() {
	        return this._class;
	    }
	    /**
	     * Get the reflected superclass for this class.
	     */
	    get super() {
	        var _a, _b;
	        if (this._super !== undefined)
	            return this._super;
	        let parentClass = (_b = (_a = Object.getPrototypeOf(this.class.prototype)) === null || _a === void 0 ? void 0 : _a.constructor) !== null && _b !== void 0 ? _b : Object;
	        if (parentClass === Object)
	            return this._super = null;
	        else
	            return this._super = ReflectedClass_1.for(parentClass);
	    }
	    /**
	     * Check if the function has the given metadata key defined. This is equivalent
	     * to Reflect.hasMetadata(key, this.class)
	     * @param key
	     * @returns
	     */
	    hasMetadata(key) {
	        return Reflect.hasMetadata(key, this.class);
	    }
	    /**
	     * Get the specified metadata key. This is equivalent to Reflect.getMetadata(key, this.class).
	     * @param key
	     * @returns
	     */
	    getMetadata(key) {
	        return Reflect.getMetadata(key, this.class);
	    }
	    /**
	     * Define a metadata key on this class. This is equivalent to Reflect.defineMetadata(key, value, this.class).
	     * @param key
	     * @param value
	     * @returns
	     */
	    defineMetadata(key, value) {
	        Reflect.defineMetadata(key, value, this.class);
	        return value;
	    }
	    /**
	     * Get or define a metadata item for this class/interface. If the key already exists, its
	     * value is returned without calling the passed function. Otherwise the passed function
	     * is called and its value is saved to the given metadata key.
	     *
	     * @param key The metadata key to fetch
	     * @param definer A function which will define the value of the metadata
	     * @returns The value of the existing metadata key or the new value returned by the definer function
	     *          which will also be defined as the appropriate metadata item on this class/interface.
	     */
	    metadata(key, definer) {
	        if (this.hasMetadata(key))
	            return this.getMetadata(key);
	        let value = definer();
	        this.defineMetadata(key, value);
	        return value;
	    }
	    /**
	     * Define a metadata key on this class's prototype object. This is equivalent to Reflect.defineMetadata(key, value, this.class.prototype)
	     * @param key
	     * @param value
	     * @returns
	     */
	    definePrototypeMetadata(key, value) {
	        Reflect.defineMetadata(key, value, this.class.prototype);
	        return value;
	    }
	    /**
	     * Retrieve the set of property names that are defined directly on this class, excluding
	     * those which are inherited.
	     */
	    get ownPropertyNames() {
	        if (this._ownPropertyNames)
	            return this._ownPropertyNames;
	        let propertyNames;
	        if (this.hasMetadata('rt:P')) {
	            propertyNames = this.getMetadata('rt:P');
	            this._hasPropertyNamesMeta = !!propertyNames;
	        }
	        else {
	            propertyNames = Object.getOwnPropertyNames(this.class.prototype)
	                .filter(x => x !== 'constructor')
	                .filter(x => {
	                // All properties which have `get` defined must be considered properties, not methods.
	                // We need to avoid executing getters inadvertently while determining the type of the property.
	                // https://github.com/typescript-rtti/typescript-rtti/issues/52
	                let descriptor = Object.getOwnPropertyDescriptor(this.class.prototype, x);
	                if (descriptor.get)
	                    return true;
	                return typeof this.class.prototype[x] === 'function';
	            });
	        }
	        return this._ownPropertyNames = propertyNames || [];
	    }
	    /**
	     * Retrieve the set of method names that are defined directly on this class, excluding
	     * those which are inherited.
	     */
	    get ownMethodNames() {
	        if (this._ownMethodNames)
	            return this._ownMethodNames;
	        let methodNames = this.getMetadata('rt:m');
	        if (!methodNames) {
	            methodNames = Object.getOwnPropertyNames(this.class.prototype)
	                .filter(x => x !== 'constructor')
	                .filter(x => {
	                // All properties which have `get` defined must be considered properties, not methods.
	                // We need to avoid executing getters inadvertently while determining the type of the property.
	                // https://github.com/typescript-rtti/typescript-rtti/issues/52
	                let descriptor = Object.getOwnPropertyDescriptor(this.class.prototype, x);
	                if (descriptor.get)
	                    return false;
	                return typeof this.class.prototype[x] === 'function';
	            });
	        }
	        return this._ownMethodNames = methodNames;
	    }
	    /**
	     * Retrieve the set of static property names that are defined directly on this class, excluding
	     * those which are inherited. Always empty for interfaces.
	     */
	    get ownStaticPropertyNames() {
	        if (this._ownStaticPropertyNames)
	            return this._ownStaticPropertyNames;
	        let ownStaticPropertyNames = this.getMetadata('rt:SP');
	        this._hasStaticPropertyNameMeta = !!ownStaticPropertyNames;
	        if (!ownStaticPropertyNames) {
	            this._hasStaticPropertyNameMeta = false;
	            ownStaticPropertyNames = Object.getOwnPropertyNames(this.class)
	                .filter(x => !['length', 'prototype', 'name'].includes(x))
	                .filter(x => typeof this.class[x] !== 'function');
	        }
	        return this._ownStaticPropertyNames = ownStaticPropertyNames;
	    }
	    /**
	     * Retrieve the set of static method names that are defined directly on this class,
	     * excluding those which are inherited. Always empty for interfaces
	     */
	    get ownStaticMethodNames() {
	        if (this._ownStaticMethodNames)
	            return this._ownStaticMethodNames;
	        let ownStaticMethodNames = this.getMetadata('rt:Sm');
	        if (!ownStaticMethodNames) {
	            ownStaticMethodNames = Object.getOwnPropertyNames(this.class)
	                .filter(x => !['length', 'prototype', 'name'].includes(x))
	                .filter(x => typeof this.class[x] === 'function');
	        }
	        return this._ownStaticMethodNames = ownStaticMethodNames;
	    }
	    /**
	     * Retrieve the set of flags for this class/interface. Use this to check for modifiers or other properties
	     * of the class/interface.
	     */
	    get flags() {
	        if (this._flags)
	            return this._flags;
	        return this._flags = new ReflectedFlags(this.getMetadata('rt:f'));
	    }
	    /**
	     * True if the class is marked abstract.
	     */
	    get isAbstract() {
	        return this.flags.isAbstract;
	    }
	    /**
	     * Get the instance method names for this reflected class/interface.
	     */
	    get methodNames() {
	        if (this._methodNames)
	            return this._methodNames;
	        if (this.super) {
	            return this._methodNames = this.super.methodNames.concat(this.ownMethodNames);
	        }
	        else {
	            return this._methodNames = this.ownMethodNames;
	        }
	    }
	    /**
	     * Get the static property names defined for this reflected class. Always empty for interfaces.
	     */
	    get staticPropertyNames() {
	        if (this._staticPropertyNames)
	            return this._staticPropertyNames;
	        if (this.super) {
	            return this._staticPropertyNames = this.super.staticPropertyNames.concat(this.ownStaticPropertyNames);
	        }
	        else {
	            return this._staticPropertyNames = this.ownStaticPropertyNames;
	        }
	    }
	    /**
	     * Retrieve an array of the names of static methods defined on this reflected class.
	     * Always empty for interfaces.
	     */
	    get staticMethodNames() {
	        if (this._staticMethodNames)
	            return this._staticMethodNames;
	        if (this.super) {
	            return this._staticMethodNames = this.super.staticMethodNames.concat(this.ownStaticMethodNames);
	        }
	        else {
	            return this._staticMethodNames = this.ownStaticMethodNames;
	        }
	    }
	    /**
	     * Retrieve an array of the names of instance properties defined on this class/interface
	     */
	    get propertyNames() {
	        if (this._propertyNames)
	            return this._propertyNames;
	        if (this.super) {
	            return this._propertyNames = this.super.propertyNames.concat(this.ownPropertyNames);
	        }
	        else {
	            return this._propertyNames = this.ownPropertyNames;
	        }
	    }
	    /**
	     * Retrieve the set of reflected methods defined directly on this class/interface.
	     */
	    get ownMethods() {
	        if (this._ownMethods)
	            return this._ownMethods;
	        return this._ownMethods = this.ownMethodNames.map(name => new ReflectedMethod(this, name, false));
	    }
	    /**
	     * Retrieve the set of reflected static properties defined directly on this class. Always empty
	     * for interfaces.
	     */
	    get ownStaticProperties() {
	        if (this._ownStaticProperties)
	            return this._ownStaticProperties;
	        return this._ownStaticProperties = this.staticPropertyNames.map(x => new ReflectedProperty(this, x, true));
	    }
	    /**
	     * Retrieve the set of reflected static methods defined directly on this class. Always
	     * empty for interfaces.
	     */
	    get ownStaticMethods() {
	        if (this._ownStaticMethods)
	            return this._ownStaticMethods;
	        return this._ownStaticMethods = this.ownStaticMethodNames.map(name => new ReflectedMethod(this, name, true));
	    }
	    /**
	     * Retrieve the set of reflected instance methods defined on this class/interface.
	     */
	    get methods() {
	        if (this._methods)
	            return this._methods;
	        if (this.super)
	            return this._methods = this.super.methods.concat(this.ownMethods);
	        else
	            return this._methods = this.ownMethods;
	    }
	    /**
	     * Retrieve the set of reflected static properties defined on this class. Always
	     * empty for interfaces.
	     */
	    get staticProperties() {
	        if (this._staticProperties)
	            return this._staticProperties;
	        if (this.super)
	            return this._staticProperties = this.super.staticProperties.concat(this.ownStaticProperties);
	        else
	            return this._staticProperties = this.ownStaticProperties;
	    }
	    /**
	     * Retrieve the set of reflected static methods defined on this class. Always
	     * empty for interfaces
	     */
	    get staticMethods() {
	        if (this._staticMethods)
	            return this._staticMethods;
	        if (this.super)
	            return this._staticMethods = this.super.staticMethods.concat(this.ownStaticMethods);
	        else
	            return this._staticMethods = this.ownStaticMethods;
	    }
	    /**
	     * Retrieve the set of reflected instance properties defined directly on this class/interface
	     */
	    get ownProperties() {
	        if (this._ownProperties)
	            return this._ownProperties;
	        return this._ownProperties = this.ownPropertyNames.map(name => new ReflectedProperty(this, name, false));
	    }
	    /**
	     * Retrieve the set of reflected instance methods defined on this class/interface
	     */
	    get properties() {
	        if (this._properties)
	            return this._properties;
	        if (this.super)
	            return this._properties = this.super.properties.concat(this.ownProperties);
	        else
	            return this._properties = this.ownProperties;
	    }
	    get rawParameterMetadata() {
	        if (this._rawParameterMetadata)
	            return this._rawParameterMetadata;
	        let rawParams = this.getMetadata('rt:p');
	        if (rawParams === void 0 && this.hasMetadata('design:paramtypes')) {
	            let types = this.getMetadata('design:paramtypes');
	            let names = getParameterNames(this.class);
	            rawParams = names.map((n, i) => ({ n, t: () => types[i] }));
	        }
	        return this._rawParameterMetadata = rawParams || [];
	    }
	    /**
	     * Retrieve an array of the parameter names for this class's constructor.
	     */
	    get parameterNames() {
	        return this.rawParameterMetadata.map(x => x.n);
	    }
	    /**
	     * Retrieve an array of the types for the parameters of this class's
	     * constructor.
	     */
	    get parameterTypes() {
	        return this.rawParameterMetadata.map(x => x.t);
	    }
	    /**
	     * Retrieve the set of reflected parameters for this class's constructor.
	     */
	    get parameters() {
	        if (this._parameters)
	            return this._parameters;
	        return this._parameters = this.rawParameterMetadata.map((x, i) => new ReflectedConstructorParameter(this, x, i));
	    }
	    /**
	     * Get a reflected constructor parameter by name.
	     * @param name
	     * @returns
	     */
	    getParameter(name) {
	        return this.parameters.find(x => x.name === name);
	    }
	    /**
	     * Get a reflected instance method (declared directly on this class) by name
	     * @param name
	     * @returns
	     */
	    getOwnMethod(name) {
	        return this.ownMethods.find(x => x.name === name);
	    }
	    /**
	     * Get a reflected instance method by name
	     * @param name
	     * @returns
	     */
	    getMethod(name) {
	        return this.methods.find(x => x.name === name);
	    }
	    /**
	     * Get a reflected static method by name
	     * @param name
	     * @returns
	     */
	    getStaticMethod(name) {
	        return this.staticMethods.find(x => x.name === name);
	    }
	    /**
	     * Get a reflected static property (declared directly on this class) by name
	     * @param name
	     * @returns
	     */
	    getOwnStaticProperty(name) {
	        let matchingProp = this.ownStaticProperties.find(x => x.name === name);
	        if (matchingProp)
	            return matchingProp;
	        if (!this._hasStaticPropertyNameMeta) {
	            if (this._dynamicStaticProperties.has(name))
	                return this._dynamicStaticProperties.get(name);
	            let prop = new ReflectedProperty(this, name, true);
	            this._dynamicStaticProperties.set(name, prop);
	            return prop;
	        }
	    }
	    /**
	     * Get a reflected static property by name
	     * @param name
	     * @returns
	     */
	    getStaticProperty(name) {
	        let matchingProp = this.staticProperties.find(x => x.name === name);
	        if (matchingProp)
	            return matchingProp;
	        if (!this._hasStaticPropertyNameMeta) {
	            if (this._dynamicStaticProperties.has(name))
	                return this._dynamicStaticProperties.get(name);
	            let prop = new ReflectedProperty(this, name, true);
	            this._dynamicStaticProperties.set(name, prop);
	            return prop;
	        }
	    }
	    /**
	     * Get a reflected instance property (declared directly on this class) by name
	     * @param name
	     * @returns
	     */
	    getOwnProperty(name) {
	        let matchingProp = this.ownProperties.find(x => x.name === name);
	        if (matchingProp)
	            return matchingProp;
	        if (!this._hasPropertyNamesMeta) {
	            if (this._dynamicProperties.has(name))
	                return this._dynamicProperties.get(name);
	            let prop = new ReflectedProperty(this, name, false);
	            this._dynamicProperties.set(name, prop);
	            return prop;
	        }
	    }
	    /**
	     * Get a reflected instance property by name
	     * @param name
	     * @returns
	     */
	    getProperty(name) {
	        let matchingProp = this.properties.find(x => x.name === name);
	        if (matchingProp)
	            return matchingProp;
	        if (!this._hasPropertyNamesMeta) {
	            if (this._dynamicProperties.has(name))
	                return this._dynamicProperties.get(name);
	            let prop = new ReflectedProperty(this, name, false);
	            this._dynamicProperties.set(name, prop);
	            return prop;
	        }
	    }
	};
	ReflectedClass.reflectedClasses = new WeakMap();
	ReflectedClass = ReflectedClass_1 = __decorate([
	    Sealed(),
	    __metadata("design:paramtypes", [Object])
	], ReflectedClass);
	/**
	 * @rtti:callsite 1
	 */
	function reflect(value = NotProvided, callSite) {
	    if (value === NotProvided && !callSite) {
	        throw new Error(`reflect<T>() can only be used when project is built with the typescript-rtti transformer`);
	    }
	    if (!value)
	        throw new TypeError(`Could not reflect on null/undefined`);
	    if (isCallSite(value))
	        return new ReflectedCallSite(value);
	    if (value === NotProvided && isCallSite(callSite))
	        return new ReflectedCallSite(callSite).typeParameters[0];
	    if (!['object', 'function'].includes(typeof value)) {
	        // Primitive value
	        return reflect(value.constructor);
	    }
	    let flags = getFlags(value);
	    if (flags.includes(F_FUNCTION))
	        return ReflectedFunction.for(value);
	    if (flags.includes(F_METHOD))
	        return ReflectedMethod.for(value);
	    if (typeof value === 'function' && !value.prototype)
	        return ReflectedFunction.for(value);
	    return ReflectedClass.for(value);
	}
	class ReflectedCallSite {
	    constructor(callSite) {
	        this.callSite = callSite;
	    }
	    get parameters() {
	        if (!this._parameters)
	            this._parameters = this.callSite.p.map(x => ReflectedTypeRef.createFromRtRef(x));
	        return this._parameters;
	    }
	    get typeParameters() {
	        if (!this._typeParameters) {
	            this._typeParameters = this.callSite.tp.map(x => ReflectedTypeRef.createFromRtRef(x));
	        }
	        return this._typeParameters;
	    }
	}

	const __RΦ$t$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$t$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$t$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$t$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [4]: { RΦ: t => ({ TΦ: "~" }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Пустая команда. Ничего не выполняет.
	 * Используется для создания повторяющихся команд.
	 */
	class NotOperationCommand {
	    name = 'NotOperationCommand';
	    constructor() { }
	    execute() { }
	}
	(t => __RΦ$t$1.t[84] = t)(NotOperationCommand);
	__RΦ$t$1.m("rt:SP", [])(NotOperationCommand);
	__RΦ$t$1.m("rt:P", ["name"])(NotOperationCommand);
	__RΦ$t$1.m("rt:Sm", [])(NotOperationCommand);
	__RΦ$t$1.m("rt:m", ["execute"])(NotOperationCommand);
	__RΦ$t$1.m("rt:p", [])(NotOperationCommand);
	__RΦ$t$1.m("rt:i", [() => undefined])(NotOperationCommand);
	__RΦ$t$1.m("rt:f", "Ce")(NotOperationCommand);
	__RΦ$t$1.m("rt:t", () => __RΦ$t$1.a(4))(NotOperationCommand.prototype, "name");
	__RΦ$t$1.m("rt:f", "P$R")(NotOperationCommand.prototype, "name");
	__RΦ$t$1.m("rt:f", "M$")(NotOperationCommand.prototype["execute"]);
	((t, p) => __RΦ$t$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(NotOperationCommand.prototype, "execute");
	__RΦ$t$1.m("rt:p", [])(NotOperationCommand.prototype, "execute");
	__RΦ$t$1.m("rt:f", "M$")(NotOperationCommand.prototype, "execute");
	__RΦ$t$1.m("rt:t", () => __RΦ$t$1.a(23))(NotOperationCommand.prototype, "execute");

	var dist$2 = {};

	var events$1 = {exports: {}};

	var R$1 = typeof Reflect === 'object' ? Reflect : null;
	var ReflectApply$1 = R$1 && typeof R$1.apply === 'function'
	  ? R$1.apply
	  : function ReflectApply(target, receiver, args) {
	    return Function.prototype.apply.call(target, receiver, args);
	  };

	var ReflectOwnKeys$1;
	if (R$1 && typeof R$1.ownKeys === 'function') {
	  ReflectOwnKeys$1 = R$1.ownKeys;
	} else if (Object.getOwnPropertySymbols) {
	  ReflectOwnKeys$1 = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target)
	      .concat(Object.getOwnPropertySymbols(target));
	  };
	} else {
	  ReflectOwnKeys$1 = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target);
	  };
	}

	function ProcessEmitWarning$1(warning) {
	  if (console && console.warn) console.warn(warning);
	}

	var NumberIsNaN$1 = Number.isNaN || function NumberIsNaN(value) {
	  return value !== value;
	};

	function EventEmitter$1$1() {
	  EventEmitter$1$1.init.call(this);
	}
	events$1.exports = EventEmitter$1$1;
	events$1.exports.once = once$1;

	// Backwards-compat with node 0.10.x
	EventEmitter$1$1.EventEmitter = EventEmitter$1$1;

	EventEmitter$1$1.prototype._events = undefined;
	EventEmitter$1$1.prototype._eventsCount = 0;
	EventEmitter$1$1.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	var defaultMaxListeners$1 = 10;

	function checkListener$1(listener) {
	  if (typeof listener !== 'function') {
	    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
	  }
	}

	Object.defineProperty(EventEmitter$1$1, 'defaultMaxListeners', {
	  enumerable: true,
	  get: function() {
	    return defaultMaxListeners$1;
	  },
	  set: function(arg) {
	    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN$1(arg)) {
	      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
	    }
	    defaultMaxListeners$1 = arg;
	  }
	});

	EventEmitter$1$1.init = function() {

	  if (this._events === undefined ||
	      this._events === Object.getPrototypeOf(this)._events) {
	    this._events = Object.create(null);
	    this._eventsCount = 0;
	  }

	  this._maxListeners = this._maxListeners || undefined;
	};

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter$1$1.prototype.setMaxListeners = function setMaxListeners(n) {
	  if (typeof n !== 'number' || n < 0 || NumberIsNaN$1(n)) {
	    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
	  }
	  this._maxListeners = n;
	  return this;
	};

	function _getMaxListeners$1(that) {
	  if (that._maxListeners === undefined)
	    return EventEmitter$1$1.defaultMaxListeners;
	  return that._maxListeners;
	}

	EventEmitter$1$1.prototype.getMaxListeners = function getMaxListeners() {
	  return _getMaxListeners$1(this);
	};

	EventEmitter$1$1.prototype.emit = function emit(type) {
	  var args = [];
	  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
	  var doError = (type === 'error');

	  var events = this._events;
	  if (events !== undefined)
	    doError = (doError && events.error === undefined);
	  else if (!doError)
	    return false;

	  // If there is no 'error' event listener then throw.
	  if (doError) {
	    var er;
	    if (args.length > 0)
	      er = args[0];
	    if (er instanceof Error) {
	      // Note: The comments on the `throw` lines are intentional, they show
	      // up in Node's output if this results in an unhandled exception.
	      throw er; // Unhandled 'error' event
	    }
	    // At least give some kind of context to the user
	    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
	    err.context = er;
	    throw err; // Unhandled 'error' event
	  }

	  var handler = events[type];

	  if (handler === undefined)
	    return false;

	  if (typeof handler === 'function') {
	    ReflectApply$1(handler, this, args);
	  } else {
	    var len = handler.length;
	    var listeners = arrayClone$1(handler, len);
	    for (var i = 0; i < len; ++i)
	      ReflectApply$1(listeners[i], this, args);
	  }

	  return true;
	};

	function _addListener$1(target, type, listener, prepend) {
	  var m;
	  var events;
	  var existing;

	  checkListener$1(listener);

	  events = target._events;
	  if (events === undefined) {
	    events = target._events = Object.create(null);
	    target._eventsCount = 0;
	  } else {
	    // To avoid recursion in the case that type === "newListener"! Before
	    // adding it to the listeners, first emit "newListener".
	    if (events.newListener !== undefined) {
	      target.emit('newListener', type,
	                  listener.listener ? listener.listener : listener);

	      // Re-assign `events` because a newListener handler could have caused the
	      // this._events to be assigned to a new object
	      events = target._events;
	    }
	    existing = events[type];
	  }

	  if (existing === undefined) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    existing = events[type] = listener;
	    ++target._eventsCount;
	  } else {
	    if (typeof existing === 'function') {
	      // Adding the second element, need to change to array.
	      existing = events[type] =
	        prepend ? [listener, existing] : [existing, listener];
	      // If we've already got an array, just append.
	    } else if (prepend) {
	      existing.unshift(listener);
	    } else {
	      existing.push(listener);
	    }

	    // Check for listener leak
	    m = _getMaxListeners$1(target);
	    if (m > 0 && existing.length > m && !existing.warned) {
	      existing.warned = true;
	      // No error code for this since it is a Warning
	      // eslint-disable-next-line no-restricted-syntax
	      var w = new Error('Possible EventEmitter memory leak detected. ' +
	                          existing.length + ' ' + String(type) + ' listeners ' +
	                          'added. Use emitter.setMaxListeners() to ' +
	                          'increase limit');
	      w.name = 'MaxListenersExceededWarning';
	      w.emitter = target;
	      w.type = type;
	      w.count = existing.length;
	      ProcessEmitWarning$1(w);
	    }
	  }

	  return target;
	}

	EventEmitter$1$1.prototype.addListener = function addListener(type, listener) {
	  return _addListener$1(this, type, listener, false);
	};

	EventEmitter$1$1.prototype.on = EventEmitter$1$1.prototype.addListener;

	EventEmitter$1$1.prototype.prependListener =
	    function prependListener(type, listener) {
	      return _addListener$1(this, type, listener, true);
	    };

	function onceWrapper$1() {
	  if (!this.fired) {
	    this.target.removeListener(this.type, this.wrapFn);
	    this.fired = true;
	    if (arguments.length === 0)
	      return this.listener.call(this.target);
	    return this.listener.apply(this.target, arguments);
	  }
	}

	function _onceWrap$1(target, type, listener) {
	  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
	  var wrapped = onceWrapper$1.bind(state);
	  wrapped.listener = listener;
	  state.wrapFn = wrapped;
	  return wrapped;
	}

	EventEmitter$1$1.prototype.once = function once(type, listener) {
	  checkListener$1(listener);
	  this.on(type, _onceWrap$1(this, type, listener));
	  return this;
	};

	EventEmitter$1$1.prototype.prependOnceListener =
	    function prependOnceListener(type, listener) {
	      checkListener$1(listener);
	      this.prependListener(type, _onceWrap$1(this, type, listener));
	      return this;
	    };

	// Emits a 'removeListener' event if and only if the listener was removed.
	EventEmitter$1$1.prototype.removeListener =
	    function removeListener(type, listener) {
	      var list, events, position, i, originalListener;

	      checkListener$1(listener);

	      events = this._events;
	      if (events === undefined)
	        return this;

	      list = events[type];
	      if (list === undefined)
	        return this;

	      if (list === listener || list.listener === listener) {
	        if (--this._eventsCount === 0)
	          this._events = Object.create(null);
	        else {
	          delete events[type];
	          if (events.removeListener)
	            this.emit('removeListener', type, list.listener || listener);
	        }
	      } else if (typeof list !== 'function') {
	        position = -1;

	        for (i = list.length - 1; i >= 0; i--) {
	          if (list[i] === listener || list[i].listener === listener) {
	            originalListener = list[i].listener;
	            position = i;
	            break;
	          }
	        }

	        if (position < 0)
	          return this;

	        if (position === 0)
	          list.shift();
	        else {
	          spliceOne$1(list, position);
	        }

	        if (list.length === 1)
	          events[type] = list[0];

	        if (events.removeListener !== undefined)
	          this.emit('removeListener', type, originalListener || listener);
	      }

	      return this;
	    };

	EventEmitter$1$1.prototype.off = EventEmitter$1$1.prototype.removeListener;

	EventEmitter$1$1.prototype.removeAllListeners =
	    function removeAllListeners(type) {
	      var listeners, events, i;

	      events = this._events;
	      if (events === undefined)
	        return this;

	      // not listening for removeListener, no need to emit
	      if (events.removeListener === undefined) {
	        if (arguments.length === 0) {
	          this._events = Object.create(null);
	          this._eventsCount = 0;
	        } else if (events[type] !== undefined) {
	          if (--this._eventsCount === 0)
	            this._events = Object.create(null);
	          else
	            delete events[type];
	        }
	        return this;
	      }

	      // emit removeListener for all listeners on all events
	      if (arguments.length === 0) {
	        var keys = Object.keys(events);
	        var key;
	        for (i = 0; i < keys.length; ++i) {
	          key = keys[i];
	          if (key === 'removeListener') continue;
	          this.removeAllListeners(key);
	        }
	        this.removeAllListeners('removeListener');
	        this._events = Object.create(null);
	        this._eventsCount = 0;
	        return this;
	      }

	      listeners = events[type];

	      if (typeof listeners === 'function') {
	        this.removeListener(type, listeners);
	      } else if (listeners !== undefined) {
	        // LIFO order
	        for (i = listeners.length - 1; i >= 0; i--) {
	          this.removeListener(type, listeners[i]);
	        }
	      }

	      return this;
	    };

	function _listeners$1(target, type, unwrap) {
	  var events = target._events;

	  if (events === undefined)
	    return [];

	  var evlistener = events[type];
	  if (evlistener === undefined)
	    return [];

	  if (typeof evlistener === 'function')
	    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

	  return unwrap ?
	    unwrapListeners$1(evlistener) : arrayClone$1(evlistener, evlistener.length);
	}

	EventEmitter$1$1.prototype.listeners = function listeners(type) {
	  return _listeners$1(this, type, true);
	};

	EventEmitter$1$1.prototype.rawListeners = function rawListeners(type) {
	  return _listeners$1(this, type, false);
	};

	EventEmitter$1$1.listenerCount = function(emitter, type) {
	  if (typeof emitter.listenerCount === 'function') {
	    return emitter.listenerCount(type);
	  } else {
	    return listenerCount$1.call(emitter, type);
	  }
	};

	EventEmitter$1$1.prototype.listenerCount = listenerCount$1;
	function listenerCount$1(type) {
	  var events = this._events;

	  if (events !== undefined) {
	    var evlistener = events[type];

	    if (typeof evlistener === 'function') {
	      return 1;
	    } else if (evlistener !== undefined) {
	      return evlistener.length;
	    }
	  }

	  return 0;
	}

	EventEmitter$1$1.prototype.eventNames = function eventNames() {
	  return this._eventsCount > 0 ? ReflectOwnKeys$1(this._events) : [];
	};

	function arrayClone$1(arr, n) {
	  var copy = new Array(n);
	  for (var i = 0; i < n; ++i)
	    copy[i] = arr[i];
	  return copy;
	}

	function spliceOne$1(list, index) {
	  for (; index + 1 < list.length; index++)
	    list[index] = list[index + 1];
	  list.pop();
	}

	function unwrapListeners$1(arr) {
	  var ret = new Array(arr.length);
	  for (var i = 0; i < ret.length; ++i) {
	    ret[i] = arr[i].listener || arr[i];
	  }
	  return ret;
	}

	function once$1(emitter, name) {
	  return new Promise(function (resolve, reject) {
	    function errorListener(err) {
	      emitter.removeListener(name, resolver);
	      reject(err);
	    }

	    function resolver() {
	      if (typeof emitter.removeListener === 'function') {
	        emitter.removeListener('error', errorListener);
	      }
	      resolve([].slice.call(arguments));
	    }
	    eventTargetAgnosticAddListener$1(emitter, name, resolver, { once: true });
	    if (name !== 'error') {
	      addErrorHandlerIfEventEmitter$1(emitter, errorListener, { once: true });
	    }
	  });
	}

	function addErrorHandlerIfEventEmitter$1(emitter, handler, flags) {
	  if (typeof emitter.on === 'function') {
	    eventTargetAgnosticAddListener$1(emitter, 'error', handler, flags);
	  }
	}

	function eventTargetAgnosticAddListener$1(emitter, name, listener, flags) {
	  if (typeof emitter.on === 'function') {
	    if (flags.once) {
	      emitter.once(name, listener);
	    } else {
	      emitter.on(name, listener);
	    }
	  } else if (typeof emitter.addEventListener === 'function') {
	    // EventTarget does not have `error` event semantics like Node
	    // EventEmitters, we do not listen for `error` events here.
	    emitter.addEventListener(name, function wrapListener(arg) {
	      // IE does not have builtin `{ once: true }` support so we
	      // have to do it manually.
	      if (flags.once) {
	        emitter.removeEventListener(name, wrapListener);
	      }
	      listener(arg);
	    });
	  } else {
	    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
	  }
	}

	Object.defineProperty(dist$2, '__esModule', { value: true });

	var EventEmitter$2 = events$1.exports;

	function _interopDefaultLegacy$2 (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var EventEmitter__default$1 = /*#__PURE__*/_interopDefaultLegacy$2(EventEmitter$2);

	const __RΦ$r$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$r$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$r$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$r$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [95]: { LΦ: t => SyntaxError }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Обработчик синтаксической ошибки в коде source.
	 * @param error
	 * @param source
	 */
	function syntaxErrorHandler$1(error, source) {
	    console.group('Синтаксическая ошибка');
	    console.log(error.message);
	    console.log(source);
	    console.log(error.stack);
	    console.groupEnd();
	}
	__RΦ$r$1.m("rt:p", [{ n: "error", t: () => __RΦ$r$1.a(95), v: null }, { n: "source", t: () => __RΦ$r$1.a(14), v: null }])(syntaxErrorHandler$1);
	__RΦ$r$1.m("rt:f", "F")(syntaxErrorHandler$1);
	__RΦ$r$1.m("rt:t", () => __RΦ$r$1.a(23))(syntaxErrorHandler$1);

	const __RΦ$q$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$q$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$q$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$q$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [112]: { LΦ: t => Object } } };
	/**
	 * Выполнить скрипт из текста, который возвращает значение типа T.
	 * @param source
	 */
	function execFunctionScript$1(source) {
	    if (!source.trim()) {
	        throw new Error('Не задано тело функции');
	    }
	    try {
	        const code = new Function('', `return (${source})`);
	        return code();
	    }
	    catch (error) {
	        if (error instanceof SyntaxError) {
	            syntaxErrorHandler$1(error, source);
	        }
	        throw error;
	    }
	}
	__RΦ$q$1.m("rt:p", [{ n: "source", t: () => __RΦ$q$1.a(14), v: null }])(execFunctionScript$1);
	__RΦ$q$1.m("rt:f", "F")(execFunctionScript$1);
	__RΦ$q$1.m("rt:t", () => __RΦ$q$1.a(112))(execFunctionScript$1);

	const __RΦ$p$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$p$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$p$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$p$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [113]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$p$1.a(10), __RΦ$p$1.a(14)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Выполнить скрипт из текста, который ничего не возвращает.
	 * @param source
	 */
	function execActionScript$1(source) {
	    if (source) {
	        try {
	            const code = new Function('', source);
	            code();
	        }
	        catch (error) {
	            if (error instanceof SyntaxError) {
	                syntaxErrorHandler$1(error, source);
	            }
	            throw error;
	        }
	    }
	}
	__RΦ$p$1.m("rt:p", [{ n: "source", t: () => __RΦ$p$1.a(113), v: null }])(execActionScript$1);
	__RΦ$p$1.m("rt:f", "F")(execActionScript$1);
	__RΦ$p$1.m("rt:t", () => __RΦ$p$1.a(23))(execActionScript$1);

	const __RΦ$o$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$o$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$o$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$o$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String } } };
	const SPACE$1 = ' ';
	const EOL$1 = '\n';
	const trim$1 = __RΦ$o$1.f((message) => message.trim()
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	, [__RΦ$o$1.m("rt:p", [{ n: "message", t: () => __RΦ$o$1.a(14), v: null }]), __RΦ$o$1.m("rt:f", "F>"), __RΦ$o$1.m("rt:t", () => __RΦ$o$1.a(14))], "trim");
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	function toOneLine$1(message) {
	    return message.trim().split(EOL$1).map(trim$1).join(SPACE$1);
	}
	__RΦ$o$1.m("rt:p", [{ n: "message", t: () => __RΦ$o$1.a(14), v: null }])(toOneLine$1);
	__RΦ$o$1.m("rt:f", "F")(toOneLine$1);
	__RΦ$o$1.m("rt:t", () => __RΦ$o$1.a(14))(toOneLine$1);

	const __RΦ$n$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$n$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$n$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$n$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1]: { RΦ: t => ({ TΦ: "~" }) } } };
	function isBrowser$1() {
	    return new Function('try { return this === window } catch (e) { return false }')();
	}
	__RΦ$n$1.m("rt:p", [])(isBrowser$1);
	__RΦ$n$1.m("rt:f", "F")(isBrowser$1);
	__RΦ$n$1.m("rt:t", () => __RΦ$n$1.a(1))(isBrowser$1);

	const __RΦ$m$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$m$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$m$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$m$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [21]: { LΦ: t => Boolean } } };
	var IΦdefault$9$1 = { name: "IStoppable", prototype: {}, identity: Symbol("IStoppable (interface)") };
	(t => __RΦ$m$1.t[150] = t)(IΦdefault$9$1);
	__RΦ$m$1.m("rt:P", [])(IΦdefault$9$1);
	__RΦ$m$1.m("rt:m", ["stop"])(IΦdefault$9$1);
	__RΦ$m$1.m("rt:f", "Ie")(IΦdefault$9$1);
	__RΦ$m$1.m("rt:p", [])(IΦdefault$9$1.prototype, "stop");
	__RΦ$m$1.m("rt:f", "M")(IΦdefault$9$1.prototype, "stop");
	__RΦ$m$1.m("rt:t", () => __RΦ$m$1.a(23))(IΦdefault$9$1.prototype, "stop");
	__RΦ$m$1.m("rt:p", [])(IΦdefault$9$1.prototype, "stop");
	__RΦ$m$1.m("rt:f", "M")(IΦdefault$9$1.prototype, "stop");
	__RΦ$m$1.m("rt:t", () => __RΦ$m$1.a(23))(IΦdefault$9$1.prototype, "stop");
	function isStoppable$1(object) {
	    return 'stop' in object && typeof object.stop === 'function';
	}
	__RΦ$m$1.m("rt:p", [{ n: "object", t: () => __RΦ$m$1.a(1), v: null }])(isStoppable$1);
	__RΦ$m$1.m("rt:f", "F")(isStoppable$1);
	__RΦ$m$1.m("rt:t", () => __RΦ$m$1.a(21))(isStoppable$1);

	const __RΦ$l$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$l$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$l$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$l$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$8$1 = { name: "IStartable", prototype: {}, identity: Symbol("IStartable (interface)") };
	(t => __RΦ$l$1.t[149] = t)(IΦdefault$8$1);
	__RΦ$l$1.m("rt:P", [])(IΦdefault$8$1);
	__RΦ$l$1.m("rt:m", ["start"])(IΦdefault$8$1);
	__RΦ$l$1.m("rt:f", "Ie")(IΦdefault$8$1);
	__RΦ$l$1.m("rt:p", [])(IΦdefault$8$1.prototype, "start");
	__RΦ$l$1.m("rt:f", "M")(IΦdefault$8$1.prototype, "start");
	__RΦ$l$1.m("rt:t", () => __RΦ$l$1.a(23))(IΦdefault$8$1.prototype, "start");
	__RΦ$l$1.m("rt:p", [])(IΦdefault$8$1.prototype, "start");
	__RΦ$l$1.m("rt:f", "M")(IΦdefault$8$1.prototype, "start");
	__RΦ$l$1.m("rt:t", () => __RΦ$l$1.a(23))(IΦdefault$8$1.prototype, "start");

	/**
	 * Состояния таймера.
	 */
	var ETimerState$1;
	(function (ETimerState) {
	    ETimerState["Started"] = "started";
	    ETimerState["Paused"] = "paused";
	    ETimerState["Stopped"] = "stopped";
	})(ETimerState$1 || (ETimerState$1 = {}));

	const __RΦ$k$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$k$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$k$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$k$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [666]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$k$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [667]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$k$1.a(4) }] }) }, [668]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$k$1.a(4) }] }) } } };
	var IΦdefault$7$1 = { name: "IStateHandlers", prototype: {}, identity: Symbol("IStateHandlers (interface)") };
	(t => __RΦ$k$1.t[669] = t)(IΦdefault$7$1);
	__RΦ$k$1.m("rt:P", ["started", "paused", "stopped"])(IΦdefault$7$1);
	__RΦ$k$1.m("rt:m", [])(IΦdefault$7$1);
	__RΦ$k$1.m("rt:f", "Ie")(IΦdefault$7$1);
	__RΦ$k$1.m("rt:t", () => __RΦ$k$1.a(666))(IΦdefault$7$1.prototype, "started");
	__RΦ$k$1.m("rt:f", "P?")(IΦdefault$7$1.prototype, "started");
	__RΦ$k$1.m("rt:t", () => __RΦ$k$1.a(667))(IΦdefault$7$1.prototype, "paused");
	__RΦ$k$1.m("rt:f", "P?")(IΦdefault$7$1.prototype, "paused");
	__RΦ$k$1.m("rt:t", () => __RΦ$k$1.a(668))(IΦdefault$7$1.prototype, "stopped");
	__RΦ$k$1.m("rt:f", "P?")(IΦdefault$7$1.prototype, "stopped");
	__RΦ$k$1.m("rt:t", () => __RΦ$k$1.a(666))(IΦdefault$7$1.prototype, "started");
	__RΦ$k$1.m("rt:f", "P?")(IΦdefault$7$1.prototype, "started");
	__RΦ$k$1.m("rt:t", () => __RΦ$k$1.a(667))(IΦdefault$7$1.prototype, "paused");
	__RΦ$k$1.m("rt:f", "P?")(IΦdefault$7$1.prototype, "paused");
	__RΦ$k$1.m("rt:t", () => __RΦ$k$1.a(668))(IΦdefault$7$1.prototype, "stopped");
	__RΦ$k$1.m("rt:f", "P?")(IΦdefault$7$1.prototype, "stopped");

	const __RΦ$j$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$j$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$j$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$j$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [689]: { RΦ: t => ({ TΦ: "e", e: ETimerState$1 }) }, [673]: { RΦ: t => ({ TΦ: "g", t: __RΦ$j$1.a(669), p: [__RΦ$j$1.a(672)] }) }, [669]: { LΦ: t => IΦdefault$7$1 }, [672]: { LΦ: t => Object }, [690]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$j$1.a(10), __RΦ$j$1.a(672)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	/**
	 * Запустить определенный скрипт в зависимости от состояния таймера.
	 * @param state Текущее состояние таймера.
	 * @param stateHandlers Массив скриптов (ключ - имя состояния, значение - скрипт).
	 */
	function handleByState$1(state, stateHandlers) {
	    switch (state) {
	        case ETimerState$1.Started: return stateHandlers.started ? stateHandlers.started() : undefined;
	        case ETimerState$1.Paused: return stateHandlers.paused ? stateHandlers.paused() : undefined;
	        case ETimerState$1.Stopped: return stateHandlers.stopped ? stateHandlers.stopped() : undefined;
	    }
	}
	__RΦ$j$1.m("rt:p", [{ n: "state", t: () => __RΦ$j$1.a(689), v: null }, { n: "stateHandlers", t: () => __RΦ$j$1.a(673), v: null }])(handleByState$1);
	__RΦ$j$1.m("rt:f", "F")(handleByState$1);
	__RΦ$j$1.m("rt:t", () => __RΦ$j$1.a(690))(handleByState$1);

	const __RΦ$i$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$i$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$i$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$i$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [1603]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$i$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1551]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$i$1.a(10), __RΦ$i$1.a(15)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [689]: { RΦ: t => ({ TΦ: "e", e: ETimerState$1 }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Простая реализация таймера.
	 */
	class Timer$1 {
	    timeout;
	    action;
	    timerId;
	    /**
	     * Время запуска таймера. В миллисекундах.
	     * @private
	     */
	    time = 0;
	    /**
	     * Время постановки на паузу. В миллисекундах.
	     * @private
	     */
	    pauseTime = 0;
	    /**
	     * Общее время остановки таймера. В миллисекундах.
	     * @private
	     */
	    pauseInterval = 0;
	    /**
	     * Текущее состояние таймера
	     * @private
	     */
	    state = ETimerState$1.Stopped;
	    /**
	     * Внимание, внутри action определена this как Timer.
	     * @param timeout
	     * @param action
	     */
	    constructor(timeout, action) {
	        this.timeout = timeout;
	        this.action = action;
	    }
	    /**
	     * Запуск таймера.
	     * Стартовать таймер сначала или продолжить с паузы.
	     */
	    start() {
	        handleByState$1(this.state, {
	            paused: __RΦ$i$1.f(() => {
	                this.state = ETimerState$1.Started;
	                this.pauseInterval += Date.now() - this.pauseTime;
	            }, [__RΦ$i$1.m("rt:p", []), __RΦ$i$1.m("rt:f", "F>"), __RΦ$i$1.m("rt:t", () => __RΦ$i$1.a(23))], "paused"),
	            stopped: __RΦ$i$1.f(() => {
	                this.state = ETimerState$1.Started;
	                this.timerId = window.setInterval(this.tick.bind(this), this.timeout);
	                this.time = Date.now();
	            }, [__RΦ$i$1.m("rt:p", []), __RΦ$i$1.m("rt:f", "F>"), __RΦ$i$1.m("rt:t", () => __RΦ$i$1.a(23))], "stopped")
	        });
	    }
	    /**
	     * Поставить на паузу таймер.
	     * Состояние сохраняется, счет приостанавливается.
	     */
	    pause() {
	        handleByState$1(this.state, {
	            started: __RΦ$i$1.f(() => {
	                this.state = ETimerState$1.Paused;
	                this.pauseTime = Date.now();
	            }, [__RΦ$i$1.m("rt:p", []), __RΦ$i$1.m("rt:f", "F>"), __RΦ$i$1.m("rt:t", () => __RΦ$i$1.a(23))], "started")
	        });
	    }
	    /**
	     * Остановить таймер.
	     * Полный сброс таймера.
	     */
	    stop() {
	        const stop = __RΦ$i$1.f(() => {
	            this.state = ETimerState$1.Stopped;
	            clearInterval(this.timerId);
	            this.timerId = undefined;
	            this.time = 0;
	        }, [__RΦ$i$1.m("rt:p", []), __RΦ$i$1.m("rt:f", "F>"), __RΦ$i$1.m("rt:t", () => __RΦ$i$1.a(23))], "stop");
	        handleByState$1(this.state, {
	            started: stop,
	            paused: stop
	        });
	    }
	    /**
	     * Количество миллисекунд с начала старта таймера.
	     * С учетом всех пауз.
	     */
	    get interval() {
	        const result = handleByState$1(this.state, {
	            started: () => Date.now() - this.time - this.pauseTime,
	            paused: () => this.time - this.pauseTime,
	            stopped: () => 0
	        });
	        return result === undefined ? 0 : result;
	    }
	    /**
	     * Выполняемая нагрузка таймера.
	     * @private
	     */
	    tick() {
	        handleByState$1(this.state, {
	            started: __RΦ$i$1.f(() => this.action.call(this), [__RΦ$i$1.m("rt:p", []), __RΦ$i$1.m("rt:f", "F>"), __RΦ$i$1.m("rt:t", () => __RΦ$i$1.a(23))], "started")
	        });
	    }
	}
	(t => __RΦ$i$1.t[692] = t)(Timer$1);
	__RΦ$i$1.m("rt:SP", [])(Timer$1);
	__RΦ$i$1.m("rt:P", ["timerId", "time", "pauseTime", "pauseInterval", "state", "timeout", "action", "interval"])(Timer$1);
	__RΦ$i$1.m("rt:Sm", [])(Timer$1);
	__RΦ$i$1.m("rt:m", ["start", "pause", "stop", "tick"])(Timer$1);
	__RΦ$i$1.m("rt:p", [{ n: "timeout", t: () => __RΦ$i$1.a(15), v: null, f: "#" }, { n: "action", t: () => __RΦ$i$1.a(1603), v: null, f: "#" }])(Timer$1);
	__RΦ$i$1.m("rt:i", [() => undefined, () => undefined])(Timer$1);
	__RΦ$i$1.m("rt:f", "Ce")(Timer$1);
	__RΦ$i$1.m("rt:t", () => __RΦ$i$1.a(1551))(Timer$1.prototype, "timerId");
	__RΦ$i$1.m("rt:f", "P#")(Timer$1.prototype, "timerId");
	__RΦ$i$1.m("rt:t", () => __RΦ$i$1.a(15))(Timer$1.prototype, "time");
	__RΦ$i$1.m("rt:f", "P#")(Timer$1.prototype, "time");
	__RΦ$i$1.m("rt:t", () => __RΦ$i$1.a(15))(Timer$1.prototype, "pauseTime");
	__RΦ$i$1.m("rt:f", "P#")(Timer$1.prototype, "pauseTime");
	__RΦ$i$1.m("rt:t", () => __RΦ$i$1.a(15))(Timer$1.prototype, "pauseInterval");
	__RΦ$i$1.m("rt:f", "P#")(Timer$1.prototype, "pauseInterval");
	__RΦ$i$1.m("rt:t", () => __RΦ$i$1.a(689))(Timer$1.prototype, "state");
	__RΦ$i$1.m("rt:f", "P#")(Timer$1.prototype, "state");
	__RΦ$i$1.m("rt:f", "M$.")(Timer$1.prototype["start"]);
	((t, p) => __RΦ$i$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$1.prototype, "start");
	__RΦ$i$1.m("rt:p", [])(Timer$1.prototype, "start");
	__RΦ$i$1.m("rt:f", "M$.")(Timer$1.prototype, "start");
	__RΦ$i$1.m("rt:t", () => __RΦ$i$1.a(23))(Timer$1.prototype, "start");
	__RΦ$i$1.m("rt:f", "M$.")(Timer$1.prototype["pause"]);
	((t, p) => __RΦ$i$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$1.prototype, "pause");
	__RΦ$i$1.m("rt:p", [])(Timer$1.prototype, "pause");
	__RΦ$i$1.m("rt:f", "M$.")(Timer$1.prototype, "pause");
	__RΦ$i$1.m("rt:t", () => __RΦ$i$1.a(23))(Timer$1.prototype, "pause");
	__RΦ$i$1.m("rt:f", "M$.")(Timer$1.prototype["stop"]);
	((t, p) => __RΦ$i$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$1.prototype, "stop");
	__RΦ$i$1.m("rt:p", [])(Timer$1.prototype, "stop");
	__RΦ$i$1.m("rt:f", "M$.")(Timer$1.prototype, "stop");
	__RΦ$i$1.m("rt:t", () => __RΦ$i$1.a(23))(Timer$1.prototype, "stop");
	__RΦ$i$1.m("rt:t", () => __RΦ$i$1.a(15))(Timer$1.prototype, "interval");
	__RΦ$i$1.m("rt:f", "P$")(Timer$1.prototype, "interval");
	__RΦ$i$1.m("rt:f", "M#.")(Timer$1.prototype["tick"]);
	((t, p) => __RΦ$i$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer$1.prototype, "tick");
	__RΦ$i$1.m("rt:p", [])(Timer$1.prototype, "tick");
	__RΦ$i$1.m("rt:f", "M#.")(Timer$1.prototype, "tick");
	__RΦ$i$1.m("rt:t", () => __RΦ$i$1.a(23))(Timer$1.prototype, "tick");

	const __RΦ$h$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$h$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$h$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$h$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1607]: { LΦ: t => Object } } };
	var IΦdefault$6$1 = { name: "ICreator", prototype: {}, identity: Symbol("ICreator (interface)") };
	(t => __RΦ$h$1.t[1608] = t)(IΦdefault$6$1);
	__RΦ$h$1.m("rt:P", [])(IΦdefault$6$1);
	__RΦ$h$1.m("rt:m", ["create"])(IΦdefault$6$1);
	__RΦ$h$1.m("rt:f", "Ie")(IΦdefault$6$1);
	__RΦ$h$1.m("rt:p", [])(IΦdefault$6$1.prototype, "create");
	__RΦ$h$1.m("rt:f", "M")(IΦdefault$6$1.prototype, "create");
	__RΦ$h$1.m("rt:t", () => __RΦ$h$1.a(1607))(IΦdefault$6$1.prototype, "create");
	__RΦ$h$1.m("rt:p", [])(IΦdefault$6$1.prototype, "create");
	__RΦ$h$1.m("rt:f", "M")(IΦdefault$6$1.prototype, "create");
	__RΦ$h$1.m("rt:t", () => __RΦ$h$1.a(1607))(IΦdefault$6$1.prototype, "create");

	const __RΦ$g$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$g$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$g$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$g$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1610]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$g$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1618]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$g$1.a(10), __RΦ$g$1.a(1612)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1612]: { LΦ: t => Object }, [1615]: { RΦ: t => ({ TΦ: "g", t: __RΦ$g$1.a(1608), p: [__RΦ$g$1.a(1612)] }) }, [1608]: { LΦ: t => IΦdefault$6$1 } } };
	/**
	 * Отложенная инициализация.
	 * @link https://metanit.com/sharp/tutorial/20.1.php
	 * @link https://docs.microsoft.com/ru-ru/dotnet/api/system.lazy-1?view=net-5.0
	 */
	class Lazy$1 {
	    createFn;
	    #value;
	    #creator;
	    constructor(createFn) {
	        this.createFn = createFn;
	        this.#creator = {
	            create() {
	                return createFn();
	            }
	        };
	    }
	    get value() {
	        if (!this.#value) {
	            this.#value = this.#creator.create();
	        }
	        return this.#value;
	    }
	}
	(t => __RΦ$g$1.t[1611] = t)(Lazy$1);
	__RΦ$g$1.m("rt:SP", [])(Lazy$1);
	__RΦ$g$1.m("rt:P", ["#value", "#creator", "createFn", "value"])(Lazy$1);
	__RΦ$g$1.m("rt:Sm", [])(Lazy$1);
	__RΦ$g$1.m("rt:m", [])(Lazy$1);
	__RΦ$g$1.m("rt:p", [{ n: "createFn", t: () => __RΦ$g$1.a(1610), v: null, f: "#" }])(Lazy$1);
	__RΦ$g$1.m("rt:f", "Ce")(Lazy$1);
	__RΦ$g$1.m("rt:t", () => __RΦ$g$1.a(1618))(Lazy$1.prototype, "#value");
	__RΦ$g$1.m("rt:f", "P")(Lazy$1.prototype, "#value");
	__RΦ$g$1.m("rt:t", () => __RΦ$g$1.a(1615))(Lazy$1.prototype, "#creator");
	__RΦ$g$1.m("rt:f", "P")(Lazy$1.prototype, "#creator");
	__RΦ$g$1.m("rt:t", () => __RΦ$g$1.a(1612))(Lazy$1.prototype, "value");
	__RΦ$g$1.m("rt:f", "P")(Lazy$1.prototype, "value");

	const __RΦ$f$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$f$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$f$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$f$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	var IΦdefault$5$1 = { name: "IPoint", prototype: {}, identity: Symbol("IPoint (interface)") };
	(t => __RΦ$f$1.t[141] = t)(IΦdefault$5$1);
	__RΦ$f$1.m("rt:P", ["x", "y"])(IΦdefault$5$1);
	__RΦ$f$1.m("rt:m", [])(IΦdefault$5$1);
	__RΦ$f$1.m("rt:f", "Ie")(IΦdefault$5$1);
	__RΦ$f$1.m("rt:t", () => __RΦ$f$1.a(15))(IΦdefault$5$1.prototype, "x");
	__RΦ$f$1.m("rt:f", "P")(IΦdefault$5$1.prototype, "x");
	__RΦ$f$1.m("rt:t", () => __RΦ$f$1.a(15))(IΦdefault$5$1.prototype, "y");
	__RΦ$f$1.m("rt:f", "P")(IΦdefault$5$1.prototype, "y");
	__RΦ$f$1.m("rt:t", () => __RΦ$f$1.a(15))(IΦdefault$5$1.prototype, "x");
	__RΦ$f$1.m("rt:f", "P")(IΦdefault$5$1.prototype, "x");
	__RΦ$f$1.m("rt:t", () => __RΦ$f$1.a(15))(IΦdefault$5$1.prototype, "y");
	__RΦ$f$1.m("rt:f", "P")(IΦdefault$5$1.prototype, "y");

	const __RΦ$e$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$e$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$e$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$e$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [141]: { LΦ: t => IΦdefault$5$1 }, [1627]: { TΦ: "5", name: "default" }, [21]: { LΦ: t => Boolean }, [1636]: { RΦ: t => ({ TΦ: "[", e: __RΦ$e$1.a(15) }) }, [14]: { LΦ: t => String } } };
	/*
	 * Увеличить длину вектора можно так:
	 * Vector.translate(Vector.identity.scale(length))
	 *
	 */
	/**
	 * Вектор.
	 * @unmutable
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/vector/Vector.js
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/Point.js
	 */
	class Vector$1 {
	    x;
	    y;
	    /**
	     * Расстояние от начала координат до точки.
	     */
	    static distance(point) {
	        // noinspection JSSuspiciousNameCombination
	        return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
	    }
	    /**
	     * Создать вектор на основе угла и длины.
	     */
	    static create(angle, length) {
	        return new Vector$1(length * Math.cos(angle), length * Math.sin(angle));
	    }
	    /**
	     * Угол между вектором и положительной осью.
	     * Принимает значение от -Math.PI до Math.PI радиан.
	     */
	    get angle() {
	        return Math.atan2(this.y, this.x);
	    }
	    /**
	     * Модуль (длина) вектора.
	     */
	    get length() {
	        return Vector$1.distance(this);
	    }
	    /**
	     * Возвращает true, если вектор является нулевым.
	     */
	    get isNull() {
	        return this.x === 0 && this.y === 0;
	    }
	    /**
	     * Конструктор вектора.
	     * @param x
	     * @param y
	     */
	    constructor(x = 0, y = 0) {
	        this.x = x;
	        this.y = y;
	    }
	    /**
	     * Получить единичный вектор, равный по направлению исходному.
	     * Он же направляющий вектор (единичный, равный по направлению).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get identity() {
	        return (new Vector$1(Math.cos(this.angle), Math.sin(this.angle)));
	    }
	    /**
	     * Получить обратный вектор (инверсия вектора).
	     */
	    get inverse() {
	        return new Vector$1(-this.x, -this.y);
	    }
	    /**
	     * Нормаль вектора (единичный вектор, перпендикулярный исходному).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get normal() {
	        return this.clone().rotate(Math.PI / 2).identity;
	        // TODO Проверить эту формулу нахождения перпендикулярного вектора.
	        /*
	            a: 1 / parallel.x(),
	            b: -1 / parallel.y(),
	        */
	    }
	    /**
	     * Сложение векторов.
	     * @param vector
	     */
	    translate(vector) {
	        return new Vector$1(this.x + vector.x, this.y + vector.y);
	    }
	    /**
	     * Вращение вектора.
	     * @param angle
	     */
	    rotate(angle) {
	        return new Vector$1(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle));
	    }
	    /**
	     * Умножение вектора на число.
	     */
	    scale(scale) {
	        return new Vector$1(this.x * scale, this.y * scale);
	    }
	    /**
	     * Скалярное произведение векторов.
	     * @param vector
	     */
	    multiply(vector) {
	        return new Vector$1(this.x * vector.x, this.y * vector.y);
	    }
	    /**
	     * Взятие остатка от деления.
	     * @param vector
	     */
	    mod(vector) {
	        return new Vector$1(this.x % vector.x, this.y % vector.y);
	    }
	    clone() {
	        return new Vector$1(this.x, this.y);
	    }
	    toArray() {
	        return [this.x, this.y];
	    }
	    toString(digits = 2) {
	        return `[${this.x.toFixed(digits)}, ${this.y.toFixed(digits)}]`;
	    }
	}
	(t => __RΦ$e$1.t[1627] = t)(Vector$1);
	__RΦ$e$1.m("rt:SP", [])(Vector$1);
	__RΦ$e$1.m("rt:P", ["angle", "length", "isNull", "x", "y", "identity", "inverse", "normal"])(Vector$1);
	__RΦ$e$1.m("rt:Sm", ["distance", "create"])(Vector$1);
	__RΦ$e$1.m("rt:m", ["translate", "rotate", "scale", "multiply", "mod", "clone", "toArray", "toString"])(Vector$1);
	__RΦ$e$1.m("rt:p", [{ n: "x", t: () => __RΦ$e$1.a(15), v: function () { return 0; }, f: "$R" }, { n: "y", t: () => __RΦ$e$1.a(15), v: function () { return 0; }, f: "$R" }])(Vector$1);
	__RΦ$e$1.m("rt:i", [() => undefined])(Vector$1);
	__RΦ$e$1.m("rt:f", "Ce")(Vector$1);
	__RΦ$e$1.m("rt:f", "M$S")(Vector$1["distance"]);
	((t, p) => __RΦ$e$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1, "distance");
	__RΦ$e$1.m("rt:p", [{ n: "point", t: () => __RΦ$e$1.a(141), v: null }])(Vector$1, "distance");
	__RΦ$e$1.m("rt:f", "M$S")(Vector$1, "distance");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(15))(Vector$1, "distance");
	__RΦ$e$1.m("rt:f", "M$S")(Vector$1["create"]);
	((t, p) => __RΦ$e$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1, "create");
	__RΦ$e$1.m("rt:p", [{ n: "angle", t: () => __RΦ$e$1.a(15), v: null }, { n: "length", t: () => __RΦ$e$1.a(15), v: null }])(Vector$1, "create");
	__RΦ$e$1.m("rt:f", "M$S")(Vector$1, "create");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(1627))(Vector$1, "create");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(15))(Vector$1.prototype, "angle");
	__RΦ$e$1.m("rt:f", "P$")(Vector$1.prototype, "angle");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(15))(Vector$1.prototype, "length");
	__RΦ$e$1.m("rt:f", "P$")(Vector$1.prototype, "length");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(21))(Vector$1.prototype, "isNull");
	__RΦ$e$1.m("rt:f", "P$")(Vector$1.prototype, "isNull");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(1627))(Vector$1.prototype, "identity");
	__RΦ$e$1.m("rt:f", "P$")(Vector$1.prototype, "identity");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(1627))(Vector$1.prototype, "inverse");
	__RΦ$e$1.m("rt:f", "P$")(Vector$1.prototype, "inverse");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(1627))(Vector$1.prototype, "normal");
	__RΦ$e$1.m("rt:f", "P$")(Vector$1.prototype, "normal");
	__RΦ$e$1.m("rt:f", "M$")(Vector$1.prototype["translate"]);
	((t, p) => __RΦ$e$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1.prototype, "translate");
	__RΦ$e$1.m("rt:p", [{ n: "vector", t: () => __RΦ$e$1.a(1627), v: null }])(Vector$1.prototype, "translate");
	__RΦ$e$1.m("rt:f", "M$")(Vector$1.prototype, "translate");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(1627))(Vector$1.prototype, "translate");
	__RΦ$e$1.m("rt:f", "M$.")(Vector$1.prototype["rotate"]);
	((t, p) => __RΦ$e$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1.prototype, "rotate");
	__RΦ$e$1.m("rt:p", [{ n: "angle", t: () => __RΦ$e$1.a(15), v: null }])(Vector$1.prototype, "rotate");
	__RΦ$e$1.m("rt:f", "M$.")(Vector$1.prototype, "rotate");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(1627))(Vector$1.prototype, "rotate");
	__RΦ$e$1.m("rt:f", "M$.")(Vector$1.prototype["scale"]);
	((t, p) => __RΦ$e$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1.prototype, "scale");
	__RΦ$e$1.m("rt:p", [{ n: "scale", t: () => __RΦ$e$1.a(15), v: null }])(Vector$1.prototype, "scale");
	__RΦ$e$1.m("rt:f", "M$.")(Vector$1.prototype, "scale");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(1627))(Vector$1.prototype, "scale");
	__RΦ$e$1.m("rt:f", "M$")(Vector$1.prototype["multiply"]);
	((t, p) => __RΦ$e$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1.prototype, "multiply");
	__RΦ$e$1.m("rt:p", [{ n: "vector", t: () => __RΦ$e$1.a(1627), v: null }])(Vector$1.prototype, "multiply");
	__RΦ$e$1.m("rt:f", "M$")(Vector$1.prototype, "multiply");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(1627))(Vector$1.prototype, "multiply");
	__RΦ$e$1.m("rt:f", "M$")(Vector$1.prototype["mod"]);
	((t, p) => __RΦ$e$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1.prototype, "mod");
	__RΦ$e$1.m("rt:p", [{ n: "vector", t: () => __RΦ$e$1.a(1627), v: null }])(Vector$1.prototype, "mod");
	__RΦ$e$1.m("rt:f", "M$")(Vector$1.prototype, "mod");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(1627))(Vector$1.prototype, "mod");
	__RΦ$e$1.m("rt:f", "M$.")(Vector$1.prototype["clone"]);
	((t, p) => __RΦ$e$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1.prototype, "clone");
	__RΦ$e$1.m("rt:p", [])(Vector$1.prototype, "clone");
	__RΦ$e$1.m("rt:f", "M$.")(Vector$1.prototype, "clone");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(1627))(Vector$1.prototype, "clone");
	__RΦ$e$1.m("rt:f", "M$.")(Vector$1.prototype["toArray"]);
	((t, p) => __RΦ$e$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1.prototype, "toArray");
	__RΦ$e$1.m("rt:p", [])(Vector$1.prototype, "toArray");
	__RΦ$e$1.m("rt:f", "M$.")(Vector$1.prototype, "toArray");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(1636))(Vector$1.prototype, "toArray");
	__RΦ$e$1.m("rt:f", "M$.")(Vector$1.prototype["toString"]);
	((t, p) => __RΦ$e$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector$1.prototype, "toString");
	__RΦ$e$1.m("rt:p", [{ n: "digits", t: () => __RΦ$e$1.a(15), v: function () { return 2; } }])(Vector$1.prototype, "toString");
	__RΦ$e$1.m("rt:f", "M$.")(Vector$1.prototype, "toString");
	__RΦ$e$1.m("rt:t", () => __RΦ$e$1.a(14))(Vector$1.prototype, "toString");

	const __RΦ$d$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$d$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$d$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$d$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	class Angle$1 {
	    /**
	     * Конвертация угла из радиан в градусы.
	     * @param value
	     */
	    static toDegree(value) {
	        return value / Math.PI * 180;
	    }
	    /**
	     * Конвертация угла из градусов в радианы.
	     * @param value
	     */
	    static toRadian(value) {
	        return value * Math.PI / 180;
	    }
	}
	(t => __RΦ$d$1.t[1638] = t)(Angle$1);
	__RΦ$d$1.m("rt:SP", [])(Angle$1);
	__RΦ$d$1.m("rt:P", [])(Angle$1);
	__RΦ$d$1.m("rt:Sm", ["toDegree", "toRadian"])(Angle$1);
	__RΦ$d$1.m("rt:m", [])(Angle$1);
	__RΦ$d$1.m("rt:f", "Ce")(Angle$1);
	__RΦ$d$1.m("rt:f", "M$S.")(Angle$1["toDegree"]);
	((t, p) => __RΦ$d$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle$1, "toDegree");
	__RΦ$d$1.m("rt:p", [{ n: "value", t: () => __RΦ$d$1.a(15), v: null }])(Angle$1, "toDegree");
	__RΦ$d$1.m("rt:f", "M$S.")(Angle$1, "toDegree");
	__RΦ$d$1.m("rt:t", () => __RΦ$d$1.a(15))(Angle$1, "toDegree");
	__RΦ$d$1.m("rt:f", "M$S.")(Angle$1["toRadian"]);
	((t, p) => __RΦ$d$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle$1, "toRadian");
	__RΦ$d$1.m("rt:p", [{ n: "value", t: () => __RΦ$d$1.a(15), v: null }])(Angle$1, "toRadian");
	__RΦ$d$1.m("rt:f", "M$S.")(Angle$1, "toRadian");
	__RΦ$d$1.m("rt:t", () => __RΦ$d$1.a(15))(Angle$1, "toRadian");

	const __RΦ$c$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$c$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$c$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$c$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [151]: { LΦ: t => Object }, [152]: { LΦ: t => Object } } };
	var IΦdefault$4$1 = { name: "IKeyValueObject", prototype: {}, identity: Symbol("IKeyValueObject (interface)") };
	(t => __RΦ$c$1.t[153] = t)(IΦdefault$4$1);
	__RΦ$c$1.m("rt:P", ["key", "value"])(IΦdefault$4$1);
	__RΦ$c$1.m("rt:m", [])(IΦdefault$4$1);
	__RΦ$c$1.m("rt:f", "Ie")(IΦdefault$4$1);
	__RΦ$c$1.m("rt:t", () => __RΦ$c$1.a(151))(IΦdefault$4$1.prototype, "key");
	__RΦ$c$1.m("rt:f", "P")(IΦdefault$4$1.prototype, "key");
	__RΦ$c$1.m("rt:t", () => __RΦ$c$1.a(152))(IΦdefault$4$1.prototype, "value");
	__RΦ$c$1.m("rt:f", "P")(IΦdefault$4$1.prototype, "value");
	__RΦ$c$1.m("rt:t", () => __RΦ$c$1.a(151))(IΦdefault$4$1.prototype, "key");
	__RΦ$c$1.m("rt:f", "P")(IΦdefault$4$1.prototype, "key");
	__RΦ$c$1.m("rt:t", () => __RΦ$c$1.a(152))(IΦdefault$4$1.prototype, "value");
	__RΦ$c$1.m("rt:f", "P")(IΦdefault$4$1.prototype, "value");

	const __RΦ$b$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$b$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$b$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$b$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1828]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$1.a(156), p: [__RΦ$b$1.a(1826), __RΦ$b$1.a(1827)] }) }, [156]: { LΦ: t => Map }, [1826]: { LΦ: t => Object }, [1827]: { LΦ: t => Object }, [1832]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$1.a(1836) }) }, [1836]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$1.a(153), p: [__RΦ$b$1.a(1826), __RΦ$b$1.a(1835)] }) }, [153]: { LΦ: t => IΦdefault$4$1 }, [1835]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b$1.a(10), __RΦ$b$1.a(1827)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1839]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b$1.a(1840), p: [__RΦ$b$1.a(1837), __RΦ$b$1.a(1838)] }) }, [1840]: { LΦ: t => Object }, [1837]: { LΦ: t => Object }, [1838]: { LΦ: t => Object }, [1844]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$1.a(1846) }) }, [1846]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$1.a(153), p: [__RΦ$b$1.a(1837), __RΦ$b$1.a(1838)] }) }, [1663]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b$1.a(1656), __RΦ$b$1.a(1661)] }) }, [1656]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$1.a(156), p: [__RΦ$b$1.a(1645), __RΦ$b$1.a(1646)] }) }, [1645]: { LΦ: t => Object }, [1646]: { LΦ: t => Object }, [1661]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b$1.a(1662), p: [__RΦ$b$1.a(1645), __RΦ$b$1.a(1646)] }) }, [1662]: { LΦ: t => Object }, [1647]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b$1.a(1650) }) }, [1650]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$1.a(153), p: [__RΦ$b$1.a(1645), __RΦ$b$1.a(1646)] }) }, [15]: { LΦ: t => Number } } };
	/**
	 * Конвертация разнообразных значений.
	 */
	class Convert$1 {
	    static toArray(object) {
	        const result = [];
	        if (object instanceof Map) {
	            for (const [key, value] of object) {
	                result.push({ key, value });
	            }
	        }
	        else {
	            for (const key in object) {
	                if (!object.hasOwnProperty(key))
	                    continue;
	                result.push({ key, value: Reflect.get(object, key) });
	            }
	        }
	        return result;
	    }
	    /**
	     * Конвертировать миллисекунды в секунды.
	     * @param millisecond
	     */
	    static toSecond(millisecond) {
	        return millisecond / 1000;
	    }
	}
	(t => __RΦ$b$1.t[1824] = t)(Convert$1);
	__RΦ$b$1.m("rt:SP", [])(Convert$1);
	__RΦ$b$1.m("rt:P", [])(Convert$1);
	__RΦ$b$1.m("rt:Sm", ["toArray", "toArray", "toArray", "toSecond"])(Convert$1);
	__RΦ$b$1.m("rt:m", [])(Convert$1);
	__RΦ$b$1.m("rt:f", "Ce")(Convert$1);
	__RΦ$b$1.m("rt:f", "M$S")(Convert$1["toArray"]);
	((t, p) => __RΦ$b$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$1, "toArray");
	__RΦ$b$1.m("rt:p", [{ n: "object", t: () => __RΦ$b$1.a(1828), v: null }])(Convert$1, "toArray");
	__RΦ$b$1.m("rt:f", "M$S")(Convert$1, "toArray");
	__RΦ$b$1.m("rt:t", () => __RΦ$b$1.a(1832))(Convert$1, "toArray");
	__RΦ$b$1.m("rt:f", "M$S")(Convert$1["toArray"]);
	((t, p) => __RΦ$b$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$1, "toArray");
	__RΦ$b$1.m("rt:p", [{ n: "object", t: () => __RΦ$b$1.a(1839), v: null }])(Convert$1, "toArray");
	__RΦ$b$1.m("rt:f", "M$S")(Convert$1, "toArray");
	__RΦ$b$1.m("rt:t", () => __RΦ$b$1.a(1844))(Convert$1, "toArray");
	__RΦ$b$1.m("rt:f", "M$S")(Convert$1["toArray"]);
	((t, p) => __RΦ$b$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$1, "toArray");
	__RΦ$b$1.m("rt:p", [{ n: "object", t: () => __RΦ$b$1.a(1663), v: null }])(Convert$1, "toArray");
	__RΦ$b$1.m("rt:f", "M$S")(Convert$1, "toArray");
	__RΦ$b$1.m("rt:t", () => __RΦ$b$1.a(1647))(Convert$1, "toArray");
	__RΦ$b$1.m("rt:f", "M$S.")(Convert$1["toSecond"]);
	((t, p) => __RΦ$b$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert$1, "toSecond");
	__RΦ$b$1.m("rt:p", [{ n: "millisecond", t: () => __RΦ$b$1.a(15), v: null }])(Convert$1, "toSecond");
	__RΦ$b$1.m("rt:f", "M$S.")(Convert$1, "toSecond");
	__RΦ$b$1.m("rt:t", () => __RΦ$b$1.a(15))(Convert$1, "toSecond");

	const __RΦ$a$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$a$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$a$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$a$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1873]: { LΦ: t => 60 }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [15]: { LΦ: t => Number }, [1869]: { LΦ: t => "update" }, [1875]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$1.a(4) }] }) }, [1850]: { RΦ: t => ({ TΦ: "t" }) }, [1871]: { LΦ: t => "render" }, [1876]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$1.a(4) }] }) }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$a$1.a(14), __RΦ$a$1.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1852]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$1.a(4) }] }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * http://gs-studio.com/news-about-it/30703----javascript
	 * https://eatdog.com.ua/assets/gamedev-slides/
	 * https://www.youtube.com/watch?v=-gsjAz9jR3Y
	 */
	class GameLoop$1 {
	    framePerSecond;
	    eventEmitter = new EventEmitter__default$1["default"];
	    time = 0;
	    timeInterval = 0;
	    renderTime = 0;
	    renderTimeInterval = 0;
	    /**
	     * Текущий FPS отрисовки игровой сцены.
	     */
	    get renderFramePerSecond() {
	        return 1 / (this.renderTimeInterval / 1000);
	    }
	    /**
	     * Временной шаг, с которым вызывается функция update для вычисления игровой логики.
	     * Измеряется в миллисекундах.
	     */
	    get step() {
	        return (1 / this.framePerSecond) / 1000;
	    }
	    constructor(
	    /**
	     * Частота обновления игровой логики (генерации события update).
	     * @private
	     */
	    framePerSecond = 60 // TODO Переименовать в updatePerSecond?
	    ) {
	        this.framePerSecond = framePerSecond;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	    start() {
	        this.time = performance.now();
	        this.timeInterval = 0;
	        requestAnimationFrame(this.frame.bind(this));
	    }
	    stop() {
	    }
	    pause() {
	    }
	    frame() {
	        // Обработка логики игры.
	        {
	            const currentTime = performance.now();
	            // Исправление проблемы неактивных вкладок.
	            // Разрешить максимальную задержку между вызовами не более, чем 1 секунда.
	            this.timeInterval = this.timeInterval + Math.min(1000, currentTime - this.time);
	            while (this.timeInterval > this.step) {
	                this.timeInterval = this.timeInterval - this.step;
	                this.eventEmitter.emit('update', this.step);
	            }
	            this.time = currentTime;
	        }
	        // Обработка отрисовки сцены игры.
	        {
	            const renderCurrentTime = performance.now();
	            this.renderTimeInterval = renderCurrentTime - this.renderTime;
	            this.renderTime = renderCurrentTime;
	            this.eventEmitter.emit('render', this.timeInterval);
	        }
	        requestAnimationFrame(this.frame.bind(this));
	    }
	}
	(t => __RΦ$a$1.t[1849] = t)(GameLoop$1);
	__RΦ$a$1.m("rt:SP", [])(GameLoop$1);
	__RΦ$a$1.m("rt:P", ["eventEmitter", "time", "timeInterval", "renderTime", "renderTimeInterval", "renderFramePerSecond", "step", "framePerSecond"])(GameLoop$1);
	__RΦ$a$1.m("rt:Sm", [])(GameLoop$1);
	__RΦ$a$1.m("rt:m", ["on", "on", "on", "start", "stop", "pause", "frame"])(GameLoop$1);
	__RΦ$a$1.m("rt:p", [{ n: "framePerSecond", t: () => __RΦ$a$1.a(1873), v: function () { return 60 // TODO Переименовать в updatePerSecond?
	        ; }, f: "#R" }])(GameLoop$1);
	__RΦ$a$1.m("rt:i", [() => undefined, () => undefined])(GameLoop$1);
	__RΦ$a$1.m("rt:f", "Ce")(GameLoop$1);
	__RΦ$a$1.m("rt:t", () => __RΦ$a$1.a(4))(GameLoop$1.prototype, "eventEmitter");
	__RΦ$a$1.m("rt:f", "P#R")(GameLoop$1.prototype, "eventEmitter");
	__RΦ$a$1.m("rt:t", () => __RΦ$a$1.a(15))(GameLoop$1.prototype, "time");
	__RΦ$a$1.m("rt:f", "P#")(GameLoop$1.prototype, "time");
	__RΦ$a$1.m("rt:t", () => __RΦ$a$1.a(15))(GameLoop$1.prototype, "timeInterval");
	__RΦ$a$1.m("rt:f", "P#")(GameLoop$1.prototype, "timeInterval");
	__RΦ$a$1.m("rt:t", () => __RΦ$a$1.a(15))(GameLoop$1.prototype, "renderTime");
	__RΦ$a$1.m("rt:f", "P#")(GameLoop$1.prototype, "renderTime");
	__RΦ$a$1.m("rt:t", () => __RΦ$a$1.a(15))(GameLoop$1.prototype, "renderTimeInterval");
	__RΦ$a$1.m("rt:f", "P#")(GameLoop$1.prototype, "renderTimeInterval");
	__RΦ$a$1.m("rt:t", () => __RΦ$a$1.a(15))(GameLoop$1.prototype, "renderFramePerSecond");
	__RΦ$a$1.m("rt:f", "P$")(GameLoop$1.prototype, "renderFramePerSecond");
	__RΦ$a$1.m("rt:t", () => __RΦ$a$1.a(15))(GameLoop$1.prototype, "step");
	__RΦ$a$1.m("rt:f", "P$")(GameLoop$1.prototype, "step");
	__RΦ$a$1.m("rt:f", "M")(GameLoop$1.prototype["on"]);
	((t, p) => __RΦ$a$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$1.prototype, "on");
	__RΦ$a$1.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$1.a(1869), v: null }, { n: "update", t: () => __RΦ$a$1.a(1875), v: null }])(GameLoop$1.prototype, "on");
	__RΦ$a$1.m("rt:f", "M")(GameLoop$1.prototype, "on");
	__RΦ$a$1.m("rt:t", () => __RΦ$a$1.a(1850))(GameLoop$1.prototype, "on");
	__RΦ$a$1.m("rt:f", "M")(GameLoop$1.prototype["on"]);
	((t, p) => __RΦ$a$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$1.prototype, "on");
	__RΦ$a$1.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$1.a(1871), v: null }, { n: "render", t: () => __RΦ$a$1.a(1876), v: null }])(GameLoop$1.prototype, "on");
	__RΦ$a$1.m("rt:f", "M")(GameLoop$1.prototype, "on");
	__RΦ$a$1.m("rt:t", () => __RΦ$a$1.a(1850))(GameLoop$1.prototype, "on");
	__RΦ$a$1.m("rt:f", "M")(GameLoop$1.prototype["on"]);
	((t, p) => __RΦ$a$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$1.prototype, "on");
	__RΦ$a$1.m("rt:p", [{ n: "eventName", t: () => __RΦ$a$1.a(143), v: null }, { n: "listener", t: () => __RΦ$a$1.a(1852), v: null }])(GameLoop$1.prototype, "on");
	__RΦ$a$1.m("rt:f", "M")(GameLoop$1.prototype, "on");
	__RΦ$a$1.m("rt:t", () => __RΦ$a$1.a(1850))(GameLoop$1.prototype, "on");
	__RΦ$a$1.m("rt:f", "M$")(GameLoop$1.prototype["start"]);
	((t, p) => __RΦ$a$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$1.prototype, "start");
	__RΦ$a$1.m("rt:p", [])(GameLoop$1.prototype, "start");
	__RΦ$a$1.m("rt:f", "M$")(GameLoop$1.prototype, "start");
	__RΦ$a$1.m("rt:t", () => __RΦ$a$1.a(23))(GameLoop$1.prototype, "start");
	__RΦ$a$1.m("rt:f", "M$")(GameLoop$1.prototype["stop"]);
	((t, p) => __RΦ$a$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$1.prototype, "stop");
	__RΦ$a$1.m("rt:p", [])(GameLoop$1.prototype, "stop");
	__RΦ$a$1.m("rt:f", "M$")(GameLoop$1.prototype, "stop");
	__RΦ$a$1.m("rt:t", () => __RΦ$a$1.a(23))(GameLoop$1.prototype, "stop");
	__RΦ$a$1.m("rt:f", "M$")(GameLoop$1.prototype["pause"]);
	((t, p) => __RΦ$a$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$1.prototype, "pause");
	__RΦ$a$1.m("rt:p", [])(GameLoop$1.prototype, "pause");
	__RΦ$a$1.m("rt:f", "M$")(GameLoop$1.prototype, "pause");
	__RΦ$a$1.m("rt:t", () => __RΦ$a$1.a(23))(GameLoop$1.prototype, "pause");
	__RΦ$a$1.m("rt:f", "M#.")(GameLoop$1.prototype["frame"]);
	((t, p) => __RΦ$a$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop$1.prototype, "frame");
	__RΦ$a$1.m("rt:p", [])(GameLoop$1.prototype, "frame");
	__RΦ$a$1.m("rt:f", "M#.")(GameLoop$1.prototype, "frame");
	__RΦ$a$1.m("rt:t", () => __RΦ$a$1.a(23))(GameLoop$1.prototype, "frame");

	const __RΦ$9$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$9$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$9$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$9$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1880]: { RΦ: t => ({ TΦ: "g", t: __RΦ$9$1$1.a(156), p: [__RΦ$9$1$1.a(14), __RΦ$9$1$1.a(21)] }) }, [156]: { LΦ: t => Map }, [14]: { LΦ: t => String }, [21]: { LΦ: t => Boolean }, [1883]: { LΦ: t => KeyboardEvent }, [1890]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$1$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1893]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$1$1.a(4) }] }) }, [1897]: { LΦ: t => Function }, [1896]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$1$1.a(4) }] }) }, [1898]: { LΦ: t => Function } } };
	/**
	 * Вместо KeyUpDownProcessor используйте Shortcut.
	 * @deprecated
	 * @link http://khusamov.github.io/tutorial/csharp/key-down-up-process
	 */
	class KeyUpDownProcessor$1 {
	    /**
	     * Данный словарь хранит информацию о том, была ли нажата клавиша.
	     * В качестве ключа выступает номер клавиши,
	     * а значение это флаг (была или не была нажата клавиша).
	     * @private
	     * @link https://learn.javascript.ru/keyboard-events
	     */
	    static #theKeyWasDown = new Map;
	    static onKeyDown(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.#theKeyWasDown.has(keyCode)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.#theKeyWasDown.set(keyCode, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.#theKeyWasDown.get(keyCode)) {
	            // Помечаем что она нажата.
	            this.#theKeyWasDown.set(keyCode, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            action();
	        }
	    }
	    static onKeyUp(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Помечаем что она уже не нажата.
	        this.#theKeyWasDown.set(keyCode, false);
	        // Выполняем действие при отжатии клавиши.
	        action();
	    }
	}
	(t => __RΦ$9$1$1.t[1878] = t)(KeyUpDownProcessor$1);
	__RΦ$9$1$1.m("rt:SP", ["#theKeyWasDown"])(KeyUpDownProcessor$1);
	__RΦ$9$1$1.m("rt:P", [])(KeyUpDownProcessor$1);
	__RΦ$9$1$1.m("rt:Sm", ["onKeyDown", "onKeyUp"])(KeyUpDownProcessor$1);
	__RΦ$9$1$1.m("rt:m", [])(KeyUpDownProcessor$1);
	__RΦ$9$1$1.m("rt:f", "Ce")(KeyUpDownProcessor$1);
	__RΦ$9$1$1.m("rt:t", () => __RΦ$9$1$1.a(1880))(KeyUpDownProcessor$1, "#theKeyWasDown");
	__RΦ$9$1$1.m("rt:f", "P")(KeyUpDownProcessor$1, "#theKeyWasDown");
	__RΦ$9$1$1.m("rt:f", "M$S.")(KeyUpDownProcessor$1["onKeyDown"]);
	((t, p) => __RΦ$9$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor$1, "onKeyDown");
	__RΦ$9$1$1.m("rt:p", [{ n: "event", t: () => __RΦ$9$1$1.a(1883), v: null }, { n: "action", t: () => __RΦ$9$1$1.a(1890), v: null }])(KeyUpDownProcessor$1, "onKeyDown");
	__RΦ$9$1$1.m("rt:f", "M$S.")(KeyUpDownProcessor$1, "onKeyDown");
	__RΦ$9$1$1.m("rt:t", () => __RΦ$9$1$1.a(23))(KeyUpDownProcessor$1, "onKeyDown");
	__RΦ$9$1$1.m("rt:f", "M$S.")(KeyUpDownProcessor$1["onKeyUp"]);
	((t, p) => __RΦ$9$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor$1, "onKeyUp");
	__RΦ$9$1$1.m("rt:p", [{ n: "event", t: () => __RΦ$9$1$1.a(1883), v: null }, { n: "action", t: () => __RΦ$9$1$1.a(1890), v: null }])(KeyUpDownProcessor$1, "onKeyUp");
	__RΦ$9$1$1.m("rt:f", "M$S.")(KeyUpDownProcessor$1, "onKeyUp");
	__RΦ$9$1$1.m("rt:t", () => __RΦ$9$1$1.a(23))(KeyUpDownProcessor$1, "onKeyUp");
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyDown$1(listener) {
	    return __RΦ$9$1$1.f((event) => {
	        KeyUpDownProcessor$1.onKeyDown(event, __RΦ$9$1$1.f(() => {
	            listener(event);
	        }, [__RΦ$9$1$1.m("rt:p", []), __RΦ$9$1$1.m("rt:f", "F>"), __RΦ$9$1$1.m("rt:t", () => __RΦ$9$1$1.a(23))], ""));
	    }, [__RΦ$9$1$1.m("rt:p", [{ n: "event", t: () => __RΦ$9$1$1.a(1883), v: null }]), __RΦ$9$1$1.m("rt:f", "F>"), __RΦ$9$1$1.m("rt:t", () => __RΦ$9$1$1.a(23))], "");
	}
	__RΦ$9$1$1.m("rt:p", [{ n: "listener", t: () => __RΦ$9$1$1.a(1893), v: null }])(onKeyDown$1);
	__RΦ$9$1$1.m("rt:f", "F")(onKeyDown$1);
	__RΦ$9$1$1.m("rt:t", () => __RΦ$9$1$1.a(1897))(onKeyDown$1);
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyUp$1(listener) {
	    return __RΦ$9$1$1.f((event) => {
	        KeyUpDownProcessor$1.onKeyUp(event, __RΦ$9$1$1.f(() => {
	            listener(event);
	        }, [__RΦ$9$1$1.m("rt:p", []), __RΦ$9$1$1.m("rt:f", "F>"), __RΦ$9$1$1.m("rt:t", () => __RΦ$9$1$1.a(23))], ""));
	    }, [__RΦ$9$1$1.m("rt:p", [{ n: "event", t: () => __RΦ$9$1$1.a(1883), v: null }]), __RΦ$9$1$1.m("rt:f", "F>"), __RΦ$9$1$1.m("rt:t", () => __RΦ$9$1$1.a(23))], "");
	}
	__RΦ$9$1$1.m("rt:p", [{ n: "listener", t: () => __RΦ$9$1$1.a(1896), v: null }])(onKeyUp$1);
	__RΦ$9$1$1.m("rt:f", "F")(onKeyUp$1);
	__RΦ$9$1$1.m("rt:t", () => __RΦ$9$1$1.a(1898))(onKeyUp$1);

	const __RΦ$8$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$8$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$8$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$8$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$3$1 = { name: "IDisposable", prototype: {}, identity: Symbol("IDisposable (interface)") };
	(t => __RΦ$8$1$1.t[147] = t)(IΦdefault$3$1);
	__RΦ$8$1$1.m("rt:P", [])(IΦdefault$3$1);
	__RΦ$8$1$1.m("rt:m", ["dispose"])(IΦdefault$3$1);
	__RΦ$8$1$1.m("rt:f", "Ie")(IΦdefault$3$1);
	__RΦ$8$1$1.m("rt:p", [])(IΦdefault$3$1.prototype, "dispose");
	__RΦ$8$1$1.m("rt:f", "M")(IΦdefault$3$1.prototype, "dispose");
	__RΦ$8$1$1.m("rt:t", () => __RΦ$8$1$1.a(23))(IΦdefault$3$1.prototype, "dispose");
	__RΦ$8$1$1.m("rt:p", [])(IΦdefault$3$1.prototype, "dispose");
	__RΦ$8$1$1.m("rt:f", "M")(IΦdefault$3$1.prototype, "dispose");
	__RΦ$8$1$1.m("rt:t", () => __RΦ$8$1$1.a(23))(IΦdefault$3$1.prototype, "dispose");

	const __RΦ$7$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$7$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$7$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$7$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1899]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$7$1$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) } } };
	var IΦdefault$2$1 = { name: "IKeyboardListeners", prototype: {}, identity: Symbol("IKeyboardListeners (interface)") };
	(t => __RΦ$7$1$1.t[1900] = t)(IΦdefault$2$1);
	__RΦ$7$1$1.m("rt:P", ["down", "up"])(IΦdefault$2$1);
	__RΦ$7$1$1.m("rt:m", [])(IΦdefault$2$1);
	__RΦ$7$1$1.m("rt:f", "Ie")(IΦdefault$2$1);
	__RΦ$7$1$1.m("rt:t", () => __RΦ$7$1$1.a(1899))(IΦdefault$2$1.prototype, "down");
	__RΦ$7$1$1.m("rt:f", "P")(IΦdefault$2$1.prototype, "down");
	__RΦ$7$1$1.m("rt:t", () => __RΦ$7$1$1.a(1899))(IΦdefault$2$1.prototype, "up");
	__RΦ$7$1$1.m("rt:f", "P")(IΦdefault$2$1.prototype, "up");
	__RΦ$7$1$1.m("rt:t", () => __RΦ$7$1$1.a(1899))(IΦdefault$2$1.prototype, "down");
	__RΦ$7$1$1.m("rt:f", "P")(IΦdefault$2$1.prototype, "down");
	__RΦ$7$1$1.m("rt:t", () => __RΦ$7$1$1.a(1899))(IΦdefault$2$1.prototype, "up");
	__RΦ$7$1$1.m("rt:f", "P")(IΦdefault$2$1.prototype, "up");

	const __RΦ$6$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$6$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$6$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$6$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [709]: { LΦ: t => Object }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1901]: { TΦ: "5", name: "default" }, [2154]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$1$1.a(156), p: [__RΦ$6$1$1.a(14), __RΦ$6$1$1.a(1900)] }) }, [156]: { LΦ: t => Map }, [1900]: { LΦ: t => IΦdefault$2$1 }, [1899]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$6$1$1.a(4) }] }) }, [1880]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$1$1.a(156), p: [__RΦ$6$1$1.a(14), __RΦ$6$1$1.a(21)] }) }, [21]: { LΦ: t => Boolean }, [147]: { LΦ: t => IΦdefault$3$1 }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1883]: { LΦ: t => KeyboardEvent } } };
	const codeOf$1 = __RΦ$6$1$1.f((key) => 'Key' + key.toUpperCase(), [__RΦ$6$1$1.m("rt:p", [{ n: "key", t: () => __RΦ$6$1$1.a(14), v: null }]), __RΦ$6$1$1.m("rt:f", "F>"), __RΦ$6$1$1.m("rt:t", () => __RΦ$6$1$1.a(14))], "codeOf");
	class ShortcutDispatcher$1 {
	    static instanceHolder = new Lazy$1(() => new ShortcutDispatcher$1);
	    static get instance() {
	        return this.instanceHolder.value;
	    }
	    host;
	    listeners = new Map;
	    keyDownListenerBinded;
	    keyUpListenerBinded;
	    theKeyWasDown = new Map;
	    constructor(host = document) {
	        this.host = host;
	        this.keyDownListenerBinded = this.keyDownListener.bind(this);
	        this.keyUpListenerBinded = this.keyUpListener.bind(this);
	        this.host.addEventListener('keydown', this.keyDownListenerBinded);
	        this.host.addEventListener('keyup', this.keyUpListenerBinded);
	    }
	    register(key, listeners) {
	        this.listeners.set(key, listeners);
	        return {
	            dispose: __RΦ$6$1$1.f(() => {
	                this.listeners.delete(key);
	                this.theKeyWasDown.delete(codeOf$1(key));
	            }, [__RΦ$6$1$1.m("rt:p", []), __RΦ$6$1$1.m("rt:f", "F>"), __RΦ$6$1$1.m("rt:t", () => __RΦ$6$1$1.a(23))], "dispose")
	        };
	    }
	    keyDownListener(event) {
	        const code = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.theKeyWasDown.has(code)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.theKeyWasDown.set(code, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.theKeyWasDown.get(code)) {
	            // Помечаем что она нажата.
	            this.theKeyWasDown.set(code, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            for (const [key, listeners] of this.listeners.entries()) {
	                if (code === codeOf$1(key)) {
	                    listeners.down(event);
	                }
	            }
	        }
	    }
	    keyUpListener(event) {
	        // Из события извлекаем номер нажатой клавиши.
	        const code = event.code;
	        // Помечаем что она уже не нажата.
	        this.theKeyWasDown.set(code, false);
	        // Выполняем действие при отжатии клавиши.
	        for (const [key, listeners] of this.listeners.entries()) {
	            if (code === codeOf$1(key)) {
	                listeners.up(event);
	            }
	        }
	    }
	    dispose() {
	        this.host.removeEventListener('keydown', this.keyDownListenerBinded);
	        this.host.removeEventListener('keyup', this.keyUpListenerBinded);
	    }
	}
	(t => __RΦ$6$1$1.t[1901] = t)(ShortcutDispatcher$1);
	__RΦ$6$1$1.m("rt:SP", ["instanceHolder", "instance"])(ShortcutDispatcher$1);
	__RΦ$6$1$1.m("rt:P", ["host", "listeners", "keyDownListenerBinded", "keyUpListenerBinded", "theKeyWasDown"])(ShortcutDispatcher$1);
	__RΦ$6$1$1.m("rt:Sm", [])(ShortcutDispatcher$1);
	__RΦ$6$1$1.m("rt:m", ["register", "keyDownListener", "keyUpListener", "dispose"])(ShortcutDispatcher$1);
	__RΦ$6$1$1.m("rt:p", [{ n: "host", t: () => __RΦ$6$1$1.a(709), v: function () { return document; } }])(ShortcutDispatcher$1);
	__RΦ$6$1$1.m("rt:i", [() => undefined])(ShortcutDispatcher$1);
	__RΦ$6$1$1.m("rt:f", "Ce")(ShortcutDispatcher$1);
	__RΦ$6$1$1.m("rt:t", () => __RΦ$6$1$1.a(4))(ShortcutDispatcher$1, "instanceHolder");
	__RΦ$6$1$1.m("rt:f", "P#R")(ShortcutDispatcher$1, "instanceHolder");
	__RΦ$6$1$1.m("rt:t", () => __RΦ$6$1$1.a(1901))(ShortcutDispatcher$1, "instance");
	__RΦ$6$1$1.m("rt:f", "P$")(ShortcutDispatcher$1, "instance");
	__RΦ$6$1$1.m("rt:t", () => __RΦ$6$1$1.a(709))(ShortcutDispatcher$1.prototype, "host");
	__RΦ$6$1$1.m("rt:f", "P#R")(ShortcutDispatcher$1.prototype, "host");
	__RΦ$6$1$1.m("rt:t", () => __RΦ$6$1$1.a(2154))(ShortcutDispatcher$1.prototype, "listeners");
	__RΦ$6$1$1.m("rt:f", "P#R")(ShortcutDispatcher$1.prototype, "listeners");
	__RΦ$6$1$1.m("rt:t", () => __RΦ$6$1$1.a(1899))(ShortcutDispatcher$1.prototype, "keyDownListenerBinded");
	__RΦ$6$1$1.m("rt:f", "P#R")(ShortcutDispatcher$1.prototype, "keyDownListenerBinded");
	__RΦ$6$1$1.m("rt:t", () => __RΦ$6$1$1.a(1899))(ShortcutDispatcher$1.prototype, "keyUpListenerBinded");
	__RΦ$6$1$1.m("rt:f", "P#R")(ShortcutDispatcher$1.prototype, "keyUpListenerBinded");
	__RΦ$6$1$1.m("rt:t", () => __RΦ$6$1$1.a(1880))(ShortcutDispatcher$1.prototype, "theKeyWasDown");
	__RΦ$6$1$1.m("rt:f", "P#R")(ShortcutDispatcher$1.prototype, "theKeyWasDown");
	__RΦ$6$1$1.m("rt:f", "M$")(ShortcutDispatcher$1.prototype["register"]);
	((t, p) => __RΦ$6$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$1.prototype, "register");
	__RΦ$6$1$1.m("rt:p", [{ n: "key", t: () => __RΦ$6$1$1.a(14), v: null }, { n: "listeners", t: () => __RΦ$6$1$1.a(1900), v: null }])(ShortcutDispatcher$1.prototype, "register");
	__RΦ$6$1$1.m("rt:f", "M$")(ShortcutDispatcher$1.prototype, "register");
	__RΦ$6$1$1.m("rt:t", () => __RΦ$6$1$1.a(147))(ShortcutDispatcher$1.prototype, "register");
	__RΦ$6$1$1.m("rt:f", "M#.")(ShortcutDispatcher$1.prototype["keyDownListener"]);
	((t, p) => __RΦ$6$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$1.prototype, "keyDownListener");
	__RΦ$6$1$1.m("rt:p", [{ n: "event", t: () => __RΦ$6$1$1.a(1883), v: null }])(ShortcutDispatcher$1.prototype, "keyDownListener");
	__RΦ$6$1$1.m("rt:f", "M#.")(ShortcutDispatcher$1.prototype, "keyDownListener");
	__RΦ$6$1$1.m("rt:t", () => __RΦ$6$1$1.a(23))(ShortcutDispatcher$1.prototype, "keyDownListener");
	__RΦ$6$1$1.m("rt:f", "M#.")(ShortcutDispatcher$1.prototype["keyUpListener"]);
	((t, p) => __RΦ$6$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$1.prototype, "keyUpListener");
	__RΦ$6$1$1.m("rt:p", [{ n: "event", t: () => __RΦ$6$1$1.a(1883), v: null }])(ShortcutDispatcher$1.prototype, "keyUpListener");
	__RΦ$6$1$1.m("rt:f", "M#.")(ShortcutDispatcher$1.prototype, "keyUpListener");
	__RΦ$6$1$1.m("rt:t", () => __RΦ$6$1$1.a(23))(ShortcutDispatcher$1.prototype, "keyUpListener");
	__RΦ$6$1$1.m("rt:f", "M$.")(ShortcutDispatcher$1.prototype["dispose"]);
	((t, p) => __RΦ$6$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher$1.prototype, "dispose");
	__RΦ$6$1$1.m("rt:p", [])(ShortcutDispatcher$1.prototype, "dispose");
	__RΦ$6$1$1.m("rt:f", "M$.")(ShortcutDispatcher$1.prototype, "dispose");
	__RΦ$6$1$1.m("rt:t", () => __RΦ$6$1$1.a(23))(ShortcutDispatcher$1.prototype, "dispose");

	const __RΦ$5$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$5$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$5$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$5$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [1900]: { LΦ: t => IΦdefault$2$1 }, [147]: { LΦ: t => IΦdefault$3$1 } } };
	class Shortcut$1 {
	    static register(key, listeners) {
	        return ShortcutDispatcher$1.instance.register(key, listeners);
	    }
	}
	(t => __RΦ$5$1$1.t[2183] = t)(Shortcut$1);
	__RΦ$5$1$1.m("rt:SP", [])(Shortcut$1);
	__RΦ$5$1$1.m("rt:P", [])(Shortcut$1);
	__RΦ$5$1$1.m("rt:Sm", ["register"])(Shortcut$1);
	__RΦ$5$1$1.m("rt:m", [])(Shortcut$1);
	__RΦ$5$1$1.m("rt:f", "Ce")(Shortcut$1);
	__RΦ$5$1$1.m("rt:f", "M$S")(Shortcut$1["register"]);
	((t, p) => __RΦ$5$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Shortcut$1, "register");
	__RΦ$5$1$1.m("rt:p", [{ n: "key", t: () => __RΦ$5$1$1.a(14), v: null }, { n: "listeners", t: () => __RΦ$5$1$1.a(1900), v: null }])(Shortcut$1, "register");
	__RΦ$5$1$1.m("rt:f", "M$S")(Shortcut$1, "register");
	__RΦ$5$1$1.m("rt:t", () => __RΦ$5$1$1.a(147))(Shortcut$1, "register");

	const __RΦ$4$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$4$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$4$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$4$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [166]: { RΦ: t => ({ TΦ: "[", e: __RΦ$4$1$1.a(165) }) }, [165]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [168]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$4$1$1.a(10), __RΦ$4$1$1.a(167)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [167]: { LΦ: t => Object }, [177]: { RΦ: t => ({ TΦ: "g", t: __RΦ$4$1$1.a(77), p: [__RΦ$4$1$1.a(167)] }) }, [77]: { LΦ: t => Object } } };
	var IΦdefault$1$1 = { name: "IQueue", prototype: {}, identity: Symbol("IQueue (interface)") };
	(t => __RΦ$4$1$1.t[178] = t)(IΦdefault$1$1);
	__RΦ$4$1$1.m("rt:P", ["items"])(IΦdefault$1$1);
	__RΦ$4$1$1.m("rt:m", ["enqueue", "dequeue"])(IΦdefault$1$1);
	__RΦ$4$1$1.m("rt:f", "Ie")(IΦdefault$1$1);
	__RΦ$4$1$1.m("rt:p", [{ n: "items", t: () => __RΦ$4$1$1.a(166), v: null }])(IΦdefault$1$1.prototype, "enqueue");
	__RΦ$4$1$1.m("rt:f", "M")(IΦdefault$1$1.prototype, "enqueue");
	__RΦ$4$1$1.m("rt:t", () => __RΦ$4$1$1.a(23))(IΦdefault$1$1.prototype, "enqueue");
	__RΦ$4$1$1.m("rt:p", [])(IΦdefault$1$1.prototype, "dequeue");
	__RΦ$4$1$1.m("rt:f", "M")(IΦdefault$1$1.prototype, "dequeue");
	__RΦ$4$1$1.m("rt:t", () => __RΦ$4$1$1.a(168))(IΦdefault$1$1.prototype, "dequeue");
	__RΦ$4$1$1.m("rt:t", () => __RΦ$4$1$1.a(177))(IΦdefault$1$1.prototype, "items");
	__RΦ$4$1$1.m("rt:f", "PR")(IΦdefault$1$1.prototype, "items");
	__RΦ$4$1$1.m("rt:p", [{ n: "items", t: () => __RΦ$4$1$1.a(166), v: null }])(IΦdefault$1$1.prototype, "enqueue");
	__RΦ$4$1$1.m("rt:f", "M")(IΦdefault$1$1.prototype, "enqueue");
	__RΦ$4$1$1.m("rt:t", () => __RΦ$4$1$1.a(23))(IΦdefault$1$1.prototype, "enqueue");
	__RΦ$4$1$1.m("rt:p", [])(IΦdefault$1$1.prototype, "dequeue");
	__RΦ$4$1$1.m("rt:f", "M")(IΦdefault$1$1.prototype, "dequeue");
	__RΦ$4$1$1.m("rt:t", () => __RΦ$4$1$1.a(168))(IΦdefault$1$1.prototype, "dequeue");
	__RΦ$4$1$1.m("rt:t", () => __RΦ$4$1$1.a(177))(IΦdefault$1$1.prototype, "items");
	__RΦ$4$1$1.m("rt:f", "PR")(IΦdefault$1$1.prototype, "items");

	const __RΦ$3$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$3$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$3$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$3$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [185]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$1$1.a(182) }) }, [182]: { LΦ: t => Object }, [190]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$1$1.a(180) }) }, [180]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [227]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$3$1$1.a(10), __RΦ$3$1$1.a(182)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [228]: { RΦ: t => ({ TΦ: "g", t: __RΦ$3$1$1.a(77), p: [__RΦ$3$1$1.a(182)] }) }, [77]: { LΦ: t => Object } } };
	/**
	 * О́чередь — абстрактный тип данных с дисциплиной доступа к элементам «первый пришёл — первый вышел»
	 * (FIFO, англ. first in, first out).
	 *
	 * Добавление элемента (принято обозначать словом enqueue — поставить в очередь) возможно лишь
	 * в конец очереди, выборка — только из начала очереди (что принято называть словом dequeue — убрать из очереди),
	 * при этом выбранный элемент из очереди удаляется.
	 *
	 * @link https://bit.ly/3tPM13G
	 */
	class Queue$1 {
	    storage = [];
	    enqueue(...items) {
	        this.storage.push(...items);
	    }
	    dequeue() {
	        return this.storage.shift();
	    }
	    get items() {
	        return this.storage;
	    }
	}
	(t => __RΦ$3$1$1.t[181] = t)(Queue$1);
	__RΦ$3$1$1.m("rt:SP", [])(Queue$1);
	__RΦ$3$1$1.m("rt:P", ["storage", "items"])(Queue$1);
	__RΦ$3$1$1.m("rt:Sm", [])(Queue$1);
	__RΦ$3$1$1.m("rt:m", ["enqueue", "dequeue"])(Queue$1);
	__RΦ$3$1$1.m("rt:i", [() => undefined])(Queue$1);
	__RΦ$3$1$1.m("rt:f", "Ce")(Queue$1);
	__RΦ$3$1$1.m("rt:t", () => __RΦ$3$1$1.a(185))(Queue$1.prototype, "storage");
	__RΦ$3$1$1.m("rt:f", "P#")(Queue$1.prototype, "storage");
	__RΦ$3$1$1.m("rt:f", "M$")(Queue$1.prototype["enqueue"]);
	((t, p) => __RΦ$3$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue$1.prototype, "enqueue");
	__RΦ$3$1$1.m("rt:p", [{ n: "items", t: () => __RΦ$3$1$1.a(190), v: null }])(Queue$1.prototype, "enqueue");
	__RΦ$3$1$1.m("rt:f", "M$")(Queue$1.prototype, "enqueue");
	__RΦ$3$1$1.m("rt:t", () => __RΦ$3$1$1.a(23))(Queue$1.prototype, "enqueue");
	__RΦ$3$1$1.m("rt:f", "M$")(Queue$1.prototype["dequeue"]);
	((t, p) => __RΦ$3$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue$1.prototype, "dequeue");
	__RΦ$3$1$1.m("rt:p", [])(Queue$1.prototype, "dequeue");
	__RΦ$3$1$1.m("rt:f", "M$")(Queue$1.prototype, "dequeue");
	__RΦ$3$1$1.m("rt:t", () => __RΦ$3$1$1.a(227))(Queue$1.prototype, "dequeue");
	__RΦ$3$1$1.m("rt:t", () => __RΦ$3$1$1.a(228))(Queue$1.prototype, "items");
	__RΦ$3$1$1.m("rt:f", "P$")(Queue$1.prototype, "items");

	const __RΦ$2$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$2$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$2$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$2$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [407]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$1$1.a(404) }) }, [404]: { LΦ: t => Object }, [273]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$1.a(178), p: [__RΦ$2$1$1.a(230)] }) }, [178]: { LΦ: t => IΦdefault$1$1 }, [230]: { LΦ: t => Object }, [406]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$1.a(403), p: [__RΦ$2$1$1.a(230)] }) }, [403]: { TΦ: "5", name: "ILog" }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [622]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$1.a(178), p: [__RΦ$2$1$1.a(621)] }) }, [621]: { LΦ: t => Object }, [628]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$2$1$1.a(622) }, { t: __RΦ$2$1$1.a(627) }] }) }, [627]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1$1.a(229), p: [__RΦ$2$1$1.a(621)] }) }, [229]: { TΦ: "5", name: "default" }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$1$1.a(14), __RΦ$2$1$1.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [397]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [629]: { LΦ: t => Function }, [408]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$1$1.a(230) }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [402]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [630]: { LΦ: t => Function }, [428]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$1$1.a(10), __RΦ$2$1$1.a(230)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	var IΦILog$1 = { name: "ILog", prototype: {}, identity: Symbol("ILog (interface)") };
	(t => __RΦ$2$1$1.t[403] = t)(IΦILog$1);
	__RΦ$2$1$1.m("rt:P", ["enqueue", "dequeue"])(IΦILog$1);
	__RΦ$2$1$1.m("rt:m", [])(IΦILog$1);
	__RΦ$2$1$1.m("rt:f", "I")(IΦILog$1);
	__RΦ$2$1$1.m("rt:t", () => __RΦ$2$1$1.a(407))(IΦILog$1.prototype, "enqueue");
	__RΦ$2$1$1.m("rt:f", "P")(IΦILog$1.prototype, "enqueue");
	__RΦ$2$1$1.m("rt:t", () => __RΦ$2$1$1.a(407))(IΦILog$1.prototype, "dequeue");
	__RΦ$2$1$1.m("rt:f", "P")(IΦILog$1.prototype, "dequeue");
	__RΦ$2$1$1.m("rt:t", () => __RΦ$2$1$1.a(407))(IΦILog$1.prototype, "enqueue");
	__RΦ$2$1$1.m("rt:f", "P")(IΦILog$1.prototype, "enqueue");
	__RΦ$2$1$1.m("rt:t", () => __RΦ$2$1$1.a(407))(IΦILog$1.prototype, "dequeue");
	__RΦ$2$1$1.m("rt:f", "P")(IΦILog$1.prototype, "dequeue");
	class QueueLog$1 {
	    queue;
	    queueProxy;
	    log = {
	        enqueue: [],
	        dequeue: []
	    };
	    get sourceQueue() {
	        return this.queue;
	    }
	    get loggedQueue() {
	        return this.queueProxy;
	    }
	    static create(queue) {
	        const queueLog = new QueueLog$1(queue);
	        return [queueLog.loggedQueue, queueLog];
	    }
	    constructor(queue) {
	        this.queue = queue;
	        this.queueProxy = (new Proxy(queue, {
	            get: this.proxyHandlerGet.bind(this)
	        }));
	    }
	    proxyHandlerGet(target, property, receiver) {
	        const origin = Reflect.get(target, property, receiver);
	        switch (property) {
	            case 'enqueue': return this.createEnqueue(target, origin);
	            case 'dequeue': return this.createDequeue(target, origin);
	            default: return origin;
	        }
	    }
	    createEnqueue(target, origin) {
	        return (__RΦ$2$1$1.f((...items) => {
	            this.log.enqueue.push(...items);
	            origin.call(target, ...items);
	        }, [__RΦ$2$1$1.m("rt:p", [{ n: "items", t: () => __RΦ$2$1$1.a(408), v: null }]), __RΦ$2$1$1.m("rt:f", "F>"), __RΦ$2$1$1.m("rt:t", () => __RΦ$2$1$1.a(23))], ""));
	    }
	    createDequeue(target, origin) {
	        return (__RΦ$2$1$1.f(() => {
	            const item = origin.call(target);
	            if (item) {
	                this.log.dequeue.push(item);
	            }
	            return item;
	        }, [__RΦ$2$1$1.m("rt:p", []), __RΦ$2$1$1.m("rt:f", "F>"), __RΦ$2$1$1.m("rt:t", () => __RΦ$2$1$1.a(428))], ""));
	    }
	}
	(t => __RΦ$2$1$1.t[229] = t)(QueueLog$1);
	__RΦ$2$1$1.m("rt:SP", [])(QueueLog$1);
	__RΦ$2$1$1.m("rt:P", ["queueProxy", "log", "sourceQueue", "loggedQueue", "queue"])(QueueLog$1);
	__RΦ$2$1$1.m("rt:Sm", ["create"])(QueueLog$1);
	__RΦ$2$1$1.m("rt:m", ["proxyHandlerGet", "createEnqueue", "createDequeue"])(QueueLog$1);
	__RΦ$2$1$1.m("rt:p", [{ n: "queue", t: () => __RΦ$2$1$1.a(273), v: null, f: "#" }])(QueueLog$1);
	__RΦ$2$1$1.m("rt:f", "Ce")(QueueLog$1);
	__RΦ$2$1$1.m("rt:t", () => __RΦ$2$1$1.a(273))(QueueLog$1.prototype, "queueProxy");
	__RΦ$2$1$1.m("rt:f", "P#R")(QueueLog$1.prototype, "queueProxy");
	__RΦ$2$1$1.m("rt:t", () => __RΦ$2$1$1.a(406))(QueueLog$1.prototype, "log");
	__RΦ$2$1$1.m("rt:f", "P#")(QueueLog$1.prototype, "log");
	__RΦ$2$1$1.m("rt:t", () => __RΦ$2$1$1.a(4))(QueueLog$1.prototype, "sourceQueue");
	__RΦ$2$1$1.m("rt:f", "P$")(QueueLog$1.prototype, "sourceQueue");
	__RΦ$2$1$1.m("rt:t", () => __RΦ$2$1$1.a(4))(QueueLog$1.prototype, "loggedQueue");
	__RΦ$2$1$1.m("rt:f", "P$")(QueueLog$1.prototype, "loggedQueue");
	__RΦ$2$1$1.m("rt:f", "M$S")(QueueLog$1["create"]);
	((t, p) => __RΦ$2$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$1, "create");
	__RΦ$2$1$1.m("rt:p", [{ n: "queue", t: () => __RΦ$2$1$1.a(622), v: null }])(QueueLog$1, "create");
	__RΦ$2$1$1.m("rt:f", "M$S")(QueueLog$1, "create");
	__RΦ$2$1$1.m("rt:t", () => __RΦ$2$1$1.a(628))(QueueLog$1, "create");
	__RΦ$2$1$1.m("rt:f", "M#")(QueueLog$1.prototype["proxyHandlerGet"]);
	((t, p) => __RΦ$2$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$1.prototype, "proxyHandlerGet");
	__RΦ$2$1$1.m("rt:p", [{ n: "target", t: () => __RΦ$2$1$1.a(273), v: null }, { n: "property", t: () => __RΦ$2$1$1.a(143), v: null }, { n: "receiver", t: () => __RΦ$2$1$1.a(1), v: null }])(QueueLog$1.prototype, "proxyHandlerGet");
	__RΦ$2$1$1.m("rt:f", "M#")(QueueLog$1.prototype, "proxyHandlerGet");
	__RΦ$2$1$1.m("rt:t", () => __RΦ$2$1$1.a(1))(QueueLog$1.prototype, "proxyHandlerGet");
	__RΦ$2$1$1.m("rt:f", "M#.")(QueueLog$1.prototype["createEnqueue"]);
	((t, p) => __RΦ$2$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$1.prototype, "createEnqueue");
	__RΦ$2$1$1.m("rt:p", [{ n: "target", t: () => __RΦ$2$1$1.a(273), v: null }, { n: "origin", t: () => __RΦ$2$1$1.a(397), v: null }])(QueueLog$1.prototype, "createEnqueue");
	__RΦ$2$1$1.m("rt:f", "M#.")(QueueLog$1.prototype, "createEnqueue");
	__RΦ$2$1$1.m("rt:t", () => __RΦ$2$1$1.a(629))(QueueLog$1.prototype, "createEnqueue");
	__RΦ$2$1$1.m("rt:f", "M#.")(QueueLog$1.prototype["createDequeue"]);
	((t, p) => __RΦ$2$1$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog$1.prototype, "createDequeue");
	__RΦ$2$1$1.m("rt:p", [{ n: "target", t: () => __RΦ$2$1$1.a(273), v: null }, { n: "origin", t: () => __RΦ$2$1$1.a(402), v: null }])(QueueLog$1.prototype, "createDequeue");
	__RΦ$2$1$1.m("rt:f", "M#.")(QueueLog$1.prototype, "createDequeue");
	__RΦ$2$1$1.m("rt:t", () => __RΦ$2$1$1.a(630))(QueueLog$1.prototype, "createDequeue");

	const __RΦ$1$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$1$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$1$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$1$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$1$1$1.a(14), __RΦ$1$1$1.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [144]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$1$1$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [146]: { RΦ: t => ({ TΦ: "t" }) } } };
	var IΦdefault$a$1 = { name: "IEventEmitter", prototype: {}, identity: Symbol("IEventEmitter (interface)") };
	(t => __RΦ$1$1$1.t[145] = t)(IΦdefault$a$1);
	__RΦ$1$1$1.m("rt:P", [])(IΦdefault$a$1);
	__RΦ$1$1$1.m("rt:m", ["on"])(IΦdefault$a$1);
	__RΦ$1$1$1.m("rt:f", "Ie")(IΦdefault$a$1);
	__RΦ$1$1$1.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$1$1.a(143), v: null }, { n: "listener", t: () => __RΦ$1$1$1.a(144), v: null }])(IΦdefault$a$1.prototype, "on");
	__RΦ$1$1$1.m("rt:f", "M")(IΦdefault$a$1.prototype, "on");
	__RΦ$1$1$1.m("rt:t", () => __RΦ$1$1$1.a(146))(IΦdefault$a$1.prototype, "on");
	__RΦ$1$1$1.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$1$1.a(143), v: null }, { n: "listener", t: () => __RΦ$1$1$1.a(144), v: null }])(IΦdefault$a$1.prototype, "on");
	__RΦ$1$1$1.m("rt:f", "M")(IΦdefault$a$1.prototype, "on");
	__RΦ$1$1$1.m("rt:t", () => __RΦ$1$1$1.a(146))(IΦdefault$a$1.prototype, "on");

	const __RΦ$s$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$s$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$s$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$s$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [4]: { RΦ: t => ({ TΦ: "~" }) }, [641]: { RΦ: t => ({ TΦ: "[", e: __RΦ$s$1.a(631) }) }, [631]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [658]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$s$1.a(10), __RΦ$s$1.a(633)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [633]: { LΦ: t => Object }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$s$1.a(14), __RΦ$s$1.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [662]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$s$1.a(4) }] }) }, [634]: { RΦ: t => ({ TΦ: "t" }) } } };
	class QueueWithEventEmitter$1 extends Queue$1 {
	    eventEmitter = new EventEmitter__default$1["default"];
	    enqueue(...items) {
	        this.eventEmitter.emit('before-enqueue', this, ...items);
	        super.enqueue(...items);
	        this.eventEmitter.emit('enqueue', this, ...items);
	    }
	    dequeue() {
	        const removed = super.dequeue();
	        this.eventEmitter.emit('dequeue', this, removed);
	        return removed;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	}
	(t => __RΦ$s$1.t[632] = t)(QueueWithEventEmitter$1);
	__RΦ$s$1.m("rt:SP", [])(QueueWithEventEmitter$1);
	__RΦ$s$1.m("rt:P", ["eventEmitter"])(QueueWithEventEmitter$1);
	__RΦ$s$1.m("rt:Sm", [])(QueueWithEventEmitter$1);
	__RΦ$s$1.m("rt:m", ["enqueue", "dequeue", "on"])(QueueWithEventEmitter$1);
	__RΦ$s$1.m("rt:i", [() => undefined])(QueueWithEventEmitter$1);
	__RΦ$s$1.m("rt:f", "Ce")(QueueWithEventEmitter$1);
	__RΦ$s$1.m("rt:t", () => __RΦ$s$1.a(4))(QueueWithEventEmitter$1.prototype, "eventEmitter");
	__RΦ$s$1.m("rt:f", "P#")(QueueWithEventEmitter$1.prototype, "eventEmitter");
	__RΦ$s$1.m("rt:f", "M$")(QueueWithEventEmitter$1.prototype["enqueue"]);
	((t, p) => __RΦ$s$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$1.prototype, "enqueue");
	__RΦ$s$1.m("rt:p", [{ n: "items", t: () => __RΦ$s$1.a(641), v: null }])(QueueWithEventEmitter$1.prototype, "enqueue");
	__RΦ$s$1.m("rt:f", "M$")(QueueWithEventEmitter$1.prototype, "enqueue");
	__RΦ$s$1.m("rt:t", () => __RΦ$s$1.a(23))(QueueWithEventEmitter$1.prototype, "enqueue");
	__RΦ$s$1.m("rt:f", "M$")(QueueWithEventEmitter$1.prototype["dequeue"]);
	((t, p) => __RΦ$s$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$1.prototype, "dequeue");
	__RΦ$s$1.m("rt:p", [])(QueueWithEventEmitter$1.prototype, "dequeue");
	__RΦ$s$1.m("rt:f", "M$")(QueueWithEventEmitter$1.prototype, "dequeue");
	__RΦ$s$1.m("rt:t", () => __RΦ$s$1.a(658))(QueueWithEventEmitter$1.prototype, "dequeue");
	__RΦ$s$1.m("rt:f", "M$")(QueueWithEventEmitter$1.prototype["on"]);
	((t, p) => __RΦ$s$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter$1.prototype, "on");
	__RΦ$s$1.m("rt:p", [{ n: "eventName", t: () => __RΦ$s$1.a(143), v: null }, { n: "listener", t: () => __RΦ$s$1.a(662), v: null }])(QueueWithEventEmitter$1.prototype, "on");
	__RΦ$s$1.m("rt:f", "M$")(QueueWithEventEmitter$1.prototype, "on");
	__RΦ$s$1.m("rt:t", () => __RΦ$s$1.a(634))(QueueWithEventEmitter$1.prototype, "on");

	dist$2.Angle = Angle$1;
	dist$2.Convert = Convert$1;
	dist$2.GameLoop = GameLoop$1;
	dist$2.KeyUpDownProcessor = KeyUpDownProcessor$1;
	dist$2.Lazy = Lazy$1;
	dist$2.Queue = Queue$1;
	dist$2.QueueLog = QueueLog$1;
	dist$2.QueueWithEventEmitter = QueueWithEventEmitter$1;
	dist$2.Shortcut = Shortcut$1;
	dist$2.ShortcutDispatcher = ShortcutDispatcher$1;
	dist$2.Timer = Timer$1;
	dist$2.Vector = Vector$1;
	dist$2.execActionScript = execActionScript$1;
	dist$2.execFunctionScript = execFunctionScript$1;
	dist$2.isBrowser = isBrowser$1;
	dist$2.isStoppable = isStoppable$1;
	dist$2.onKeyDown = onKeyDown$1;
	dist$2.onKeyUp = onKeyUp$1;
	dist$2.toOneLine = toOneLine$1;

	const __RΦ$d$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$d$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$d$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$d$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [86]: { LΦ: t => undefined }, [97]: { RΦ: t => ({ TΦ: "g", t: __RΦ$d$2.a(94), p: [__RΦ$d$2.a(86)] }) }, [94]: { LΦ: t => dist$2["IΦdefault"] }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Команда, которая выполняет другую команду.
	 * Есть возможность заменить выполняемую команду.
	 * Предназначена для создания повторяющихся команд.
	 */
	class BridgeCommand {
	    commandQueue;
	    internalCommand = new NotOperationCommand;
	    get name() {
	        return 'BridgeCommand: ' + this.internalCommand.name;
	    }
	    constructor(internalCommand) {
	        if (internalCommand) {
	            this.inject(internalCommand);
	        }
	    }
	    /**
	     * Внедрить команду.
	     * @param internalCommand
	     */
	    inject(internalCommand) {
	        this.internalCommand = internalCommand;
	    }
	    execute() {
	        if (this.commandQueue) {
	            this.internalCommand.commandQueue = this.commandQueue;
	        }
	        this.internalCommand.execute();
	    }
	}
	(t => __RΦ$d$2.t[87] = t)(BridgeCommand);
	__RΦ$d$2.m("rt:SP", [])(BridgeCommand);
	__RΦ$d$2.m("rt:P", ["commandQueue", "internalCommand", "name"])(BridgeCommand);
	__RΦ$d$2.m("rt:Sm", [])(BridgeCommand);
	__RΦ$d$2.m("rt:m", ["inject", "execute"])(BridgeCommand);
	__RΦ$d$2.m("rt:p", [{ n: "internalCommand", t: () => __RΦ$d$2.a(86), v: null, f: "?" }])(BridgeCommand);
	__RΦ$d$2.m("rt:i", [() => undefined])(BridgeCommand);
	__RΦ$d$2.m("rt:f", "Ce")(BridgeCommand);
	__RΦ$d$2.m("rt:t", () => __RΦ$d$2.a(97))(BridgeCommand.prototype, "commandQueue");
	__RΦ$d$2.m("rt:f", "P$?")(BridgeCommand.prototype, "commandQueue");
	__RΦ$d$2.m("rt:t", () => __RΦ$d$2.a(86))(BridgeCommand.prototype, "internalCommand");
	__RΦ$d$2.m("rt:f", "P#")(BridgeCommand.prototype, "internalCommand");
	__RΦ$d$2.m("rt:t", () => __RΦ$d$2.a(14))(BridgeCommand.prototype, "name");
	__RΦ$d$2.m("rt:f", "P$")(BridgeCommand.prototype, "name");
	__RΦ$d$2.m("rt:f", "M$.")(BridgeCommand.prototype["inject"]);
	((t, p) => __RΦ$d$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(BridgeCommand.prototype, "inject");
	__RΦ$d$2.m("rt:p", [{ n: "internalCommand", t: () => __RΦ$d$2.a(86), v: null }])(BridgeCommand.prototype, "inject");
	__RΦ$d$2.m("rt:f", "M$.")(BridgeCommand.prototype, "inject");
	__RΦ$d$2.m("rt:t", () => __RΦ$d$2.a(23))(BridgeCommand.prototype, "inject");
	__RΦ$d$2.m("rt:f", "M$.")(BridgeCommand.prototype["execute"]);
	((t, p) => __RΦ$d$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(BridgeCommand.prototype, "execute");
	__RΦ$d$2.m("rt:p", [])(BridgeCommand.prototype, "execute");
	__RΦ$d$2.m("rt:f", "M$.")(BridgeCommand.prototype, "execute");
	__RΦ$d$2.m("rt:t", () => __RΦ$d$2.a(23))(BridgeCommand.prototype, "execute");

	const __RΦ$c$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$c$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$c$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$c$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [290]: { RΦ: t => ({ TΦ: "[", e: __RΦ$c$2.a(86) }) }, [86]: { LΦ: t => dist$2["IΦdefault"] }, [97]: { RΦ: t => ({ TΦ: "g", t: __RΦ$c$2.a(94), p: [__RΦ$c$2.a(86)] }) }, [94]: { LΦ: t => dist$2["IΦdefault"] }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Макро-команда.
	 * Предназначена для создания набора команд, которые выполняются как одно целое.
	 * Используется для создания повторяющихся команд.
	 */
	class MacroCommand {
	    commands;
	    commandQueue;
	    get name() {
	        return 'MacroCommand: ' + (this.commands.map(command => command.name).join(', ') || '<empty>');
	    }
	    constructor(commands) {
	        this.commands = commands;
	    }
	    execute() {
	        for (const command of this.commands) {
	            if (this.commandQueue) {
	                command.commandQueue = this.commandQueue;
	            }
	            command.execute();
	        }
	    }
	}
	(t => __RΦ$c$2.t[287] = t)(MacroCommand);
	__RΦ$c$2.m("rt:SP", [])(MacroCommand);
	__RΦ$c$2.m("rt:P", ["commandQueue", "name", "commands"])(MacroCommand);
	__RΦ$c$2.m("rt:Sm", [])(MacroCommand);
	__RΦ$c$2.m("rt:m", ["execute"])(MacroCommand);
	__RΦ$c$2.m("rt:p", [{ n: "commands", t: () => __RΦ$c$2.a(290), v: null, f: "#" }])(MacroCommand);
	__RΦ$c$2.m("rt:i", [() => undefined])(MacroCommand);
	__RΦ$c$2.m("rt:f", "Ce")(MacroCommand);
	__RΦ$c$2.m("rt:t", () => __RΦ$c$2.a(97))(MacroCommand.prototype, "commandQueue");
	__RΦ$c$2.m("rt:f", "P$?")(MacroCommand.prototype, "commandQueue");
	__RΦ$c$2.m("rt:t", () => __RΦ$c$2.a(14))(MacroCommand.prototype, "name");
	__RΦ$c$2.m("rt:f", "P$")(MacroCommand.prototype, "name");
	__RΦ$c$2.m("rt:f", "M$")(MacroCommand.prototype["execute"]);
	((t, p) => __RΦ$c$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(MacroCommand.prototype, "execute");
	__RΦ$c$2.m("rt:p", [])(MacroCommand.prototype, "execute");
	__RΦ$c$2.m("rt:f", "M$")(MacroCommand.prototype, "execute");
	__RΦ$c$2.m("rt:t", () => __RΦ$c$2.a(23))(MacroCommand.prototype, "execute");

	const __RΦ$b$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$b$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$b$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$b$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [86]: { LΦ: t => undefined }, [97]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b$2.a(94), p: [__RΦ$b$2.a(86)] }) }, [94]: { LΦ: t => dist$2["IΦdefault"] }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Повторение команд.
	 *
	 * Данная команда просто добавляет требуемую команду в очередь.
	 * Предназначена для создания повторяющихся команд.
	 */
	class RepeatCommand {
	    targetCommand;
	    commandQueue;
	    get name() {
	        return 'RepeatCommand: ' + this.targetCommand.name;
	    }
	    /**
	     * Конструктор повторяющей команды.
	     * @param targetCommand
	     */
	    constructor(targetCommand) {
	        this.targetCommand = targetCommand;
	    }
	    execute() {
	        if (!this.commandQueue) {
	            throw new Error(`RepeatCommand: Не найдена очередь команд для добавления в нее команды '${this.targetCommand.name}'`);
	        }
	        // Внимание, очередь команд сама позаботится об определении свойства 'this.targetCommand.commandQueue'.
	        this.commandQueue.enqueue(this.targetCommand);
	    }
	}
	(t => __RΦ$b$2.t[350] = t)(RepeatCommand);
	__RΦ$b$2.m("rt:SP", [])(RepeatCommand);
	__RΦ$b$2.m("rt:P", ["commandQueue", "name", "targetCommand"])(RepeatCommand);
	__RΦ$b$2.m("rt:Sm", [])(RepeatCommand);
	__RΦ$b$2.m("rt:m", ["execute"])(RepeatCommand);
	__RΦ$b$2.m("rt:p", [{ n: "targetCommand", t: () => __RΦ$b$2.a(86), v: null, f: "#" }])(RepeatCommand);
	__RΦ$b$2.m("rt:i", [() => undefined])(RepeatCommand);
	__RΦ$b$2.m("rt:f", "Ce")(RepeatCommand);
	__RΦ$b$2.m("rt:t", () => __RΦ$b$2.a(97))(RepeatCommand.prototype, "commandQueue");
	__RΦ$b$2.m("rt:f", "P$?")(RepeatCommand.prototype, "commandQueue");
	__RΦ$b$2.m("rt:t", () => __RΦ$b$2.a(14))(RepeatCommand.prototype, "name");
	__RΦ$b$2.m("rt:f", "P$")(RepeatCommand.prototype, "name");
	__RΦ$b$2.m("rt:f", "M$")(RepeatCommand.prototype["execute"]);
	((t, p) => __RΦ$b$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(RepeatCommand.prototype, "execute");
	__RΦ$b$2.m("rt:p", [])(RepeatCommand.prototype, "execute");
	__RΦ$b$2.m("rt:f", "M$")(RepeatCommand.prototype, "execute");
	__RΦ$b$2.m("rt:t", () => __RΦ$b$2.a(23))(RepeatCommand.prototype, "execute");

	const __RΦ$a$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$a$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$a$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$a$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [364]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$a$2.a(14), __RΦ$a$2.a(363)] }) }, [14]: { LΦ: t => String }, [363]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a$2.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [315]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$a$2.a(10), __RΦ$a$2.a(14)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [376]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$a$2.a(315) }, { t: __RΦ$a$2.a(363) }] }) } } };
	/**
	 * Команда с пользовательской функцией.
	 *
	 * Так как данная команда может выполнять разные действия, в зависимости
	 * от пользовательской функции, то есть возможность изменять имя команды
	 * при помощи первого аргумента конструктора.
	 *
	 * @link https://metanit.com/sharp/wpf/22.3.php
	 * @link https://docs.microsoft.com/en-us/windows/communitytoolkit/mvvm/relaycommand
	 */
	class RelayCommand {
	    #name;
	    action;
	    get name() {
	        const prefix = 'RelayCommand';
	        return this.#name ? `${prefix}: ${this.#name}` : prefix;
	    }
	    /**
	     * Конструктор команды с пользовательской функцией.
	     * @param nameOrAction Имя команды или пользовательская функция.
	     * @param action Пользовательская функция.
	     */
	    constructor(nameOrAction, action) {
	        const [_name, _action] = parseConstructorArguments(nameOrAction, action);
	        this.#name = _name;
	        this.action = _action;
	    }
	    execute() {
	        this.action();
	    }
	}
	(t => __RΦ$a$2.t[366] = t)(RelayCommand);
	__RΦ$a$2.m("rt:SP", [])(RelayCommand);
	__RΦ$a$2.m("rt:P", ["#name", "action", "name"])(RelayCommand);
	__RΦ$a$2.m("rt:Sm", [])(RelayCommand);
	__RΦ$a$2.m("rt:m", ["execute"])(RelayCommand);
	__RΦ$a$2.m("rt:p", [{ n: "nameOrAction", t: () => __RΦ$a$2.a(364), v: null }, { n: "action", t: () => __RΦ$a$2.a(363), v: null, f: "?" }])(RelayCommand);
	__RΦ$a$2.m("rt:i", [() => undefined])(RelayCommand);
	__RΦ$a$2.m("rt:f", "Ce")(RelayCommand);
	__RΦ$a$2.m("rt:t", () => __RΦ$a$2.a(315))(RelayCommand.prototype, "#name");
	__RΦ$a$2.m("rt:f", "PR")(RelayCommand.prototype, "#name");
	__RΦ$a$2.m("rt:t", () => __RΦ$a$2.a(363))(RelayCommand.prototype, "action");
	__RΦ$a$2.m("rt:f", "P#R")(RelayCommand.prototype, "action");
	__RΦ$a$2.m("rt:t", () => __RΦ$a$2.a(14))(RelayCommand.prototype, "name");
	__RΦ$a$2.m("rt:f", "P$")(RelayCommand.prototype, "name");
	__RΦ$a$2.m("rt:f", "M$")(RelayCommand.prototype["execute"]);
	((t, p) => __RΦ$a$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(RelayCommand.prototype, "execute");
	__RΦ$a$2.m("rt:p", [])(RelayCommand.prototype, "execute");
	__RΦ$a$2.m("rt:f", "M$")(RelayCommand.prototype, "execute");
	__RΦ$a$2.m("rt:t", () => __RΦ$a$2.a(23))(RelayCommand.prototype, "execute");
	function parseConstructorArguments(nameOrAction, action) {
	    return (arguments.length === 1
	        ? [undefined, action]
	        : [nameOrAction, action]);
	}
	__RΦ$a$2.m("rt:p", [{ n: "nameOrAction", t: () => __RΦ$a$2.a(364), v: null }, { n: "action", t: () => __RΦ$a$2.a(363), v: null, f: "?" }])(parseConstructorArguments);
	__RΦ$a$2.m("rt:f", "F")(parseConstructorArguments);
	__RΦ$a$2.m("rt:t", () => __RΦ$a$2.a(376))(parseConstructorArguments);

	const __RΦ$9$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$9$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$9$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$9$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [86]: { LΦ: t => undefined }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Повторяемая команда.
	 *
	 * После выполнения команды targetCommand ставит себя в начало очереди.
	 * Можно остановить вызвав метод stop().
	 */
	class RepeatableCommand extends BridgeCommand {
	    targetCommand;
	    get name() {
	        return 'RepeatableCommand: ' + this.targetCommand.name;
	    }
	    constructor(targetCommand) {
	        super();
	        this.targetCommand = targetCommand;
	        this.inject(new MacroCommand([
	            targetCommand,
	            new RepeatCommand(this)
	        ]));
	    }
	    stop() {
	        this.inject(new NotOperationCommand);
	    }
	}
	(t => __RΦ$9$2.t[395] = t)(RepeatableCommand);
	__RΦ$9$2.m("rt:SP", [])(RepeatableCommand);
	__RΦ$9$2.m("rt:P", ["name", "targetCommand"])(RepeatableCommand);
	__RΦ$9$2.m("rt:Sm", [])(RepeatableCommand);
	__RΦ$9$2.m("rt:m", ["stop"])(RepeatableCommand);
	__RΦ$9$2.m("rt:p", [{ n: "targetCommand", t: () => __RΦ$9$2.a(86), v: null, f: "#" }])(RepeatableCommand);
	__RΦ$9$2.m("rt:i", [() => undefined])(RepeatableCommand);
	__RΦ$9$2.m("rt:f", "Ce")(RepeatableCommand);
	__RΦ$9$2.m("rt:t", () => __RΦ$9$2.a(14))(RepeatableCommand.prototype, "name");
	__RΦ$9$2.m("rt:f", "P$")(RepeatableCommand.prototype, "name");
	__RΦ$9$2.m("rt:f", "M$")(RepeatableCommand.prototype["stop"]);
	((t, p) => __RΦ$9$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(RepeatableCommand.prototype, "stop");
	__RΦ$9$2.m("rt:p", [])(RepeatableCommand.prototype, "stop");
	__RΦ$9$2.m("rt:f", "M$")(RepeatableCommand.prototype, "stop");
	__RΦ$9$2.m("rt:t", () => __RΦ$9$2.a(23))(RepeatableCommand.prototype, "stop");

	const __RΦ$8$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$8$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$8$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$8$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [86]: { LΦ: t => undefined } } };
	/**
	 * Функция для вывода имени команды в единообразном виде.
	 *
	 * Это требуется в ситуации: есть имя commandName и найденная по этому имени
	 * команда command. Если команда не найдена, то command === undefined.
	 * И требуется для отладки вывести имя команды.
	 *
	 * @param commandName Искомое имя команды.
	 * @param command Ссылка на команду, которая может быть не найдена.
	 */
	function commandFullName(commandName, command) {
	    const commandCommonName = (command
	        ? command.name
	        : 'Command not found');
	    return `${commandName}(${commandCommonName})`;
	}
	__RΦ$8$2.m("rt:p", [{ n: "commandName", t: () => __RΦ$8$2.a(14), v: null }, { n: "command", t: () => __RΦ$8$2.a(86), v: null, f: "?" }])(commandFullName);
	__RΦ$8$2.m("rt:f", "F")(commandFullName);
	__RΦ$8$2.m("rt:t", () => __RΦ$8$2.a(14))(commandFullName);

	const __RΦ$7$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$7$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$7$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$7$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [422]: { LΦ: t => undefined }, [431]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$7$2.a(10), __RΦ$7$2.a(430)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [430]: { RΦ: t => ({ TΦ: "g", t: __RΦ$7$2.a(426), p: [__RΦ$7$2.a(14), __RΦ$7$2.a(419)] }) }, [426]: { LΦ: t => Map }, [14]: { LΦ: t => String }, [419]: { LΦ: t => Object } } };
	class WithStoppableAdapter {
	    universalObject;
	    constructor(universalObject) {
	        this.universalObject = universalObject;
	    }
	    get stoppableMap() {
	        return this.universalObject.getValue('stoppableMap');
	    }
	    set stoppableMap(value) {
	        this.universalObject.setValue('stoppableMap', value);
	    }
	}
	(t => __RΦ$7$2.t[418] = t)(WithStoppableAdapter);
	__RΦ$7$2.m("rt:SP", [])(WithStoppableAdapter);
	__RΦ$7$2.m("rt:P", ["universalObject", "stoppableMap", "stoppableMap"])(WithStoppableAdapter);
	__RΦ$7$2.m("rt:Sm", [])(WithStoppableAdapter);
	__RΦ$7$2.m("rt:m", [])(WithStoppableAdapter);
	__RΦ$7$2.m("rt:p", [{ n: "universalObject", t: () => __RΦ$7$2.a(422), v: null, f: "#" }])(WithStoppableAdapter);
	__RΦ$7$2.m("rt:i", [() => undefined])(WithStoppableAdapter);
	__RΦ$7$2.m("rt:f", "Ce")(WithStoppableAdapter);
	__RΦ$7$2.m("rt:t", () => __RΦ$7$2.a(431))(WithStoppableAdapter.prototype, "stoppableMap");
	__RΦ$7$2.m("rt:f", "P$")(WithStoppableAdapter.prototype, "stoppableMap");
	__RΦ$7$2.m("rt:t", () => __RΦ$7$2.a(431))(WithStoppableAdapter.prototype, "stoppableMap");
	__RΦ$7$2.m("rt:f", "P$")(WithStoppableAdapter.prototype, "stoppableMap");

	const __RΦ$6$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$6$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$6$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$6$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [422]: { LΦ: t => undefined }, [620]: { RΦ: t => ({ TΦ: "&", t: [__RΦ$6$2.a(86), __RΦ$6$2.a(415)] }) }, [86]: { LΦ: t => dist$2["IΦdefault"] }, [415]: { LΦ: t => dist$2["IΦdefault"] }, [97]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$2.a(94), p: [__RΦ$6$2.a(86)] }) }, [94]: { LΦ: t => dist$2["IΦdefault"] }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [4]: { RΦ: t => ({ TΦ: "~" }) } } };
	/**
	 * Запуск команды, которую можно остановить.
	 */
	class StartCommand {
	    stoppableCommandName;
	    targetObject;
	    stoppableCommand;
	    commandQueue;
	    get name() {
	        return 'StartCommand: ' + this.stoppableCommandFullName;
	    }
	    /**
	     * Конструктор.
	     * @param stoppableCommandName Уникальное в рамках targetObject имя команды.
	     * @param targetObject Объект, в котором будет хранится ссылка на команду.
	     * @param stoppableCommand Команда, которую можно остановить.
	     */
	    constructor(stoppableCommandName, targetObject, stoppableCommand) {
	        this.stoppableCommandName = stoppableCommandName;
	        this.targetObject = targetObject;
	        this.stoppableCommand = stoppableCommand;
	    }
	    execute() {
	        if (this.stoppableCommandMap.has(this.stoppableCommandName)) {
	            throw new Error(`StartCommand: Попытка запустить повторно команду '${this.stoppableCommandFullName}'`);
	        }
	        if (!this.commandQueue) {
	            throw new Error(`StartCommand: Не найдена очередь команд для добавления в нее команды '${this.stoppableCommandFullName}'`);
	        }
	        this.commandQueue.enqueue(this.stoppableCommand);
	        // Сохранение ссылки на команду, чтобы была возможность ее остановить по ссылке.
	        this.stoppableCommandMap.set(this.stoppableCommandName, this.stoppableCommand);
	    }
	    get stoppableCommandMap() {
	        // https://github.com/typescript-rtti/typescript-rtti/issues/59
	        // Пока с адаптерами проблемы. Сложные адаптеры похоже не создать при помощи typescript-rtti.
	        // const withStoppable = resolve<IWithStoppable>('Adapter', this.targetObject, reflect<IWithStoppable>())
	        const withStoppable = new WithStoppableAdapter(this.targetObject);
	        if (!withStoppable.stoppableMap) {
	            withStoppable.stoppableMap = new Map;
	        }
	        return withStoppable.stoppableMap;
	    }
	    get stoppableCommandFullName() {
	        return commandFullName(this.stoppableCommandName, this.stoppableCommand);
	    }
	}
	(t => __RΦ$6$2.t[440] = t)(StartCommand);
	__RΦ$6$2.m("rt:SP", [])(StartCommand);
	__RΦ$6$2.m("rt:P", ["commandQueue", "name", "stoppableCommandName", "targetObject", "stoppableCommand", "stoppableCommandMap", "stoppableCommandFullName"])(StartCommand);
	__RΦ$6$2.m("rt:Sm", [])(StartCommand);
	__RΦ$6$2.m("rt:m", ["execute"])(StartCommand);
	__RΦ$6$2.m("rt:p", [{ n: "stoppableCommandName", t: () => __RΦ$6$2.a(14), v: null, f: "#R" }, { n: "targetObject", t: () => __RΦ$6$2.a(422), v: null, f: "#R" }, { n: "stoppableCommand", t: () => __RΦ$6$2.a(620), v: null, f: "#" }])(StartCommand);
	__RΦ$6$2.m("rt:i", [() => undefined])(StartCommand);
	__RΦ$6$2.m("rt:f", "Ce")(StartCommand);
	__RΦ$6$2.m("rt:t", () => __RΦ$6$2.a(97))(StartCommand.prototype, "commandQueue");
	__RΦ$6$2.m("rt:f", "P$?")(StartCommand.prototype, "commandQueue");
	__RΦ$6$2.m("rt:t", () => __RΦ$6$2.a(14))(StartCommand.prototype, "name");
	__RΦ$6$2.m("rt:f", "P$")(StartCommand.prototype, "name");
	__RΦ$6$2.m("rt:f", "M$")(StartCommand.prototype["execute"]);
	((t, p) => __RΦ$6$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(StartCommand.prototype, "execute");
	__RΦ$6$2.m("rt:p", [])(StartCommand.prototype, "execute");
	__RΦ$6$2.m("rt:f", "M$")(StartCommand.prototype, "execute");
	__RΦ$6$2.m("rt:t", () => __RΦ$6$2.a(23))(StartCommand.prototype, "execute");
	__RΦ$6$2.m("rt:t", () => __RΦ$6$2.a(4))(StartCommand.prototype, "stoppableCommandMap");
	__RΦ$6$2.m("rt:f", "P#")(StartCommand.prototype, "stoppableCommandMap");
	__RΦ$6$2.m("rt:t", () => __RΦ$6$2.a(14))(StartCommand.prototype, "stoppableCommandFullName");
	__RΦ$6$2.m("rt:f", "P#")(StartCommand.prototype, "stoppableCommandFullName");

	const __RΦ$5$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$5$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$5$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$5$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [422]: { LΦ: t => undefined }, [315]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$5$2.a(10), __RΦ$5$2.a(14)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [14]: { LΦ: t => String }, [632]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$5$2.a(10), __RΦ$5$2.a(620)] }) }, [620]: { RΦ: t => ({ TΦ: "&", t: [__RΦ$5$2.a(86), __RΦ$5$2.a(415)] }) }, [86]: { LΦ: t => dist$2["IΦdefault"] }, [415]: { LΦ: t => dist$2["IΦdefault"] }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Остановка команды, которую можно остановить.
	 */
	class StopCommand {
	    stoppableCommandName;
	    targetObject;
	    get name() {
	        return 'StopCommand: ' + this.stoppableCommandFullName;
	    }
	    get stoppableCommandFullName() {
	        return commandFullName(this.stoppableCommandName || 'All', this.stoppableCommand);
	    }
	    get stoppableCommand() {
	        return this.stoppableCommandName ? this.withStoppable.stoppableMap?.get(this.stoppableCommandName) : undefined;
	    }
	    get withStoppable() {
	        return new WithStoppableAdapter(this.targetObject);
	        //return resolve<IWithStoppable>('Adapter', this.targetObject, reflect<IWithStoppable>()) as IWithStoppable<ICommand & IStoppable>
	    }
	    constructor(stoppableCommandNameOrTargetObject, targetObject) {
	        if (arguments.length === 1 && isUniversalObject$1(stoppableCommandNameOrTargetObject)) {
	            this.stoppableCommandName = undefined;
	            this.targetObject = stoppableCommandNameOrTargetObject;
	        }
	        else if (typeof stoppableCommandNameOrTargetObject === 'string' && isUniversalObject$1(targetObject)) {
	            this.stoppableCommandName = stoppableCommandNameOrTargetObject;
	            this.targetObject = targetObject;
	        }
	        else {
	            throw new Error('Задана неправильные параметры');
	        }
	    }
	    execute() {
	        const stoppableCommandName = this.stoppableCommandName;
	        const stoppableCommand = this.stoppableCommand;
	        const stoppableMap = this.withStoppable.stoppableMap;
	        if (!stoppableMap) {
	            throw new Error('Не найдена карта останавливаемых команд');
	        }
	        if (stoppableCommandName) {
	            // Останавливается одна определенная команда.
	            if (!stoppableMap.has(stoppableCommandName) || !stoppableCommand) {
	                console.group(`StopCommand: Не найдена команда для остановки '${stoppableCommandName}'`);
	                console.log('Целевая команда:', this.stoppableCommandName);
	                console.log('Полное имя команды:', this.stoppableCommandFullName);
	                console.log('Целевой объект:', this.targetObject);
	                console.groupEnd();
	                throw new Error(`StopCommand: Не найдена команда для остановки '${stoppableCommandName}'`);
	            }
	            stoppableCommand.stop();
	            stoppableMap.delete(stoppableCommandName);
	        }
	        else {
	            // Останавливаются все команды.
	            for (const [stoppableCommandName, stoppableCommand] of stoppableMap.entries()) {
	                stoppableCommand.stop();
	                stoppableMap.delete(stoppableCommandName);
	            }
	        }
	    }
	}
	(t => __RΦ$5$2.t[627] = t)(StopCommand);
	__RΦ$5$2.m("rt:SP", [])(StopCommand);
	__RΦ$5$2.m("rt:P", ["stoppableCommandName", "targetObject", "name", "stoppableCommandFullName", "stoppableCommand", "withStoppable"])(StopCommand);
	__RΦ$5$2.m("rt:Sm", [])(StopCommand);
	__RΦ$5$2.m("rt:m", ["execute"])(StopCommand);
	__RΦ$5$2.m("rt:p", [{ n: "targetObject", t: () => __RΦ$5$2.a(422), v: null }])(StopCommand);
	__RΦ$5$2.m("rt:i", [() => undefined])(StopCommand);
	__RΦ$5$2.m("rt:f", "Ce")(StopCommand);
	__RΦ$5$2.m("rt:t", () => __RΦ$5$2.a(315))(StopCommand.prototype, "stoppableCommandName");
	__RΦ$5$2.m("rt:f", "P#R")(StopCommand.prototype, "stoppableCommandName");
	__RΦ$5$2.m("rt:t", () => __RΦ$5$2.a(422))(StopCommand.prototype, "targetObject");
	__RΦ$5$2.m("rt:f", "P#R")(StopCommand.prototype, "targetObject");
	__RΦ$5$2.m("rt:t", () => __RΦ$5$2.a(14))(StopCommand.prototype, "name");
	__RΦ$5$2.m("rt:f", "P$")(StopCommand.prototype, "name");
	__RΦ$5$2.m("rt:t", () => __RΦ$5$2.a(14))(StopCommand.prototype, "stoppableCommandFullName");
	__RΦ$5$2.m("rt:f", "P#")(StopCommand.prototype, "stoppableCommandFullName");
	__RΦ$5$2.m("rt:t", () => __RΦ$5$2.a(632))(StopCommand.prototype, "stoppableCommand");
	__RΦ$5$2.m("rt:f", "P#")(StopCommand.prototype, "stoppableCommand");
	__RΦ$5$2.m("rt:t", () => __RΦ$5$2.a(4))(StopCommand.prototype, "withStoppable");
	__RΦ$5$2.m("rt:f", "P#")(StopCommand.prototype, "withStoppable");
	__RΦ$5$2.m("rt:f", "M$")(StopCommand.prototype["execute"]);
	((t, p) => __RΦ$5$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(StopCommand.prototype, "execute");
	__RΦ$5$2.m("rt:p", [])(StopCommand.prototype, "execute");
	__RΦ$5$2.m("rt:f", "M$")(StopCommand.prototype, "execute");
	__RΦ$5$2.m("rt:t", () => __RΦ$5$2.a(23))(StopCommand.prototype, "execute");

	const __RΦ$4$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$4$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$4$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$4$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [422]: { LΦ: t => undefined }, [14]: { LΦ: t => String } } };
	// Нет возможности добраться до родительского интерфейса ITyped и в итоге свойство type недоступно для адаптера.
	// https://github.com/typescript-rtti/typescript-rtti/issues/60
	// const order = resolve<IOrder>('Adapter', orderObject, reflect<IOrder>())
	// Поэтому пришлось тут адаптер написать вручную.
	class OrderAdapter {
	    universalObject;
	    constructor(universalObject) {
	        this.universalObject = universalObject;
	    }
	    get type() {
	        return this.universalObject.getValue('type', 'UnknownType');
	    }
	    set type(value) {
	        this.universalObject.setValue('type', value);
	    }
	}
	(t => __RΦ$4$2.t[669] = t)(OrderAdapter);
	__RΦ$4$2.m("rt:SP", [])(OrderAdapter);
	__RΦ$4$2.m("rt:P", ["universalObject", "type", "type"])(OrderAdapter);
	__RΦ$4$2.m("rt:Sm", [])(OrderAdapter);
	__RΦ$4$2.m("rt:m", [])(OrderAdapter);
	__RΦ$4$2.m("rt:p", [{ n: "universalObject", t: () => __RΦ$4$2.a(422), v: null, f: "#" }])(OrderAdapter);
	__RΦ$4$2.m("rt:i", [() => undefined])(OrderAdapter);
	__RΦ$4$2.m("rt:f", "Ce")(OrderAdapter);
	__RΦ$4$2.m("rt:t", () => __RΦ$4$2.a(14))(OrderAdapter.prototype, "type");
	__RΦ$4$2.m("rt:f", "P$")(OrderAdapter.prototype, "type");
	__RΦ$4$2.m("rt:t", () => __RΦ$4$2.a(14))(OrderAdapter.prototype, "type");
	__RΦ$4$2.m("rt:f", "P$")(OrderAdapter.prototype, "type");

	const __RΦ$3$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$3$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$3$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$3$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [97]: { RΦ: t => ({ TΦ: "g", t: __RΦ$3$2.a(94), p: [__RΦ$3$2.a(86)] }) }, [94]: { LΦ: t => dist$2["IΦdefault"] }, [86]: { LΦ: t => dist$2["IΦdefault"] }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [422]: { LΦ: t => undefined } } };
	/**
	 * Интерпретация приказа от клиента.
	 *
	 * Приказ берется из очереди приказов 'OrderQueue' и конвертируется в команду.
	 * Команда приказа размещается в очереди команд.
	 * @link https://stepik.org/lesson/664251/step/1?unit=662137
	 */
	class InterpretOrderCommand {
	    name = 'InterpretOrderCommand';
	    commandQueue;
	    execute() {
	        const orderObject = resolve('OrderQueue').dequeue();
	        if (orderObject) {
	            const orderCommand = convertToCommand(orderObject);
	            this.commandQueue?.enqueue(orderCommand);
	        }
	    }
	}
	(t => __RΦ$3$2.t[688] = t)(InterpretOrderCommand);
	__RΦ$3$2.m("rt:SP", [])(InterpretOrderCommand);
	__RΦ$3$2.m("rt:P", ["name", "commandQueue"])(InterpretOrderCommand);
	__RΦ$3$2.m("rt:Sm", [])(InterpretOrderCommand);
	__RΦ$3$2.m("rt:m", ["execute"])(InterpretOrderCommand);
	__RΦ$3$2.m("rt:i", [() => undefined])(InterpretOrderCommand);
	__RΦ$3$2.m("rt:f", "Ce")(InterpretOrderCommand);
	__RΦ$3$2.m("rt:t", () => __RΦ$3$2.a(14))(InterpretOrderCommand.prototype, "name");
	__RΦ$3$2.m("rt:f", "P$R")(InterpretOrderCommand.prototype, "name");
	__RΦ$3$2.m("rt:t", () => __RΦ$3$2.a(97))(InterpretOrderCommand.prototype, "commandQueue");
	__RΦ$3$2.m("rt:f", "P$?")(InterpretOrderCommand.prototype, "commandQueue");
	__RΦ$3$2.m("rt:f", "M$")(InterpretOrderCommand.prototype["execute"]);
	((t, p) => __RΦ$3$2.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(InterpretOrderCommand.prototype, "execute");
	__RΦ$3$2.m("rt:p", [])(InterpretOrderCommand.prototype, "execute");
	__RΦ$3$2.m("rt:f", "M$")(InterpretOrderCommand.prototype, "execute");
	__RΦ$3$2.m("rt:t", () => __RΦ$3$2.a(23))(InterpretOrderCommand.prototype, "execute");
	function convertToCommand(orderObject) {
	    const order = new OrderAdapter(orderObject);
	    if (!order.type)
	        throw new Error('Не определен тип приказа');
	    return resolve(order.type, orderObject);
	}
	__RΦ$3$2.m("rt:p", [{ n: "orderObject", t: () => __RΦ$3$2.a(422), v: null }])(convertToCommand);
	__RΦ$3$2.m("rt:f", "F")(convertToCommand);
	__RΦ$3$2.m("rt:t", () => __RΦ$3$2.a(86))(convertToCommand);

	const __RΦ$2$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$2$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$2$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$2$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [695]: { LΦ: t => "StopCommand" }, [703]: { RΦ: t => ({ TΦ: "&", t: [__RΦ$2$3.a(677), __RΦ$2$3.a(701)] }) }, [677]: { LΦ: t => dist$2["IΦdefault"] }, [701]: { RΦ: t => ({ TΦ: "m", t: __RΦ$2$3.a(702), p: [__RΦ$2$3.a(14), __RΦ$2$3.a(1)] }) }, [702]: { LΦ: t => Object }, [14]: { LΦ: t => String }, [1]: { RΦ: t => ({ TΦ: "~" }) } } };
	var IΦdefault$f = { name: "IStopOrder", prototype: {}, identity: Symbol("IStopOrder (interface)") };
	(t => __RΦ$2$3.t[704] = t)(IΦdefault$f);
	__RΦ$2$3.m("rt:P", ["type", "targetObjectSearchData", "stoppableCommandName"])(IΦdefault$f);
	__RΦ$2$3.m("rt:m", [])(IΦdefault$f);
	__RΦ$2$3.m("rt:f", "Ie")(IΦdefault$f);
	__RΦ$2$3.m("rt:t", () => __RΦ$2$3.a(695))(IΦdefault$f.prototype, "type");
	__RΦ$2$3.m("rt:f", "P")(IΦdefault$f.prototype, "type");
	__RΦ$2$3.m("rt:t", () => __RΦ$2$3.a(703))(IΦdefault$f.prototype, "targetObjectSearchData");
	__RΦ$2$3.m("rt:f", "P")(IΦdefault$f.prototype, "targetObjectSearchData");
	__RΦ$2$3.m("rt:t", () => __RΦ$2$3.a(14))(IΦdefault$f.prototype, "stoppableCommandName");
	__RΦ$2$3.m("rt:f", "P")(IΦdefault$f.prototype, "stoppableCommandName");
	__RΦ$2$3.m("rt:t", () => __RΦ$2$3.a(695))(IΦdefault$f.prototype, "type");
	__RΦ$2$3.m("rt:f", "P")(IΦdefault$f.prototype, "type");
	__RΦ$2$3.m("rt:t", () => __RΦ$2$3.a(703))(IΦdefault$f.prototype, "targetObjectSearchData");
	__RΦ$2$3.m("rt:f", "P")(IΦdefault$f.prototype, "targetObjectSearchData");
	__RΦ$2$3.m("rt:t", () => __RΦ$2$3.a(14))(IΦdefault$f.prototype, "stoppableCommandName");
	__RΦ$2$3.m("rt:f", "P")(IΦdefault$f.prototype, "stoppableCommandName");

	const __RΦ$1$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$1$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$1$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$1$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [704]: { LΦ: t => IΦdefault$f }, [422]: { LΦ: t => undefined }, [627]: { LΦ: t => StopCommand }, [703]: { RΦ: t => ({ TΦ: "&", t: [__RΦ$1$3.a(677), __RΦ$1$3.a(701)] }) }, [677]: { LΦ: t => dist$2["IΦdefault"] }, [701]: { RΦ: t => ({ TΦ: "m", t: __RΦ$1$3.a(702), p: [__RΦ$1$3.a(14), __RΦ$1$3.a(1)] }) }, [702]: { LΦ: t => Object }, [14]: { LΦ: t => String }, [1]: { RΦ: t => ({ TΦ: "~" }) } } };
	// TODO Удалить!
	/**
	 * Функция для создания команды StopCommand на основе приказа.
	 *
	 * Приказ: createUniversalObject<IStopOrder>({type='StopCommand', ...})
	 * Зависимость: register('StopCommand', stopCommandResolver)
	 *
	 * @param stopOrderObject
	 */
	function stopCommandResolver$1(stopOrderObject) {
	    const stopOrder = resolve('Adapter', stopOrderObject, reflect(void 0, { TΦ: "c", t: void 0, p: [], r: void 0, tp: [__RΦ$1$3.a(704)] }));
	    const { stoppableCommandName, targetObjectSearchData } = stopOrder;
	    const targetObject = resolve(targetObjectSearchData.type, targetObjectSearchData);
	    if (!targetObject)
	        throw new NotFoundTargetObjectError(targetObjectSearchData);
	    return new StopCommand(stoppableCommandName, targetObject);
	}
	__RΦ$1$3.m("rt:p", [{ n: "stopOrderObject", t: () => __RΦ$1$3.a(422), v: null }])(stopCommandResolver$1);
	__RΦ$1$3.m("rt:f", "F")(stopCommandResolver$1);
	__RΦ$1$3.m("rt:t", () => __RΦ$1$3.a(627))(stopCommandResolver$1);
	class NotFoundTargetObjectError extends Error {
	    constructor(targetObjectSearchData) {
	        const message = `
			Для IStopOrder не найден targetObject 
			типа '${targetObjectSearchData.type}'
			с параметрами '${Object.entries(targetObjectSearchData).toString()}'
		`;
	        super(toOneLine$5(message));
	    }
	}
	(t => __RΦ$1$3.t[775] = t)(NotFoundTargetObjectError);
	__RΦ$1$3.m("rt:SP", [])(NotFoundTargetObjectError);
	__RΦ$1$3.m("rt:P", [])(NotFoundTargetObjectError);
	__RΦ$1$3.m("rt:Sm", [])(NotFoundTargetObjectError);
	__RΦ$1$3.m("rt:m", [])(NotFoundTargetObjectError);
	__RΦ$1$3.m("rt:p", [{ n: "targetObjectSearchData", t: () => __RΦ$1$3.a(703), v: null }])(NotFoundTargetObjectError);
	__RΦ$1$3.m("rt:f", "C")(NotFoundTargetObjectError);

	const __RΦ$x = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$x.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$x.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$x.t[id] = t = l;
	        }
	        return t;
	    }, t: { [793]: { RΦ: t => ({ TΦ: "g", t: __RΦ$x.a(94), p: [__RΦ$x.a(86)] }) }, [94]: { LΦ: t => dist$2["IΦdefault"] }, [86]: { LΦ: t => dist$2["IΦdefault"] } } };
	/**
	 * Создать очередь команд.
	 *
	 * Отличие от обычной очереди: перед добавление команды в очередь
	 * в свойство команды commandQueue помещается ссылка на саму очередь.
	 */
	function createCommandQueue() {
	    const commandQueueProxy = (new Proxy(new Queue$5, {
	        get(target, property, receiver) {
	            const origin = Reflect.get(target, property, receiver);
	            if (property === 'enqueue') {
	                const originEnqueue = origin;
	                return (function proxyEnqueue(...items) {
	                    items.forEach(item => item.commandQueue = commandQueueProxy);
	                    originEnqueue.call(target, ...items);
	                });
	            }
	            return origin;
	        }
	    }));
	    return commandQueueProxy;
	}
	__RΦ$x.m("rt:p", [])(createCommandQueue);
	__RΦ$x.m("rt:f", "F")(createCommandQueue);
	__RΦ$x.m("rt:t", () => __RΦ$x.a(793))(createCommandQueue);

	const __RΦ$w = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$w.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$w.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$w.t[id] = t = l;
	        }
	        return t;
	    }, t: { [327]: { LΦ: t => "StartMoveTransform" }, [838]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$w.a(777), __RΦ$w.a(790), __RΦ$w.a(804), __RΦ$w.a(818), __RΦ$w.a(834), __RΦ$w.a(837)] }) }, [777]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$w.a(754) }, { t: __RΦ$w.a(15) }] }) }, [754]: { LΦ: t => "IncreaseForce" }, [15]: { LΦ: t => Number }, [790]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$w.a(778) }, { t: __RΦ$w.a(15) }] }) }, [778]: { LΦ: t => "DecreaseForce" }, [804]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$w.a(791) }, { t: __RΦ$w.a(15) }] }) }, [791]: { LΦ: t => "ClockwiseRotateForce" }, [818]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$w.a(805) }, { t: __RΦ$w.a(15) }] }) }, [805]: { LΦ: t => "CounterclockwiseRotateForce" }, [834]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$w.a(819) }, { t: __RΦ$w.a(821) }] }) }, [819]: { LΦ: t => "ToroidalPositionTransformation" }, [821]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$w.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [837]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$w.a(835) }] }) }, [835]: { LΦ: t => "UnknownTransformAction" }, [88]: { RΦ: t => ({ TΦ: "O", m: [{ n: "type", f: "", t: __RΦ$w.a(14) }, { n: "name", f: "", t: __RΦ$w.a(14) }] }) }, [14]: { LΦ: t => String }, [87]: { LΦ: t => undefined }, [632]: { LΦ: t => undefined }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$e = { name: "IStartMoveTransformOrder", prototype: {}, identity: Symbol("IStartMoveTransformOrder (interface)") };
	(t => __RΦ$w.t[743] = t)(IΦdefault$e);
	__RΦ$w.m("rt:P", ["type", "transformAction", "targetObject"])(IΦdefault$e);
	__RΦ$w.m("rt:m", [])(IΦdefault$e);
	__RΦ$w.m("rt:f", "Ie")(IΦdefault$e);
	__RΦ$w.m("rt:t", () => __RΦ$w.a(327))(IΦdefault$e.prototype, "type");
	__RΦ$w.m("rt:f", "P")(IΦdefault$e.prototype, "type");
	__RΦ$w.m("rt:t", () => __RΦ$w.a(838))(IΦdefault$e.prototype, "transformAction");
	__RΦ$w.m("rt:f", "P")(IΦdefault$e.prototype, "transformAction");
	__RΦ$w.m("rt:t", () => __RΦ$w.a(88))(IΦdefault$e.prototype, "targetObject");
	__RΦ$w.m("rt:f", "P")(IΦdefault$e.prototype, "targetObject");
	__RΦ$w.m("rt:t", () => __RΦ$w.a(327))(IΦdefault$e.prototype, "type");
	__RΦ$w.m("rt:f", "P")(IΦdefault$e.prototype, "type");
	__RΦ$w.m("rt:t", () => __RΦ$w.a(838))(IΦdefault$e.prototype, "transformAction");
	__RΦ$w.m("rt:f", "P")(IΦdefault$e.prototype, "transformAction");
	__RΦ$w.m("rt:t", () => __RΦ$w.a(88))(IΦdefault$e.prototype, "targetObject");
	__RΦ$w.m("rt:f", "P")(IΦdefault$e.prototype, "targetObject");
	class StartMoveTransformOrderAdapter {
	    universalObject;
	    type = 'StartMoveTransform';
	    constructor(universalObject) {
	        this.universalObject = universalObject;
	    }
	    get transformAction() {
	        return this.universalObject.getValue('transformAction', ['UnknownTransformAction']);
	    }
	    set transformAction(value) {
	        this.universalObject.setValue('transformAction', value);
	    }
	    get targetObject() {
	        return this.universalObject.getValue('targetObject', {
	            type: '',
	            name: ''
	        });
	    }
	    set targetObject(value) {
	        this.universalObject.setValue('targetObject', value);
	    }
	}
	(t => __RΦ$w.t[2627] = t)(StartMoveTransformOrderAdapter);
	__RΦ$w.m("rt:SP", [])(StartMoveTransformOrderAdapter);
	__RΦ$w.m("rt:P", ["type", "universalObject", "transformAction", "transformAction", "targetObject", "targetObject"])(StartMoveTransformOrderAdapter);
	__RΦ$w.m("rt:Sm", [])(StartMoveTransformOrderAdapter);
	__RΦ$w.m("rt:m", [])(StartMoveTransformOrderAdapter);
	__RΦ$w.m("rt:p", [{ n: "universalObject", t: () => __RΦ$w.a(87), v: null, f: "#" }])(StartMoveTransformOrderAdapter);
	__RΦ$w.m("rt:i", [() => IΦIStartMoveTransformOrder])(StartMoveTransformOrderAdapter);
	__RΦ$w.m("rt:f", "C")(StartMoveTransformOrderAdapter);
	__RΦ$w.m("rt:t", () => __RΦ$w.a(4))(StartMoveTransformOrderAdapter.prototype, "type");
	__RΦ$w.m("rt:f", "P$R")(StartMoveTransformOrderAdapter.prototype, "type");
	__RΦ$w.m("rt:t", () => __RΦ$w.a(838))(StartMoveTransformOrderAdapter.prototype, "transformAction");
	__RΦ$w.m("rt:f", "P$")(StartMoveTransformOrderAdapter.prototype, "transformAction");
	__RΦ$w.m("rt:t", () => __RΦ$w.a(838))(StartMoveTransformOrderAdapter.prototype, "transformAction");
	__RΦ$w.m("rt:f", "P$")(StartMoveTransformOrderAdapter.prototype, "transformAction");
	__RΦ$w.m("rt:t", () => __RΦ$w.a(88))(StartMoveTransformOrderAdapter.prototype, "targetObject");
	__RΦ$w.m("rt:f", "P$")(StartMoveTransformOrderAdapter.prototype, "targetObject");
	__RΦ$w.m("rt:t", () => __RΦ$w.a(88))(StartMoveTransformOrderAdapter.prototype, "targetObject");
	__RΦ$w.m("rt:f", "P$")(StartMoveTransformOrderAdapter.prototype, "targetObject");
	function startMoveTransformCommandResolver(startMoveTransformOrderObject) {
	    const startMoveTransformOrder = new StartMoveTransformOrderAdapter(startMoveTransformOrderObject);
	    const targetObject = (resolve(startMoveTransformOrder.targetObject.type, startMoveTransformOrder.targetObject));
	    if (!targetObject) {
	        throw new Error(`Целевой объект не найден '${JSON.stringify(startMoveTransformOrder.targetObject)}'`);
	    }
	    const [transformName, ...transformParams] = startMoveTransformOrder.transformAction;
	    return (new StartCommand('MoveTransform.' + transformName, targetObject, new RepeatableCommand(new RelayCommand('MoveTransformAction.' + transformName, __RΦ$w.f(() => {
	        const transform = (resolve('MoveTransformAction.' + transformName, ...transformParams));
	        transform(new MovableAdapter(targetObject));
	    }, [__RΦ$w.m("rt:p", []), __RΦ$w.m("rt:f", "F>"), __RΦ$w.m("rt:t", () => __RΦ$w.a(23))], "")))));
	}
	__RΦ$w.m("rt:p", [{ n: "startMoveTransformOrderObject", t: () => __RΦ$w.a(87), v: null }])(startMoveTransformCommandResolver);
	__RΦ$w.m("rt:f", "F")(startMoveTransformCommandResolver);
	__RΦ$w.m("rt:t", () => __RΦ$w.a(632))(startMoveTransformCommandResolver);

	const __RΦ$v = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$v.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$v.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$v.t[id] = t = l;
	        }
	        return t;
	    }, t: { [324]: { LΦ: t => "StartMove" }, [88]: { RΦ: t => ({ TΦ: "O", m: [{ n: "type", f: "", t: __RΦ$v.a(14) }, { n: "name", f: "", t: __RΦ$v.a(14) }] }) }, [14]: { LΦ: t => String }, [87]: { LΦ: t => undefined }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [632]: { LΦ: t => undefined } } };
	var IΦdefault$d = { name: "IStartMoveOrder", prototype: {}, identity: Symbol("IStartMoveOrder (interface)") };
	(t => __RΦ$v.t[728] = t)(IΦdefault$d);
	__RΦ$v.m("rt:P", ["type", "targetObject"])(IΦdefault$d);
	__RΦ$v.m("rt:m", [])(IΦdefault$d);
	__RΦ$v.m("rt:f", "Ie")(IΦdefault$d);
	__RΦ$v.m("rt:t", () => __RΦ$v.a(324))(IΦdefault$d.prototype, "type");
	__RΦ$v.m("rt:f", "P")(IΦdefault$d.prototype, "type");
	__RΦ$v.m("rt:t", () => __RΦ$v.a(88))(IΦdefault$d.prototype, "targetObject");
	__RΦ$v.m("rt:f", "P")(IΦdefault$d.prototype, "targetObject");
	__RΦ$v.m("rt:t", () => __RΦ$v.a(324))(IΦdefault$d.prototype, "type");
	__RΦ$v.m("rt:f", "P")(IΦdefault$d.prototype, "type");
	__RΦ$v.m("rt:t", () => __RΦ$v.a(88))(IΦdefault$d.prototype, "targetObject");
	__RΦ$v.m("rt:f", "P")(IΦdefault$d.prototype, "targetObject");
	class StartMoveOrderAdapter {
	    universalObject;
	    type = 'StartMove';
	    constructor(universalObject) {
	        this.universalObject = universalObject;
	    }
	    get targetObject() {
	        return this.universalObject.getValue('targetObject', {
	            type: '',
	            name: ''
	        });
	    }
	    set targetObject(value) {
	        this.universalObject.setValue('targetObject', value);
	    }
	}
	(t => __RΦ$v.t[1150] = t)(StartMoveOrderAdapter);
	__RΦ$v.m("rt:SP", [])(StartMoveOrderAdapter);
	__RΦ$v.m("rt:P", ["type", "universalObject", "targetObject", "targetObject"])(StartMoveOrderAdapter);
	__RΦ$v.m("rt:Sm", [])(StartMoveOrderAdapter);
	__RΦ$v.m("rt:m", [])(StartMoveOrderAdapter);
	__RΦ$v.m("rt:p", [{ n: "universalObject", t: () => __RΦ$v.a(87), v: null, f: "#" }])(StartMoveOrderAdapter);
	__RΦ$v.m("rt:i", [() => IΦIStartMoveOrder])(StartMoveOrderAdapter);
	__RΦ$v.m("rt:f", "Ce")(StartMoveOrderAdapter);
	__RΦ$v.m("rt:t", () => __RΦ$v.a(4))(StartMoveOrderAdapter.prototype, "type");
	__RΦ$v.m("rt:f", "P$R")(StartMoveOrderAdapter.prototype, "type");
	__RΦ$v.m("rt:t", () => __RΦ$v.a(88))(StartMoveOrderAdapter.prototype, "targetObject");
	__RΦ$v.m("rt:f", "P$")(StartMoveOrderAdapter.prototype, "targetObject");
	__RΦ$v.m("rt:t", () => __RΦ$v.a(88))(StartMoveOrderAdapter.prototype, "targetObject");
	__RΦ$v.m("rt:f", "P$")(StartMoveOrderAdapter.prototype, "targetObject");
	function startMoveCommandResolver(startMoveOrderObject) {
	    const startMoveOrder = new StartMoveOrderAdapter(startMoveOrderObject);
	    const targetObject = (resolve(startMoveOrder.targetObject.type, startMoveOrder.targetObject));
	    if (!targetObject) {
	        throw new Error(`Целевой объект не найден '${JSON.stringify(startMoveOrder.targetObject)}'`);
	    }
	    return (new StartCommand('MoveCommand', targetObject, new RepeatableCommand(new MoveCommand(new MovableAdapter(targetObject)))));
	}
	__RΦ$v.m("rt:p", [{ n: "startMoveOrderObject", t: () => __RΦ$v.a(87), v: null }])(startMoveCommandResolver);
	__RΦ$v.m("rt:f", "F")(startMoveCommandResolver);
	__RΦ$v.m("rt:t", () => __RΦ$v.a(632))(startMoveCommandResolver);

	const __RΦ$u = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$u.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$u.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$u.t[id] = t = l;
	        }
	        return t;
	    }, t: { [321]: { LΦ: t => "Destroy" }, [88]: { RΦ: t => ({ TΦ: "O", m: [{ n: "type", f: "", t: __RΦ$u.a(14) }, { n: "name", f: "", t: __RΦ$u.a(14) }] }) }, [14]: { LΦ: t => String }, [87]: { LΦ: t => undefined }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [632]: { LΦ: t => undefined }, [649]: { RΦ: t => ({ TΦ: "g", t: __RΦ$u.a(352), p: [__RΦ$u.a(632)] }) }, [352]: { LΦ: t => dist$3["IΦdefault"] }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$c = { name: "IDestroyOrder", prototype: {}, identity: Symbol("IDestroyOrder (interface)") };
	(t => __RΦ$u.t[1149] = t)(IΦdefault$c);
	__RΦ$u.m("rt:P", ["type", "targetObject"])(IΦdefault$c);
	__RΦ$u.m("rt:m", [])(IΦdefault$c);
	__RΦ$u.m("rt:f", "Ie")(IΦdefault$c);
	__RΦ$u.m("rt:t", () => __RΦ$u.a(321))(IΦdefault$c.prototype, "type");
	__RΦ$u.m("rt:f", "P")(IΦdefault$c.prototype, "type");
	__RΦ$u.m("rt:t", () => __RΦ$u.a(88))(IΦdefault$c.prototype, "targetObject");
	__RΦ$u.m("rt:f", "P")(IΦdefault$c.prototype, "targetObject");
	__RΦ$u.m("rt:t", () => __RΦ$u.a(321))(IΦdefault$c.prototype, "type");
	__RΦ$u.m("rt:f", "P")(IΦdefault$c.prototype, "type");
	__RΦ$u.m("rt:t", () => __RΦ$u.a(88))(IΦdefault$c.prototype, "targetObject");
	__RΦ$u.m("rt:f", "P")(IΦdefault$c.prototype, "targetObject");
	class DestroyOrderAdapter {
	    universalObject;
	    type = 'Destroy';
	    constructor(universalObject) {
	        this.universalObject = universalObject;
	    }
	    get targetObject() {
	        return this.universalObject.getValue('targetObject', {
	            type: '',
	            name: ''
	        });
	    }
	    set targetObject(value) {
	        this.universalObject.setValue('targetObject', value);
	    }
	}
	(t => __RΦ$u.t[1114] = t)(DestroyOrderAdapter);
	__RΦ$u.m("rt:SP", [])(DestroyOrderAdapter);
	__RΦ$u.m("rt:P", ["type", "universalObject", "targetObject", "targetObject"])(DestroyOrderAdapter);
	__RΦ$u.m("rt:Sm", [])(DestroyOrderAdapter);
	__RΦ$u.m("rt:m", [])(DestroyOrderAdapter);
	__RΦ$u.m("rt:p", [{ n: "universalObject", t: () => __RΦ$u.a(87), v: null, f: "#" }])(DestroyOrderAdapter);
	__RΦ$u.m("rt:i", [() => IΦIDestroyOrder])(DestroyOrderAdapter);
	__RΦ$u.m("rt:f", "Ce")(DestroyOrderAdapter);
	__RΦ$u.m("rt:t", () => __RΦ$u.a(4))(DestroyOrderAdapter.prototype, "type");
	__RΦ$u.m("rt:f", "P$R")(DestroyOrderAdapter.prototype, "type");
	__RΦ$u.m("rt:t", () => __RΦ$u.a(88))(DestroyOrderAdapter.prototype, "targetObject");
	__RΦ$u.m("rt:f", "P$")(DestroyOrderAdapter.prototype, "targetObject");
	__RΦ$u.m("rt:t", () => __RΦ$u.a(88))(DestroyOrderAdapter.prototype, "targetObject");
	__RΦ$u.m("rt:f", "P$")(DestroyOrderAdapter.prototype, "targetObject");
	function destroyCommandResolver(destroyOrderObject) {
	    const destroyOrder = new DestroyOrderAdapter(destroyOrderObject);
	    const targetObject = (resolve(destroyOrder.targetObject.type, destroyOrder.targetObject));
	    if (!targetObject) {
	        throw new Error(`Целевой объект не найден '${JSON.stringify(destroyOrder.targetObject)}'`);
	    }
	    return new DestroyCommand(targetObject);
	}
	__RΦ$u.m("rt:p", [{ n: "destroyOrderObject", t: () => __RΦ$u.a(87), v: null }])(destroyCommandResolver);
	__RΦ$u.m("rt:f", "F")(destroyCommandResolver);
	__RΦ$u.m("rt:t", () => __RΦ$u.a(632))(destroyCommandResolver);
	class DestroyCommand {
	    targetObject;
	    name = 'DestroyCommand';
	    commandQueue;
	    constructor(targetObject) {
	        this.targetObject = targetObject;
	    }
	    execute() {
	        const commandQueue = this.commandQueue;
	        if (!commandQueue) {
	            throw new Error('Не найдена очередь команд');
	        }
	        const stopCommand = new StopCommand(this.targetObject);
	        const commandQueueEventEmitter = resolve('CommandQueue.EventEmitter');
	        // Создать обработчик события execute.
	        // Это нужно, чтобы отследить момент, когда команда stopCommand остановила
	        // все команды целевого объекта. Так как только после этого можно удалить сам целевой объект.
	        const onStopCommandExecute = __RΦ$u.f((command) => {
	            if (command === stopCommand) {
	                // Удаление обработчика события execute.
	                commandQueueEventEmitter.removeListener('execute', onStopCommandExecute);
	                // Удаление целевого объекта.
	                const gameObjectList = resolve('GameObjectList');
	                const targetObjectIndex = gameObjectList.indexOf(this.targetObject);
	                if (targetObjectIndex === -1) {
	                    throw new Error(`Целевой объект не найден '${JSON.stringify(this.targetObject)}'`);
	                }
	                gameObjectList.splice(targetObjectIndex, 1);
	            }
	        }, [__RΦ$u.m("rt:p", [{ n: "command", t: () => __RΦ$u.a(632), v: null }]), __RΦ$u.m("rt:f", "F>"), __RΦ$u.m("rt:t", () => __RΦ$u.a(23))], "onStopCommandExecute");
	        commandQueueEventEmitter.on('execute', onStopCommandExecute);
	        // Размещение команды stopCommand в очередеь команд.
	        commandQueue.enqueue(stopCommand);
	    }
	}
	(t => __RΦ$u.t[1128] = t)(DestroyCommand);
	__RΦ$u.m("rt:SP", [])(DestroyCommand);
	__RΦ$u.m("rt:P", ["name", "commandQueue", "targetObject"])(DestroyCommand);
	__RΦ$u.m("rt:Sm", [])(DestroyCommand);
	__RΦ$u.m("rt:m", ["execute"])(DestroyCommand);
	__RΦ$u.m("rt:p", [{ n: "targetObject", t: () => __RΦ$u.a(87), v: null, f: "#" }])(DestroyCommand);
	__RΦ$u.m("rt:i", [() => undefined])(DestroyCommand);
	__RΦ$u.m("rt:f", "C")(DestroyCommand);
	__RΦ$u.m("rt:t", () => __RΦ$u.a(14))(DestroyCommand.prototype, "name");
	__RΦ$u.m("rt:f", "P$R")(DestroyCommand.prototype, "name");
	__RΦ$u.m("rt:t", () => __RΦ$u.a(649))(DestroyCommand.prototype, "commandQueue");
	__RΦ$u.m("rt:f", "P$?")(DestroyCommand.prototype, "commandQueue");
	__RΦ$u.m("rt:f", "M$")(DestroyCommand.prototype["execute"]);
	((t, p) => __RΦ$u.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(DestroyCommand.prototype, "execute");
	__RΦ$u.m("rt:p", [])(DestroyCommand.prototype, "execute");
	__RΦ$u.m("rt:f", "M$")(DestroyCommand.prototype, "execute");
	__RΦ$u.m("rt:t", () => __RΦ$u.a(23))(DestroyCommand.prototype, "execute");

	var dist$1 = {};

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(index_es);

	var require$$1 = /*@__PURE__*/getAugmentedNamespace(index_es$1);

	Object.defineProperty(dist$1, '__esModule', { value: true });

	var khusamovBaseTypes = require$$0;
	var khusamovInversionOfControl = require$$1;

	var dist = {};

	var events = {exports: {}};

	var R = typeof Reflect === 'object' ? Reflect : null;
	var ReflectApply = R && typeof R.apply === 'function'
	  ? R.apply
	  : function ReflectApply(target, receiver, args) {
	    return Function.prototype.apply.call(target, receiver, args);
	  };

	var ReflectOwnKeys;
	if (R && typeof R.ownKeys === 'function') {
	  ReflectOwnKeys = R.ownKeys;
	} else if (Object.getOwnPropertySymbols) {
	  ReflectOwnKeys = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target)
	      .concat(Object.getOwnPropertySymbols(target));
	  };
	} else {
	  ReflectOwnKeys = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target);
	  };
	}

	function ProcessEmitWarning(warning) {
	  if (console && console.warn) console.warn(warning);
	}

	var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
	  return value !== value;
	};

	function EventEmitter$1() {
	  EventEmitter$1.init.call(this);
	}
	events.exports = EventEmitter$1;
	events.exports.once = once;

	// Backwards-compat with node 0.10.x
	EventEmitter$1.EventEmitter = EventEmitter$1;

	EventEmitter$1.prototype._events = undefined;
	EventEmitter$1.prototype._eventsCount = 0;
	EventEmitter$1.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	var defaultMaxListeners = 10;

	function checkListener(listener) {
	  if (typeof listener !== 'function') {
	    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
	  }
	}

	Object.defineProperty(EventEmitter$1, 'defaultMaxListeners', {
	  enumerable: true,
	  get: function() {
	    return defaultMaxListeners;
	  },
	  set: function(arg) {
	    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
	      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
	    }
	    defaultMaxListeners = arg;
	  }
	});

	EventEmitter$1.init = function() {

	  if (this._events === undefined ||
	      this._events === Object.getPrototypeOf(this)._events) {
	    this._events = Object.create(null);
	    this._eventsCount = 0;
	  }

	  this._maxListeners = this._maxListeners || undefined;
	};

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n) {
	  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
	    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
	  }
	  this._maxListeners = n;
	  return this;
	};

	function _getMaxListeners(that) {
	  if (that._maxListeners === undefined)
	    return EventEmitter$1.defaultMaxListeners;
	  return that._maxListeners;
	}

	EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
	  return _getMaxListeners(this);
	};

	EventEmitter$1.prototype.emit = function emit(type) {
	  var args = [];
	  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
	  var doError = (type === 'error');

	  var events = this._events;
	  if (events !== undefined)
	    doError = (doError && events.error === undefined);
	  else if (!doError)
	    return false;

	  // If there is no 'error' event listener then throw.
	  if (doError) {
	    var er;
	    if (args.length > 0)
	      er = args[0];
	    if (er instanceof Error) {
	      // Note: The comments on the `throw` lines are intentional, they show
	      // up in Node's output if this results in an unhandled exception.
	      throw er; // Unhandled 'error' event
	    }
	    // At least give some kind of context to the user
	    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
	    err.context = er;
	    throw err; // Unhandled 'error' event
	  }

	  var handler = events[type];

	  if (handler === undefined)
	    return false;

	  if (typeof handler === 'function') {
	    ReflectApply(handler, this, args);
	  } else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      ReflectApply(listeners[i], this, args);
	  }

	  return true;
	};

	function _addListener(target, type, listener, prepend) {
	  var m;
	  var events;
	  var existing;

	  checkListener(listener);

	  events = target._events;
	  if (events === undefined) {
	    events = target._events = Object.create(null);
	    target._eventsCount = 0;
	  } else {
	    // To avoid recursion in the case that type === "newListener"! Before
	    // adding it to the listeners, first emit "newListener".
	    if (events.newListener !== undefined) {
	      target.emit('newListener', type,
	                  listener.listener ? listener.listener : listener);

	      // Re-assign `events` because a newListener handler could have caused the
	      // this._events to be assigned to a new object
	      events = target._events;
	    }
	    existing = events[type];
	  }

	  if (existing === undefined) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    existing = events[type] = listener;
	    ++target._eventsCount;
	  } else {
	    if (typeof existing === 'function') {
	      // Adding the second element, need to change to array.
	      existing = events[type] =
	        prepend ? [listener, existing] : [existing, listener];
	      // If we've already got an array, just append.
	    } else if (prepend) {
	      existing.unshift(listener);
	    } else {
	      existing.push(listener);
	    }

	    // Check for listener leak
	    m = _getMaxListeners(target);
	    if (m > 0 && existing.length > m && !existing.warned) {
	      existing.warned = true;
	      // No error code for this since it is a Warning
	      // eslint-disable-next-line no-restricted-syntax
	      var w = new Error('Possible EventEmitter memory leak detected. ' +
	                          existing.length + ' ' + String(type) + ' listeners ' +
	                          'added. Use emitter.setMaxListeners() to ' +
	                          'increase limit');
	      w.name = 'MaxListenersExceededWarning';
	      w.emitter = target;
	      w.type = type;
	      w.count = existing.length;
	      ProcessEmitWarning(w);
	    }
	  }

	  return target;
	}

	EventEmitter$1.prototype.addListener = function addListener(type, listener) {
	  return _addListener(this, type, listener, false);
	};

	EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;

	EventEmitter$1.prototype.prependListener =
	    function prependListener(type, listener) {
	      return _addListener(this, type, listener, true);
	    };

	function onceWrapper() {
	  if (!this.fired) {
	    this.target.removeListener(this.type, this.wrapFn);
	    this.fired = true;
	    if (arguments.length === 0)
	      return this.listener.call(this.target);
	    return this.listener.apply(this.target, arguments);
	  }
	}

	function _onceWrap(target, type, listener) {
	  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
	  var wrapped = onceWrapper.bind(state);
	  wrapped.listener = listener;
	  state.wrapFn = wrapped;
	  return wrapped;
	}

	EventEmitter$1.prototype.once = function once(type, listener) {
	  checkListener(listener);
	  this.on(type, _onceWrap(this, type, listener));
	  return this;
	};

	EventEmitter$1.prototype.prependOnceListener =
	    function prependOnceListener(type, listener) {
	      checkListener(listener);
	      this.prependListener(type, _onceWrap(this, type, listener));
	      return this;
	    };

	// Emits a 'removeListener' event if and only if the listener was removed.
	EventEmitter$1.prototype.removeListener =
	    function removeListener(type, listener) {
	      var list, events, position, i, originalListener;

	      checkListener(listener);

	      events = this._events;
	      if (events === undefined)
	        return this;

	      list = events[type];
	      if (list === undefined)
	        return this;

	      if (list === listener || list.listener === listener) {
	        if (--this._eventsCount === 0)
	          this._events = Object.create(null);
	        else {
	          delete events[type];
	          if (events.removeListener)
	            this.emit('removeListener', type, list.listener || listener);
	        }
	      } else if (typeof list !== 'function') {
	        position = -1;

	        for (i = list.length - 1; i >= 0; i--) {
	          if (list[i] === listener || list[i].listener === listener) {
	            originalListener = list[i].listener;
	            position = i;
	            break;
	          }
	        }

	        if (position < 0)
	          return this;

	        if (position === 0)
	          list.shift();
	        else {
	          spliceOne(list, position);
	        }

	        if (list.length === 1)
	          events[type] = list[0];

	        if (events.removeListener !== undefined)
	          this.emit('removeListener', type, originalListener || listener);
	      }

	      return this;
	    };

	EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;

	EventEmitter$1.prototype.removeAllListeners =
	    function removeAllListeners(type) {
	      var listeners, events, i;

	      events = this._events;
	      if (events === undefined)
	        return this;

	      // not listening for removeListener, no need to emit
	      if (events.removeListener === undefined) {
	        if (arguments.length === 0) {
	          this._events = Object.create(null);
	          this._eventsCount = 0;
	        } else if (events[type] !== undefined) {
	          if (--this._eventsCount === 0)
	            this._events = Object.create(null);
	          else
	            delete events[type];
	        }
	        return this;
	      }

	      // emit removeListener for all listeners on all events
	      if (arguments.length === 0) {
	        var keys = Object.keys(events);
	        var key;
	        for (i = 0; i < keys.length; ++i) {
	          key = keys[i];
	          if (key === 'removeListener') continue;
	          this.removeAllListeners(key);
	        }
	        this.removeAllListeners('removeListener');
	        this._events = Object.create(null);
	        this._eventsCount = 0;
	        return this;
	      }

	      listeners = events[type];

	      if (typeof listeners === 'function') {
	        this.removeListener(type, listeners);
	      } else if (listeners !== undefined) {
	        // LIFO order
	        for (i = listeners.length - 1; i >= 0; i--) {
	          this.removeListener(type, listeners[i]);
	        }
	      }

	      return this;
	    };

	function _listeners(target, type, unwrap) {
	  var events = target._events;

	  if (events === undefined)
	    return [];

	  var evlistener = events[type];
	  if (evlistener === undefined)
	    return [];

	  if (typeof evlistener === 'function')
	    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

	  return unwrap ?
	    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
	}

	EventEmitter$1.prototype.listeners = function listeners(type) {
	  return _listeners(this, type, true);
	};

	EventEmitter$1.prototype.rawListeners = function rawListeners(type) {
	  return _listeners(this, type, false);
	};

	EventEmitter$1.listenerCount = function(emitter, type) {
	  if (typeof emitter.listenerCount === 'function') {
	    return emitter.listenerCount(type);
	  } else {
	    return listenerCount.call(emitter, type);
	  }
	};

	EventEmitter$1.prototype.listenerCount = listenerCount;
	function listenerCount(type) {
	  var events = this._events;

	  if (events !== undefined) {
	    var evlistener = events[type];

	    if (typeof evlistener === 'function') {
	      return 1;
	    } else if (evlistener !== undefined) {
	      return evlistener.length;
	    }
	  }

	  return 0;
	}

	EventEmitter$1.prototype.eventNames = function eventNames() {
	  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
	};

	function arrayClone(arr, n) {
	  var copy = new Array(n);
	  for (var i = 0; i < n; ++i)
	    copy[i] = arr[i];
	  return copy;
	}

	function spliceOne(list, index) {
	  for (; index + 1 < list.length; index++)
	    list[index] = list[index + 1];
	  list.pop();
	}

	function unwrapListeners(arr) {
	  var ret = new Array(arr.length);
	  for (var i = 0; i < ret.length; ++i) {
	    ret[i] = arr[i].listener || arr[i];
	  }
	  return ret;
	}

	function once(emitter, name) {
	  return new Promise(function (resolve, reject) {
	    function errorListener(err) {
	      emitter.removeListener(name, resolver);
	      reject(err);
	    }

	    function resolver() {
	      if (typeof emitter.removeListener === 'function') {
	        emitter.removeListener('error', errorListener);
	      }
	      resolve([].slice.call(arguments));
	    }
	    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
	    if (name !== 'error') {
	      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
	    }
	  });
	}

	function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
	  if (typeof emitter.on === 'function') {
	    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
	  }
	}

	function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
	  if (typeof emitter.on === 'function') {
	    if (flags.once) {
	      emitter.once(name, listener);
	    } else {
	      emitter.on(name, listener);
	    }
	  } else if (typeof emitter.addEventListener === 'function') {
	    // EventTarget does not have `error` event semantics like Node
	    // EventEmitters, we do not listen for `error` events here.
	    emitter.addEventListener(name, function wrapListener(arg) {
	      // IE does not have builtin `{ once: true }` support so we
	      // have to do it manually.
	      if (flags.once) {
	        emitter.removeEventListener(name, wrapListener);
	      }
	      listener(arg);
	    });
	  } else {
	    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
	  }
	}

	Object.defineProperty(dist, '__esModule', { value: true });

	var EventEmitter = events.exports;

	function _interopDefaultLegacy$1 (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy$1(EventEmitter);

	const __RΦ$r = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$r.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$r.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$r.t[id] = t = l;
	        }
	        return t;
	    }, t: { [95]: { LΦ: t => SyntaxError }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Обработчик синтаксической ошибки в коде source.
	 * @param error
	 * @param source
	 */
	function syntaxErrorHandler(error, source) {
	    console.group('Синтаксическая ошибка');
	    console.log(error.message);
	    console.log(source);
	    console.log(error.stack);
	    console.groupEnd();
	}
	__RΦ$r.m("rt:p", [{ n: "error", t: () => __RΦ$r.a(95), v: null }, { n: "source", t: () => __RΦ$r.a(14), v: null }])(syntaxErrorHandler);
	__RΦ$r.m("rt:f", "F")(syntaxErrorHandler);
	__RΦ$r.m("rt:t", () => __RΦ$r.a(23))(syntaxErrorHandler);

	const __RΦ$q = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$q.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$q.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$q.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [112]: { LΦ: t => Object } } };
	/**
	 * Выполнить скрипт из текста, который возвращает значение типа T.
	 * @param source
	 */
	function execFunctionScript(source) {
	    if (!source.trim()) {
	        throw new Error('Не задано тело функции');
	    }
	    try {
	        const code = new Function('', `return (${source})`);
	        return code();
	    }
	    catch (error) {
	        if (error instanceof SyntaxError) {
	            syntaxErrorHandler(error, source);
	        }
	        throw error;
	    }
	}
	__RΦ$q.m("rt:p", [{ n: "source", t: () => __RΦ$q.a(14), v: null }])(execFunctionScript);
	__RΦ$q.m("rt:f", "F")(execFunctionScript);
	__RΦ$q.m("rt:t", () => __RΦ$q.a(112))(execFunctionScript);

	const __RΦ$p = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$p.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$p.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$p.t[id] = t = l;
	        }
	        return t;
	    }, t: { [113]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$p.a(10), __RΦ$p.a(14)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [14]: { LΦ: t => String }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Выполнить скрипт из текста, который ничего не возвращает.
	 * @param source
	 */
	function execActionScript(source) {
	    if (source) {
	        try {
	            const code = new Function('', source);
	            code();
	        }
	        catch (error) {
	            if (error instanceof SyntaxError) {
	                syntaxErrorHandler(error, source);
	            }
	            throw error;
	        }
	    }
	}
	__RΦ$p.m("rt:p", [{ n: "source", t: () => __RΦ$p.a(113), v: null }])(execActionScript);
	__RΦ$p.m("rt:f", "F")(execActionScript);
	__RΦ$p.m("rt:t", () => __RΦ$p.a(23))(execActionScript);

	const __RΦ$o = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$o.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$o.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$o.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String } } };
	const SPACE = ' ';
	const EOL = '\n';
	const trim = __RΦ$o.f((message) => message.trim()
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	, [__RΦ$o.m("rt:p", [{ n: "message", t: () => __RΦ$o.a(14), v: null }]), __RΦ$o.m("rt:f", "F>"), __RΦ$o.m("rt:t", () => __RΦ$o.a(14))], "trim");
	/**
	 * Собрать мультистроковый текст в одну строку без лишних
	 * пробельных символов (переносы, табы и т.п.).
	 * @param message
	 */
	function toOneLine(message) {
	    return message.trim().split(EOL).map(trim).join(SPACE);
	}
	__RΦ$o.m("rt:p", [{ n: "message", t: () => __RΦ$o.a(14), v: null }])(toOneLine);
	__RΦ$o.m("rt:f", "F")(toOneLine);
	__RΦ$o.m("rt:t", () => __RΦ$o.a(14))(toOneLine);

	const __RΦ$n = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$n.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$n.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$n.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1]: { RΦ: t => ({ TΦ: "~" }) } } };
	function isBrowser() {
	    return new Function('try { return this === window } catch (e) { return false }')();
	}
	__RΦ$n.m("rt:p", [])(isBrowser);
	__RΦ$n.m("rt:f", "F")(isBrowser);
	__RΦ$n.m("rt:t", () => __RΦ$n.a(1))(isBrowser);

	const __RΦ$m = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$m.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$m.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$m.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [21]: { LΦ: t => Boolean } } };
	var IΦdefault$9 = { name: "IStoppable", prototype: {}, identity: Symbol("IStoppable (interface)") };
	(t => __RΦ$m.t[150] = t)(IΦdefault$9);
	__RΦ$m.m("rt:P", [])(IΦdefault$9);
	__RΦ$m.m("rt:m", ["stop"])(IΦdefault$9);
	__RΦ$m.m("rt:f", "Ie")(IΦdefault$9);
	__RΦ$m.m("rt:p", [])(IΦdefault$9.prototype, "stop");
	__RΦ$m.m("rt:f", "M")(IΦdefault$9.prototype, "stop");
	__RΦ$m.m("rt:t", () => __RΦ$m.a(23))(IΦdefault$9.prototype, "stop");
	__RΦ$m.m("rt:p", [])(IΦdefault$9.prototype, "stop");
	__RΦ$m.m("rt:f", "M")(IΦdefault$9.prototype, "stop");
	__RΦ$m.m("rt:t", () => __RΦ$m.a(23))(IΦdefault$9.prototype, "stop");
	function isStoppable(object) {
	    return 'stop' in object && typeof object.stop === 'function';
	}
	__RΦ$m.m("rt:p", [{ n: "object", t: () => __RΦ$m.a(1), v: null }])(isStoppable);
	__RΦ$m.m("rt:f", "F")(isStoppable);
	__RΦ$m.m("rt:t", () => __RΦ$m.a(21))(isStoppable);

	const __RΦ$l = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$l.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$l.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$l.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$8 = { name: "IStartable", prototype: {}, identity: Symbol("IStartable (interface)") };
	(t => __RΦ$l.t[149] = t)(IΦdefault$8);
	__RΦ$l.m("rt:P", [])(IΦdefault$8);
	__RΦ$l.m("rt:m", ["start"])(IΦdefault$8);
	__RΦ$l.m("rt:f", "Ie")(IΦdefault$8);
	__RΦ$l.m("rt:p", [])(IΦdefault$8.prototype, "start");
	__RΦ$l.m("rt:f", "M")(IΦdefault$8.prototype, "start");
	__RΦ$l.m("rt:t", () => __RΦ$l.a(23))(IΦdefault$8.prototype, "start");
	__RΦ$l.m("rt:p", [])(IΦdefault$8.prototype, "start");
	__RΦ$l.m("rt:f", "M")(IΦdefault$8.prototype, "start");
	__RΦ$l.m("rt:t", () => __RΦ$l.a(23))(IΦdefault$8.prototype, "start");

	/**
	 * Состояния таймера.
	 */
	var ETimerState;
	(function (ETimerState) {
	    ETimerState["Started"] = "started";
	    ETimerState["Paused"] = "paused";
	    ETimerState["Stopped"] = "stopped";
	})(ETimerState || (ETimerState = {}));

	const __RΦ$k = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$k.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$k.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$k.t[id] = t = l;
	        }
	        return t;
	    }, t: { [666]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$k.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [667]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$k.a(4) }] }) }, [668]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$k.a(4) }] }) } } };
	var IΦdefault$7 = { name: "IStateHandlers", prototype: {}, identity: Symbol("IStateHandlers (interface)") };
	(t => __RΦ$k.t[669] = t)(IΦdefault$7);
	__RΦ$k.m("rt:P", ["started", "paused", "stopped"])(IΦdefault$7);
	__RΦ$k.m("rt:m", [])(IΦdefault$7);
	__RΦ$k.m("rt:f", "Ie")(IΦdefault$7);
	__RΦ$k.m("rt:t", () => __RΦ$k.a(666))(IΦdefault$7.prototype, "started");
	__RΦ$k.m("rt:f", "P?")(IΦdefault$7.prototype, "started");
	__RΦ$k.m("rt:t", () => __RΦ$k.a(667))(IΦdefault$7.prototype, "paused");
	__RΦ$k.m("rt:f", "P?")(IΦdefault$7.prototype, "paused");
	__RΦ$k.m("rt:t", () => __RΦ$k.a(668))(IΦdefault$7.prototype, "stopped");
	__RΦ$k.m("rt:f", "P?")(IΦdefault$7.prototype, "stopped");
	__RΦ$k.m("rt:t", () => __RΦ$k.a(666))(IΦdefault$7.prototype, "started");
	__RΦ$k.m("rt:f", "P?")(IΦdefault$7.prototype, "started");
	__RΦ$k.m("rt:t", () => __RΦ$k.a(667))(IΦdefault$7.prototype, "paused");
	__RΦ$k.m("rt:f", "P?")(IΦdefault$7.prototype, "paused");
	__RΦ$k.m("rt:t", () => __RΦ$k.a(668))(IΦdefault$7.prototype, "stopped");
	__RΦ$k.m("rt:f", "P?")(IΦdefault$7.prototype, "stopped");

	const __RΦ$j = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$j.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$j.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$j.t[id] = t = l;
	        }
	        return t;
	    }, t: { [689]: { RΦ: t => ({ TΦ: "e", e: ETimerState }) }, [673]: { RΦ: t => ({ TΦ: "g", t: __RΦ$j.a(669), p: [__RΦ$j.a(672)] }) }, [669]: { LΦ: t => IΦdefault$7 }, [672]: { LΦ: t => Object }, [690]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$j.a(10), __RΦ$j.a(672)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	/**
	 * Запустить определенный скрипт в зависимости от состояния таймера.
	 * @param state Текущее состояние таймера.
	 * @param stateHandlers Массив скриптов (ключ - имя состояния, значение - скрипт).
	 */
	function handleByState(state, stateHandlers) {
	    switch (state) {
	        case ETimerState.Started: return stateHandlers.started ? stateHandlers.started() : undefined;
	        case ETimerState.Paused: return stateHandlers.paused ? stateHandlers.paused() : undefined;
	        case ETimerState.Stopped: return stateHandlers.stopped ? stateHandlers.stopped() : undefined;
	    }
	}
	__RΦ$j.m("rt:p", [{ n: "state", t: () => __RΦ$j.a(689), v: null }, { n: "stateHandlers", t: () => __RΦ$j.a(673), v: null }])(handleByState);
	__RΦ$j.m("rt:f", "F")(handleByState);
	__RΦ$j.m("rt:t", () => __RΦ$j.a(690))(handleByState);

	const __RΦ$i = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$i.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$i.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$i.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [1603]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$i.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1551]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$i.a(10), __RΦ$i.a(15)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [689]: { RΦ: t => ({ TΦ: "e", e: ETimerState }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * Простая реализация таймера.
	 */
	class Timer {
	    timeout;
	    action;
	    timerId;
	    /**
	     * Время запуска таймера. В миллисекундах.
	     * @private
	     */
	    time = 0;
	    /**
	     * Время постановки на паузу. В миллисекундах.
	     * @private
	     */
	    pauseTime = 0;
	    /**
	     * Общее время остановки таймера. В миллисекундах.
	     * @private
	     */
	    pauseInterval = 0;
	    /**
	     * Текущее состояние таймера
	     * @private
	     */
	    state = ETimerState.Stopped;
	    /**
	     * Внимание, внутри action определена this как Timer.
	     * @param timeout
	     * @param action
	     */
	    constructor(timeout, action) {
	        this.timeout = timeout;
	        this.action = action;
	    }
	    /**
	     * Запуск таймера.
	     * Стартовать таймер сначала или продолжить с паузы.
	     */
	    start() {
	        handleByState(this.state, {
	            paused: __RΦ$i.f(() => {
	                this.state = ETimerState.Started;
	                this.pauseInterval += Date.now() - this.pauseTime;
	            }, [__RΦ$i.m("rt:p", []), __RΦ$i.m("rt:f", "F>"), __RΦ$i.m("rt:t", () => __RΦ$i.a(23))], "paused"),
	            stopped: __RΦ$i.f(() => {
	                this.state = ETimerState.Started;
	                this.timerId = window.setInterval(this.tick.bind(this), this.timeout);
	                this.time = Date.now();
	            }, [__RΦ$i.m("rt:p", []), __RΦ$i.m("rt:f", "F>"), __RΦ$i.m("rt:t", () => __RΦ$i.a(23))], "stopped")
	        });
	    }
	    /**
	     * Поставить на паузу таймер.
	     * Состояние сохраняется, счет приостанавливается.
	     */
	    pause() {
	        handleByState(this.state, {
	            started: __RΦ$i.f(() => {
	                this.state = ETimerState.Paused;
	                this.pauseTime = Date.now();
	            }, [__RΦ$i.m("rt:p", []), __RΦ$i.m("rt:f", "F>"), __RΦ$i.m("rt:t", () => __RΦ$i.a(23))], "started")
	        });
	    }
	    /**
	     * Остановить таймер.
	     * Полный сброс таймера.
	     */
	    stop() {
	        const stop = __RΦ$i.f(() => {
	            this.state = ETimerState.Stopped;
	            clearInterval(this.timerId);
	            this.timerId = undefined;
	            this.time = 0;
	        }, [__RΦ$i.m("rt:p", []), __RΦ$i.m("rt:f", "F>"), __RΦ$i.m("rt:t", () => __RΦ$i.a(23))], "stop");
	        handleByState(this.state, {
	            started: stop,
	            paused: stop
	        });
	    }
	    /**
	     * Количество миллисекунд с начала старта таймера.
	     * С учетом всех пауз.
	     */
	    get interval() {
	        const result = handleByState(this.state, {
	            started: () => Date.now() - this.time - this.pauseTime,
	            paused: () => this.time - this.pauseTime,
	            stopped: () => 0
	        });
	        return result === undefined ? 0 : result;
	    }
	    /**
	     * Выполняемая нагрузка таймера.
	     * @private
	     */
	    tick() {
	        handleByState(this.state, {
	            started: __RΦ$i.f(() => this.action.call(this), [__RΦ$i.m("rt:p", []), __RΦ$i.m("rt:f", "F>"), __RΦ$i.m("rt:t", () => __RΦ$i.a(23))], "started")
	        });
	    }
	}
	(t => __RΦ$i.t[692] = t)(Timer);
	__RΦ$i.m("rt:SP", [])(Timer);
	__RΦ$i.m("rt:P", ["timerId", "time", "pauseTime", "pauseInterval", "state", "timeout", "action", "interval"])(Timer);
	__RΦ$i.m("rt:Sm", [])(Timer);
	__RΦ$i.m("rt:m", ["start", "pause", "stop", "tick"])(Timer);
	__RΦ$i.m("rt:p", [{ n: "timeout", t: () => __RΦ$i.a(15), v: null, f: "#" }, { n: "action", t: () => __RΦ$i.a(1603), v: null, f: "#" }])(Timer);
	__RΦ$i.m("rt:i", [() => undefined, () => undefined])(Timer);
	__RΦ$i.m("rt:f", "Ce")(Timer);
	__RΦ$i.m("rt:t", () => __RΦ$i.a(1551))(Timer.prototype, "timerId");
	__RΦ$i.m("rt:f", "P#")(Timer.prototype, "timerId");
	__RΦ$i.m("rt:t", () => __RΦ$i.a(15))(Timer.prototype, "time");
	__RΦ$i.m("rt:f", "P#")(Timer.prototype, "time");
	__RΦ$i.m("rt:t", () => __RΦ$i.a(15))(Timer.prototype, "pauseTime");
	__RΦ$i.m("rt:f", "P#")(Timer.prototype, "pauseTime");
	__RΦ$i.m("rt:t", () => __RΦ$i.a(15))(Timer.prototype, "pauseInterval");
	__RΦ$i.m("rt:f", "P#")(Timer.prototype, "pauseInterval");
	__RΦ$i.m("rt:t", () => __RΦ$i.a(689))(Timer.prototype, "state");
	__RΦ$i.m("rt:f", "P#")(Timer.prototype, "state");
	__RΦ$i.m("rt:f", "M$.")(Timer.prototype["start"]);
	((t, p) => __RΦ$i.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer.prototype, "start");
	__RΦ$i.m("rt:p", [])(Timer.prototype, "start");
	__RΦ$i.m("rt:f", "M$.")(Timer.prototype, "start");
	__RΦ$i.m("rt:t", () => __RΦ$i.a(23))(Timer.prototype, "start");
	__RΦ$i.m("rt:f", "M$.")(Timer.prototype["pause"]);
	((t, p) => __RΦ$i.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer.prototype, "pause");
	__RΦ$i.m("rt:p", [])(Timer.prototype, "pause");
	__RΦ$i.m("rt:f", "M$.")(Timer.prototype, "pause");
	__RΦ$i.m("rt:t", () => __RΦ$i.a(23))(Timer.prototype, "pause");
	__RΦ$i.m("rt:f", "M$.")(Timer.prototype["stop"]);
	((t, p) => __RΦ$i.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer.prototype, "stop");
	__RΦ$i.m("rt:p", [])(Timer.prototype, "stop");
	__RΦ$i.m("rt:f", "M$.")(Timer.prototype, "stop");
	__RΦ$i.m("rt:t", () => __RΦ$i.a(23))(Timer.prototype, "stop");
	__RΦ$i.m("rt:t", () => __RΦ$i.a(15))(Timer.prototype, "interval");
	__RΦ$i.m("rt:f", "P$")(Timer.prototype, "interval");
	__RΦ$i.m("rt:f", "M#.")(Timer.prototype["tick"]);
	((t, p) => __RΦ$i.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Timer.prototype, "tick");
	__RΦ$i.m("rt:p", [])(Timer.prototype, "tick");
	__RΦ$i.m("rt:f", "M#.")(Timer.prototype, "tick");
	__RΦ$i.m("rt:t", () => __RΦ$i.a(23))(Timer.prototype, "tick");

	const __RΦ$h = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$h.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$h.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$h.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1607]: { LΦ: t => Object } } };
	var IΦdefault$6 = { name: "ICreator", prototype: {}, identity: Symbol("ICreator (interface)") };
	(t => __RΦ$h.t[1608] = t)(IΦdefault$6);
	__RΦ$h.m("rt:P", [])(IΦdefault$6);
	__RΦ$h.m("rt:m", ["create"])(IΦdefault$6);
	__RΦ$h.m("rt:f", "Ie")(IΦdefault$6);
	__RΦ$h.m("rt:p", [])(IΦdefault$6.prototype, "create");
	__RΦ$h.m("rt:f", "M")(IΦdefault$6.prototype, "create");
	__RΦ$h.m("rt:t", () => __RΦ$h.a(1607))(IΦdefault$6.prototype, "create");
	__RΦ$h.m("rt:p", [])(IΦdefault$6.prototype, "create");
	__RΦ$h.m("rt:f", "M")(IΦdefault$6.prototype, "create");
	__RΦ$h.m("rt:t", () => __RΦ$h.a(1607))(IΦdefault$6.prototype, "create");

	const __RΦ$g = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$g.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$g.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$g.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1610]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$g.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1618]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$g.a(10), __RΦ$g.a(1612)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1612]: { LΦ: t => Object }, [1615]: { RΦ: t => ({ TΦ: "g", t: __RΦ$g.a(1608), p: [__RΦ$g.a(1612)] }) }, [1608]: { LΦ: t => IΦdefault$6 } } };
	/**
	 * Отложенная инициализация.
	 * @link https://metanit.com/sharp/tutorial/20.1.php
	 * @link https://docs.microsoft.com/ru-ru/dotnet/api/system.lazy-1?view=net-5.0
	 */
	class Lazy {
	    createFn;
	    #value;
	    #creator;
	    constructor(createFn) {
	        this.createFn = createFn;
	        this.#creator = {
	            create() {
	                return createFn();
	            }
	        };
	    }
	    get value() {
	        if (!this.#value) {
	            this.#value = this.#creator.create();
	        }
	        return this.#value;
	    }
	}
	(t => __RΦ$g.t[1611] = t)(Lazy);
	__RΦ$g.m("rt:SP", [])(Lazy);
	__RΦ$g.m("rt:P", ["#value", "#creator", "createFn", "value"])(Lazy);
	__RΦ$g.m("rt:Sm", [])(Lazy);
	__RΦ$g.m("rt:m", [])(Lazy);
	__RΦ$g.m("rt:p", [{ n: "createFn", t: () => __RΦ$g.a(1610), v: null, f: "#" }])(Lazy);
	__RΦ$g.m("rt:f", "Ce")(Lazy);
	__RΦ$g.m("rt:t", () => __RΦ$g.a(1618))(Lazy.prototype, "#value");
	__RΦ$g.m("rt:f", "P")(Lazy.prototype, "#value");
	__RΦ$g.m("rt:t", () => __RΦ$g.a(1615))(Lazy.prototype, "#creator");
	__RΦ$g.m("rt:f", "P")(Lazy.prototype, "#creator");
	__RΦ$g.m("rt:t", () => __RΦ$g.a(1612))(Lazy.prototype, "value");
	__RΦ$g.m("rt:f", "P")(Lazy.prototype, "value");

	const __RΦ$f = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$f.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$f.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$f.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	var IΦdefault$5 = { name: "IPoint", prototype: {}, identity: Symbol("IPoint (interface)") };
	(t => __RΦ$f.t[141] = t)(IΦdefault$5);
	__RΦ$f.m("rt:P", ["x", "y"])(IΦdefault$5);
	__RΦ$f.m("rt:m", [])(IΦdefault$5);
	__RΦ$f.m("rt:f", "Ie")(IΦdefault$5);
	__RΦ$f.m("rt:t", () => __RΦ$f.a(15))(IΦdefault$5.prototype, "x");
	__RΦ$f.m("rt:f", "P")(IΦdefault$5.prototype, "x");
	__RΦ$f.m("rt:t", () => __RΦ$f.a(15))(IΦdefault$5.prototype, "y");
	__RΦ$f.m("rt:f", "P")(IΦdefault$5.prototype, "y");
	__RΦ$f.m("rt:t", () => __RΦ$f.a(15))(IΦdefault$5.prototype, "x");
	__RΦ$f.m("rt:f", "P")(IΦdefault$5.prototype, "x");
	__RΦ$f.m("rt:t", () => __RΦ$f.a(15))(IΦdefault$5.prototype, "y");
	__RΦ$f.m("rt:f", "P")(IΦdefault$5.prototype, "y");

	const __RΦ$e = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$e.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$e.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$e.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number }, [141]: { LΦ: t => IΦdefault$5 }, [1627]: { TΦ: "5", name: "default" }, [21]: { LΦ: t => Boolean }, [1636]: { RΦ: t => ({ TΦ: "[", e: __RΦ$e.a(15) }) }, [14]: { LΦ: t => String } } };
	/*
	 * Увеличить длину вектора можно так:
	 * Vector.translate(Vector.identity.scale(length))
	 *
	 */
	/**
	 * Вектор.
	 * @unmutable
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/vector/Vector.js
	 * @link https://github.com/khusamov/extjs-cad-2d/blob/master/packages/local/khusamov-svg/src/geometry/Point.js
	 */
	class Vector {
	    x;
	    y;
	    /**
	     * Расстояние от начала координат до точки.
	     */
	    static distance(point) {
	        // noinspection JSSuspiciousNameCombination
	        return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
	    }
	    /**
	     * Создать вектор на основе угла и длины.
	     */
	    static create(angle, length) {
	        return new Vector(length * Math.cos(angle), length * Math.sin(angle));
	    }
	    /**
	     * Угол между вектором и положительной осью.
	     * Принимает значение от -Math.PI до Math.PI радиан.
	     */
	    get angle() {
	        return Math.atan2(this.y, this.x);
	    }
	    /**
	     * Модуль (длина) вектора.
	     */
	    get length() {
	        return Vector.distance(this);
	    }
	    /**
	     * Возвращает true, если вектор является нулевым.
	     */
	    get isNull() {
	        return this.x === 0 && this.y === 0;
	    }
	    /**
	     * Конструктор вектора.
	     * @param x
	     * @param y
	     */
	    constructor(x = 0, y = 0) {
	        this.x = x;
	        this.y = y;
	    }
	    /**
	     * Получить единичный вектор, равный по направлению исходному.
	     * Он же направляющий вектор (единичный, равный по направлению).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get identity() {
	        return (new Vector(Math.cos(this.angle), Math.sin(this.angle)));
	    }
	    /**
	     * Получить обратный вектор (инверсия вектора).
	     */
	    get inverse() {
	        return new Vector(-this.x, -this.y);
	    }
	    /**
	     * Нормаль вектора (единичный вектор, перпендикулярный исходному).
	     * Создается новый вектор, а исходный вектор не меняется.
	     */
	    get normal() {
	        return this.clone().rotate(Math.PI / 2).identity;
	        // TODO Проверить эту формулу нахождения перпендикулярного вектора.
	        /*
	            a: 1 / parallel.x(),
	            b: -1 / parallel.y(),
	        */
	    }
	    /**
	     * Сложение векторов.
	     * @param vector
	     */
	    translate(vector) {
	        return new Vector(this.x + vector.x, this.y + vector.y);
	    }
	    /**
	     * Вращение вектора.
	     * @param angle
	     */
	    rotate(angle) {
	        return new Vector(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle));
	    }
	    /**
	     * Умножение вектора на число.
	     */
	    scale(scale) {
	        return new Vector(this.x * scale, this.y * scale);
	    }
	    /**
	     * Скалярное произведение векторов.
	     * @param vector
	     */
	    multiply(vector) {
	        return new Vector(this.x * vector.x, this.y * vector.y);
	    }
	    /**
	     * Взятие остатка от деления.
	     * @param vector
	     */
	    mod(vector) {
	        return new Vector(this.x % vector.x, this.y % vector.y);
	    }
	    clone() {
	        return new Vector(this.x, this.y);
	    }
	    toArray() {
	        return [this.x, this.y];
	    }
	    toString(digits = 2) {
	        return `[${this.x.toFixed(digits)}, ${this.y.toFixed(digits)}]`;
	    }
	}
	(t => __RΦ$e.t[1627] = t)(Vector);
	__RΦ$e.m("rt:SP", [])(Vector);
	__RΦ$e.m("rt:P", ["angle", "length", "isNull", "x", "y", "identity", "inverse", "normal"])(Vector);
	__RΦ$e.m("rt:Sm", ["distance", "create"])(Vector);
	__RΦ$e.m("rt:m", ["translate", "rotate", "scale", "multiply", "mod", "clone", "toArray", "toString"])(Vector);
	__RΦ$e.m("rt:p", [{ n: "x", t: () => __RΦ$e.a(15), v: function () { return 0; }, f: "$R" }, { n: "y", t: () => __RΦ$e.a(15), v: function () { return 0; }, f: "$R" }])(Vector);
	__RΦ$e.m("rt:i", [() => undefined])(Vector);
	__RΦ$e.m("rt:f", "Ce")(Vector);
	__RΦ$e.m("rt:f", "M$S")(Vector["distance"]);
	((t, p) => __RΦ$e.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector, "distance");
	__RΦ$e.m("rt:p", [{ n: "point", t: () => __RΦ$e.a(141), v: null }])(Vector, "distance");
	__RΦ$e.m("rt:f", "M$S")(Vector, "distance");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(15))(Vector, "distance");
	__RΦ$e.m("rt:f", "M$S")(Vector["create"]);
	((t, p) => __RΦ$e.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector, "create");
	__RΦ$e.m("rt:p", [{ n: "angle", t: () => __RΦ$e.a(15), v: null }, { n: "length", t: () => __RΦ$e.a(15), v: null }])(Vector, "create");
	__RΦ$e.m("rt:f", "M$S")(Vector, "create");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(1627))(Vector, "create");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(15))(Vector.prototype, "angle");
	__RΦ$e.m("rt:f", "P$")(Vector.prototype, "angle");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(15))(Vector.prototype, "length");
	__RΦ$e.m("rt:f", "P$")(Vector.prototype, "length");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(21))(Vector.prototype, "isNull");
	__RΦ$e.m("rt:f", "P$")(Vector.prototype, "isNull");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(1627))(Vector.prototype, "identity");
	__RΦ$e.m("rt:f", "P$")(Vector.prototype, "identity");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(1627))(Vector.prototype, "inverse");
	__RΦ$e.m("rt:f", "P$")(Vector.prototype, "inverse");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(1627))(Vector.prototype, "normal");
	__RΦ$e.m("rt:f", "P$")(Vector.prototype, "normal");
	__RΦ$e.m("rt:f", "M$")(Vector.prototype["translate"]);
	((t, p) => __RΦ$e.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector.prototype, "translate");
	__RΦ$e.m("rt:p", [{ n: "vector", t: () => __RΦ$e.a(1627), v: null }])(Vector.prototype, "translate");
	__RΦ$e.m("rt:f", "M$")(Vector.prototype, "translate");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(1627))(Vector.prototype, "translate");
	__RΦ$e.m("rt:f", "M$.")(Vector.prototype["rotate"]);
	((t, p) => __RΦ$e.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector.prototype, "rotate");
	__RΦ$e.m("rt:p", [{ n: "angle", t: () => __RΦ$e.a(15), v: null }])(Vector.prototype, "rotate");
	__RΦ$e.m("rt:f", "M$.")(Vector.prototype, "rotate");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(1627))(Vector.prototype, "rotate");
	__RΦ$e.m("rt:f", "M$.")(Vector.prototype["scale"]);
	((t, p) => __RΦ$e.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector.prototype, "scale");
	__RΦ$e.m("rt:p", [{ n: "scale", t: () => __RΦ$e.a(15), v: null }])(Vector.prototype, "scale");
	__RΦ$e.m("rt:f", "M$.")(Vector.prototype, "scale");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(1627))(Vector.prototype, "scale");
	__RΦ$e.m("rt:f", "M$")(Vector.prototype["multiply"]);
	((t, p) => __RΦ$e.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector.prototype, "multiply");
	__RΦ$e.m("rt:p", [{ n: "vector", t: () => __RΦ$e.a(1627), v: null }])(Vector.prototype, "multiply");
	__RΦ$e.m("rt:f", "M$")(Vector.prototype, "multiply");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(1627))(Vector.prototype, "multiply");
	__RΦ$e.m("rt:f", "M$")(Vector.prototype["mod"]);
	((t, p) => __RΦ$e.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector.prototype, "mod");
	__RΦ$e.m("rt:p", [{ n: "vector", t: () => __RΦ$e.a(1627), v: null }])(Vector.prototype, "mod");
	__RΦ$e.m("rt:f", "M$")(Vector.prototype, "mod");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(1627))(Vector.prototype, "mod");
	__RΦ$e.m("rt:f", "M$.")(Vector.prototype["clone"]);
	((t, p) => __RΦ$e.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector.prototype, "clone");
	__RΦ$e.m("rt:p", [])(Vector.prototype, "clone");
	__RΦ$e.m("rt:f", "M$.")(Vector.prototype, "clone");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(1627))(Vector.prototype, "clone");
	__RΦ$e.m("rt:f", "M$.")(Vector.prototype["toArray"]);
	((t, p) => __RΦ$e.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector.prototype, "toArray");
	__RΦ$e.m("rt:p", [])(Vector.prototype, "toArray");
	__RΦ$e.m("rt:f", "M$.")(Vector.prototype, "toArray");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(1636))(Vector.prototype, "toArray");
	__RΦ$e.m("rt:f", "M$.")(Vector.prototype["toString"]);
	((t, p) => __RΦ$e.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Vector.prototype, "toString");
	__RΦ$e.m("rt:p", [{ n: "digits", t: () => __RΦ$e.a(15), v: function () { return 2; } }])(Vector.prototype, "toString");
	__RΦ$e.m("rt:f", "M$.")(Vector.prototype, "toString");
	__RΦ$e.m("rt:t", () => __RΦ$e.a(14))(Vector.prototype, "toString");

	const __RΦ$d = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$d.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$d.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$d.t[id] = t = l;
	        }
	        return t;
	    }, t: { [15]: { LΦ: t => Number } } };
	class Angle {
	    /**
	     * Конвертация угла из радиан в градусы.
	     * @param value
	     */
	    static toDegree(value) {
	        return value / Math.PI * 180;
	    }
	    /**
	     * Конвертация угла из градусов в радианы.
	     * @param value
	     */
	    static toRadian(value) {
	        return value * Math.PI / 180;
	    }
	}
	(t => __RΦ$d.t[1638] = t)(Angle);
	__RΦ$d.m("rt:SP", [])(Angle);
	__RΦ$d.m("rt:P", [])(Angle);
	__RΦ$d.m("rt:Sm", ["toDegree", "toRadian"])(Angle);
	__RΦ$d.m("rt:m", [])(Angle);
	__RΦ$d.m("rt:f", "Ce")(Angle);
	__RΦ$d.m("rt:f", "M$S.")(Angle["toDegree"]);
	((t, p) => __RΦ$d.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle, "toDegree");
	__RΦ$d.m("rt:p", [{ n: "value", t: () => __RΦ$d.a(15), v: null }])(Angle, "toDegree");
	__RΦ$d.m("rt:f", "M$S.")(Angle, "toDegree");
	__RΦ$d.m("rt:t", () => __RΦ$d.a(15))(Angle, "toDegree");
	__RΦ$d.m("rt:f", "M$S.")(Angle["toRadian"]);
	((t, p) => __RΦ$d.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Angle, "toRadian");
	__RΦ$d.m("rt:p", [{ n: "value", t: () => __RΦ$d.a(15), v: null }])(Angle, "toRadian");
	__RΦ$d.m("rt:f", "M$S.")(Angle, "toRadian");
	__RΦ$d.m("rt:t", () => __RΦ$d.a(15))(Angle, "toRadian");

	const __RΦ$c = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$c.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$c.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$c.t[id] = t = l;
	        }
	        return t;
	    }, t: { [151]: { LΦ: t => Object }, [152]: { LΦ: t => Object } } };
	var IΦdefault$4 = { name: "IKeyValueObject", prototype: {}, identity: Symbol("IKeyValueObject (interface)") };
	(t => __RΦ$c.t[153] = t)(IΦdefault$4);
	__RΦ$c.m("rt:P", ["key", "value"])(IΦdefault$4);
	__RΦ$c.m("rt:m", [])(IΦdefault$4);
	__RΦ$c.m("rt:f", "Ie")(IΦdefault$4);
	__RΦ$c.m("rt:t", () => __RΦ$c.a(151))(IΦdefault$4.prototype, "key");
	__RΦ$c.m("rt:f", "P")(IΦdefault$4.prototype, "key");
	__RΦ$c.m("rt:t", () => __RΦ$c.a(152))(IΦdefault$4.prototype, "value");
	__RΦ$c.m("rt:f", "P")(IΦdefault$4.prototype, "value");
	__RΦ$c.m("rt:t", () => __RΦ$c.a(151))(IΦdefault$4.prototype, "key");
	__RΦ$c.m("rt:f", "P")(IΦdefault$4.prototype, "key");
	__RΦ$c.m("rt:t", () => __RΦ$c.a(152))(IΦdefault$4.prototype, "value");
	__RΦ$c.m("rt:f", "P")(IΦdefault$4.prototype, "value");

	const __RΦ$b = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$b.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$b.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$b.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1828]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b.a(156), p: [__RΦ$b.a(1826), __RΦ$b.a(1827)] }) }, [156]: { LΦ: t => Map }, [1826]: { LΦ: t => Object }, [1827]: { LΦ: t => Object }, [1832]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b.a(1836) }) }, [1836]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b.a(153), p: [__RΦ$b.a(1826), __RΦ$b.a(1835)] }) }, [153]: { LΦ: t => IΦdefault$4 }, [1835]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b.a(10), __RΦ$b.a(1827)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [1839]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b.a(1840), p: [__RΦ$b.a(1837), __RΦ$b.a(1838)] }) }, [1840]: { LΦ: t => Object }, [1837]: { LΦ: t => Object }, [1838]: { LΦ: t => Object }, [1844]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b.a(1846) }) }, [1846]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b.a(153), p: [__RΦ$b.a(1837), __RΦ$b.a(1838)] }) }, [1663]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$b.a(1656), __RΦ$b.a(1661)] }) }, [1656]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b.a(156), p: [__RΦ$b.a(1645), __RΦ$b.a(1646)] }) }, [1645]: { LΦ: t => Object }, [1646]: { LΦ: t => Object }, [1661]: { RΦ: t => ({ TΦ: "m", t: __RΦ$b.a(1662), p: [__RΦ$b.a(1645), __RΦ$b.a(1646)] }) }, [1662]: { LΦ: t => Object }, [1647]: { RΦ: t => ({ TΦ: "[", e: __RΦ$b.a(1650) }) }, [1650]: { RΦ: t => ({ TΦ: "g", t: __RΦ$b.a(153), p: [__RΦ$b.a(1645), __RΦ$b.a(1646)] }) }, [15]: { LΦ: t => Number } } };
	/**
	 * Конвертация разнообразных значений.
	 */
	class Convert {
	    static toArray(object) {
	        const result = [];
	        if (object instanceof Map) {
	            for (const [key, value] of object) {
	                result.push({ key, value });
	            }
	        }
	        else {
	            for (const key in object) {
	                if (!object.hasOwnProperty(key))
	                    continue;
	                result.push({ key, value: Reflect.get(object, key) });
	            }
	        }
	        return result;
	    }
	    /**
	     * Конвертировать миллисекунды в секунды.
	     * @param millisecond
	     */
	    static toSecond(millisecond) {
	        return millisecond / 1000;
	    }
	}
	(t => __RΦ$b.t[1824] = t)(Convert);
	__RΦ$b.m("rt:SP", [])(Convert);
	__RΦ$b.m("rt:P", [])(Convert);
	__RΦ$b.m("rt:Sm", ["toArray", "toArray", "toArray", "toSecond"])(Convert);
	__RΦ$b.m("rt:m", [])(Convert);
	__RΦ$b.m("rt:f", "Ce")(Convert);
	__RΦ$b.m("rt:f", "M$S")(Convert["toArray"]);
	((t, p) => __RΦ$b.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert, "toArray");
	__RΦ$b.m("rt:p", [{ n: "object", t: () => __RΦ$b.a(1828), v: null }])(Convert, "toArray");
	__RΦ$b.m("rt:f", "M$S")(Convert, "toArray");
	__RΦ$b.m("rt:t", () => __RΦ$b.a(1832))(Convert, "toArray");
	__RΦ$b.m("rt:f", "M$S")(Convert["toArray"]);
	((t, p) => __RΦ$b.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert, "toArray");
	__RΦ$b.m("rt:p", [{ n: "object", t: () => __RΦ$b.a(1839), v: null }])(Convert, "toArray");
	__RΦ$b.m("rt:f", "M$S")(Convert, "toArray");
	__RΦ$b.m("rt:t", () => __RΦ$b.a(1844))(Convert, "toArray");
	__RΦ$b.m("rt:f", "M$S")(Convert["toArray"]);
	((t, p) => __RΦ$b.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert, "toArray");
	__RΦ$b.m("rt:p", [{ n: "object", t: () => __RΦ$b.a(1663), v: null }])(Convert, "toArray");
	__RΦ$b.m("rt:f", "M$S")(Convert, "toArray");
	__RΦ$b.m("rt:t", () => __RΦ$b.a(1647))(Convert, "toArray");
	__RΦ$b.m("rt:f", "M$S.")(Convert["toSecond"]);
	((t, p) => __RΦ$b.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Convert, "toSecond");
	__RΦ$b.m("rt:p", [{ n: "millisecond", t: () => __RΦ$b.a(15), v: null }])(Convert, "toSecond");
	__RΦ$b.m("rt:f", "M$S.")(Convert, "toSecond");
	__RΦ$b.m("rt:t", () => __RΦ$b.a(15))(Convert, "toSecond");

	const __RΦ$a = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$a.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$a.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$a.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1873]: { LΦ: t => 60 }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [15]: { LΦ: t => Number }, [1869]: { LΦ: t => "update" }, [1875]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a.a(4) }] }) }, [1850]: { RΦ: t => ({ TΦ: "t" }) }, [1871]: { LΦ: t => "render" }, [1876]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a.a(4) }] }) }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$a.a(14), __RΦ$a.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1852]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$a.a(4) }] }) }, [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	/**
	 * http://gs-studio.com/news-about-it/30703----javascript
	 * https://eatdog.com.ua/assets/gamedev-slides/
	 * https://www.youtube.com/watch?v=-gsjAz9jR3Y
	 */
	class GameLoop {
	    framePerSecond;
	    eventEmitter = new EventEmitter__default["default"];
	    time = 0;
	    timeInterval = 0;
	    renderTime = 0;
	    renderTimeInterval = 0;
	    /**
	     * Текущий FPS отрисовки игровой сцены.
	     */
	    get renderFramePerSecond() {
	        return 1 / (this.renderTimeInterval / 1000);
	    }
	    /**
	     * Временной шаг, с которым вызывается функция update для вычисления игровой логики.
	     * Измеряется в миллисекундах.
	     */
	    get step() {
	        return (1 / this.framePerSecond) / 1000;
	    }
	    constructor(
	    /**
	     * Частота обновления игровой логики (генерации события update).
	     * @private
	     */
	    framePerSecond = 60 // TODO Переименовать в updatePerSecond?
	    ) {
	        this.framePerSecond = framePerSecond;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	    start() {
	        this.time = performance.now();
	        this.timeInterval = 0;
	        requestAnimationFrame(this.frame.bind(this));
	    }
	    stop() {
	    }
	    pause() {
	    }
	    frame() {
	        // Обработка логики игры.
	        {
	            const currentTime = performance.now();
	            // Исправление проблемы неактивных вкладок.
	            // Разрешить максимальную задержку между вызовами не более, чем 1 секунда.
	            this.timeInterval = this.timeInterval + Math.min(1000, currentTime - this.time);
	            while (this.timeInterval > this.step) {
	                this.timeInterval = this.timeInterval - this.step;
	                this.eventEmitter.emit('update', this.step);
	            }
	            this.time = currentTime;
	        }
	        // Обработка отрисовки сцены игры.
	        {
	            const renderCurrentTime = performance.now();
	            this.renderTimeInterval = renderCurrentTime - this.renderTime;
	            this.renderTime = renderCurrentTime;
	            this.eventEmitter.emit('render', this.timeInterval);
	        }
	        requestAnimationFrame(this.frame.bind(this));
	    }
	}
	(t => __RΦ$a.t[1849] = t)(GameLoop);
	__RΦ$a.m("rt:SP", [])(GameLoop);
	__RΦ$a.m("rt:P", ["eventEmitter", "time", "timeInterval", "renderTime", "renderTimeInterval", "renderFramePerSecond", "step", "framePerSecond"])(GameLoop);
	__RΦ$a.m("rt:Sm", [])(GameLoop);
	__RΦ$a.m("rt:m", ["on", "on", "on", "start", "stop", "pause", "frame"])(GameLoop);
	__RΦ$a.m("rt:p", [{ n: "framePerSecond", t: () => __RΦ$a.a(1873), v: function () { return 60 // TODO Переименовать в updatePerSecond?
	        ; }, f: "#R" }])(GameLoop);
	__RΦ$a.m("rt:i", [() => undefined, () => undefined])(GameLoop);
	__RΦ$a.m("rt:f", "Ce")(GameLoop);
	__RΦ$a.m("rt:t", () => __RΦ$a.a(4))(GameLoop.prototype, "eventEmitter");
	__RΦ$a.m("rt:f", "P#R")(GameLoop.prototype, "eventEmitter");
	__RΦ$a.m("rt:t", () => __RΦ$a.a(15))(GameLoop.prototype, "time");
	__RΦ$a.m("rt:f", "P#")(GameLoop.prototype, "time");
	__RΦ$a.m("rt:t", () => __RΦ$a.a(15))(GameLoop.prototype, "timeInterval");
	__RΦ$a.m("rt:f", "P#")(GameLoop.prototype, "timeInterval");
	__RΦ$a.m("rt:t", () => __RΦ$a.a(15))(GameLoop.prototype, "renderTime");
	__RΦ$a.m("rt:f", "P#")(GameLoop.prototype, "renderTime");
	__RΦ$a.m("rt:t", () => __RΦ$a.a(15))(GameLoop.prototype, "renderTimeInterval");
	__RΦ$a.m("rt:f", "P#")(GameLoop.prototype, "renderTimeInterval");
	__RΦ$a.m("rt:t", () => __RΦ$a.a(15))(GameLoop.prototype, "renderFramePerSecond");
	__RΦ$a.m("rt:f", "P$")(GameLoop.prototype, "renderFramePerSecond");
	__RΦ$a.m("rt:t", () => __RΦ$a.a(15))(GameLoop.prototype, "step");
	__RΦ$a.m("rt:f", "P$")(GameLoop.prototype, "step");
	__RΦ$a.m("rt:f", "M")(GameLoop.prototype["on"]);
	((t, p) => __RΦ$a.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop.prototype, "on");
	__RΦ$a.m("rt:p", [{ n: "eventName", t: () => __RΦ$a.a(1869), v: null }, { n: "update", t: () => __RΦ$a.a(1875), v: null }])(GameLoop.prototype, "on");
	__RΦ$a.m("rt:f", "M")(GameLoop.prototype, "on");
	__RΦ$a.m("rt:t", () => __RΦ$a.a(1850))(GameLoop.prototype, "on");
	__RΦ$a.m("rt:f", "M")(GameLoop.prototype["on"]);
	((t, p) => __RΦ$a.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop.prototype, "on");
	__RΦ$a.m("rt:p", [{ n: "eventName", t: () => __RΦ$a.a(1871), v: null }, { n: "render", t: () => __RΦ$a.a(1876), v: null }])(GameLoop.prototype, "on");
	__RΦ$a.m("rt:f", "M")(GameLoop.prototype, "on");
	__RΦ$a.m("rt:t", () => __RΦ$a.a(1850))(GameLoop.prototype, "on");
	__RΦ$a.m("rt:f", "M")(GameLoop.prototype["on"]);
	((t, p) => __RΦ$a.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop.prototype, "on");
	__RΦ$a.m("rt:p", [{ n: "eventName", t: () => __RΦ$a.a(143), v: null }, { n: "listener", t: () => __RΦ$a.a(1852), v: null }])(GameLoop.prototype, "on");
	__RΦ$a.m("rt:f", "M")(GameLoop.prototype, "on");
	__RΦ$a.m("rt:t", () => __RΦ$a.a(1850))(GameLoop.prototype, "on");
	__RΦ$a.m("rt:f", "M$")(GameLoop.prototype["start"]);
	((t, p) => __RΦ$a.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop.prototype, "start");
	__RΦ$a.m("rt:p", [])(GameLoop.prototype, "start");
	__RΦ$a.m("rt:f", "M$")(GameLoop.prototype, "start");
	__RΦ$a.m("rt:t", () => __RΦ$a.a(23))(GameLoop.prototype, "start");
	__RΦ$a.m("rt:f", "M$")(GameLoop.prototype["stop"]);
	((t, p) => __RΦ$a.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop.prototype, "stop");
	__RΦ$a.m("rt:p", [])(GameLoop.prototype, "stop");
	__RΦ$a.m("rt:f", "M$")(GameLoop.prototype, "stop");
	__RΦ$a.m("rt:t", () => __RΦ$a.a(23))(GameLoop.prototype, "stop");
	__RΦ$a.m("rt:f", "M$")(GameLoop.prototype["pause"]);
	((t, p) => __RΦ$a.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop.prototype, "pause");
	__RΦ$a.m("rt:p", [])(GameLoop.prototype, "pause");
	__RΦ$a.m("rt:f", "M$")(GameLoop.prototype, "pause");
	__RΦ$a.m("rt:t", () => __RΦ$a.a(23))(GameLoop.prototype, "pause");
	__RΦ$a.m("rt:f", "M#.")(GameLoop.prototype["frame"]);
	((t, p) => __RΦ$a.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(GameLoop.prototype, "frame");
	__RΦ$a.m("rt:p", [])(GameLoop.prototype, "frame");
	__RΦ$a.m("rt:f", "M#.")(GameLoop.prototype, "frame");
	__RΦ$a.m("rt:t", () => __RΦ$a.a(23))(GameLoop.prototype, "frame");

	const __RΦ$9$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$9$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$9$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$9$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1880]: { RΦ: t => ({ TΦ: "g", t: __RΦ$9$1.a(156), p: [__RΦ$9$1.a(14), __RΦ$9$1.a(21)] }) }, [156]: { LΦ: t => Map }, [14]: { LΦ: t => String }, [21]: { LΦ: t => Boolean }, [1883]: { LΦ: t => KeyboardEvent }, [1890]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1893]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$1.a(4) }] }) }, [1897]: { LΦ: t => Function }, [1896]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$9$1.a(4) }] }) }, [1898]: { LΦ: t => Function } } };
	/**
	 * Вместо KeyUpDownProcessor используйте Shortcut.
	 * @deprecated
	 * @link http://khusamov.github.io/tutorial/csharp/key-down-up-process
	 */
	class KeyUpDownProcessor {
	    /**
	     * Данный словарь хранит информацию о том, была ли нажата клавиша.
	     * В качестве ключа выступает номер клавиши,
	     * а значение это флаг (была или не была нажата клавиша).
	     * @private
	     * @link https://learn.javascript.ru/keyboard-events
	     */
	    static #theKeyWasDown = new Map;
	    static onKeyDown(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.#theKeyWasDown.has(keyCode)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.#theKeyWasDown.set(keyCode, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.#theKeyWasDown.get(keyCode)) {
	            // Помечаем что она нажата.
	            this.#theKeyWasDown.set(keyCode, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            action();
	        }
	    }
	    static onKeyUp(event, action) {
	        // Из события извлекаем номер нажатой клавиши.
	        const keyCode = event.code;
	        // Помечаем что она уже не нажата.
	        this.#theKeyWasDown.set(keyCode, false);
	        // Выполняем действие при отжатии клавиши.
	        action();
	    }
	}
	(t => __RΦ$9$1.t[1878] = t)(KeyUpDownProcessor);
	__RΦ$9$1.m("rt:SP", ["#theKeyWasDown"])(KeyUpDownProcessor);
	__RΦ$9$1.m("rt:P", [])(KeyUpDownProcessor);
	__RΦ$9$1.m("rt:Sm", ["onKeyDown", "onKeyUp"])(KeyUpDownProcessor);
	__RΦ$9$1.m("rt:m", [])(KeyUpDownProcessor);
	__RΦ$9$1.m("rt:f", "Ce")(KeyUpDownProcessor);
	__RΦ$9$1.m("rt:t", () => __RΦ$9$1.a(1880))(KeyUpDownProcessor, "#theKeyWasDown");
	__RΦ$9$1.m("rt:f", "P")(KeyUpDownProcessor, "#theKeyWasDown");
	__RΦ$9$1.m("rt:f", "M$S.")(KeyUpDownProcessor["onKeyDown"]);
	((t, p) => __RΦ$9$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor, "onKeyDown");
	__RΦ$9$1.m("rt:p", [{ n: "event", t: () => __RΦ$9$1.a(1883), v: null }, { n: "action", t: () => __RΦ$9$1.a(1890), v: null }])(KeyUpDownProcessor, "onKeyDown");
	__RΦ$9$1.m("rt:f", "M$S.")(KeyUpDownProcessor, "onKeyDown");
	__RΦ$9$1.m("rt:t", () => __RΦ$9$1.a(23))(KeyUpDownProcessor, "onKeyDown");
	__RΦ$9$1.m("rt:f", "M$S.")(KeyUpDownProcessor["onKeyUp"]);
	((t, p) => __RΦ$9$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(KeyUpDownProcessor, "onKeyUp");
	__RΦ$9$1.m("rt:p", [{ n: "event", t: () => __RΦ$9$1.a(1883), v: null }, { n: "action", t: () => __RΦ$9$1.a(1890), v: null }])(KeyUpDownProcessor, "onKeyUp");
	__RΦ$9$1.m("rt:f", "M$S.")(KeyUpDownProcessor, "onKeyUp");
	__RΦ$9$1.m("rt:t", () => __RΦ$9$1.a(23))(KeyUpDownProcessor, "onKeyUp");
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyDown(listener) {
	    return __RΦ$9$1.f((event) => {
	        KeyUpDownProcessor.onKeyDown(event, __RΦ$9$1.f(() => {
	            listener(event);
	        }, [__RΦ$9$1.m("rt:p", []), __RΦ$9$1.m("rt:f", "F>"), __RΦ$9$1.m("rt:t", () => __RΦ$9$1.a(23))], ""));
	    }, [__RΦ$9$1.m("rt:p", [{ n: "event", t: () => __RΦ$9$1.a(1883), v: null }]), __RΦ$9$1.m("rt:f", "F>"), __RΦ$9$1.m("rt:t", () => __RΦ$9$1.a(23))], "");
	}
	__RΦ$9$1.m("rt:p", [{ n: "listener", t: () => __RΦ$9$1.a(1893), v: null }])(onKeyDown);
	__RΦ$9$1.m("rt:f", "F")(onKeyDown);
	__RΦ$9$1.m("rt:t", () => __RΦ$9$1.a(1897))(onKeyDown);
	/**
	 * @deprecated
	 * @param listener
	 */
	function onKeyUp(listener) {
	    return __RΦ$9$1.f((event) => {
	        KeyUpDownProcessor.onKeyUp(event, __RΦ$9$1.f(() => {
	            listener(event);
	        }, [__RΦ$9$1.m("rt:p", []), __RΦ$9$1.m("rt:f", "F>"), __RΦ$9$1.m("rt:t", () => __RΦ$9$1.a(23))], ""));
	    }, [__RΦ$9$1.m("rt:p", [{ n: "event", t: () => __RΦ$9$1.a(1883), v: null }]), __RΦ$9$1.m("rt:f", "F>"), __RΦ$9$1.m("rt:t", () => __RΦ$9$1.a(23))], "");
	}
	__RΦ$9$1.m("rt:p", [{ n: "listener", t: () => __RΦ$9$1.a(1896), v: null }])(onKeyUp);
	__RΦ$9$1.m("rt:f", "F")(onKeyUp);
	__RΦ$9$1.m("rt:t", () => __RΦ$9$1.a(1898))(onKeyUp);

	const __RΦ$8$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$8$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$8$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$8$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [23]: { RΦ: t => ({ TΦ: "V" }) } } };
	var IΦdefault$3 = { name: "IDisposable", prototype: {}, identity: Symbol("IDisposable (interface)") };
	(t => __RΦ$8$1.t[147] = t)(IΦdefault$3);
	__RΦ$8$1.m("rt:P", [])(IΦdefault$3);
	__RΦ$8$1.m("rt:m", ["dispose"])(IΦdefault$3);
	__RΦ$8$1.m("rt:f", "Ie")(IΦdefault$3);
	__RΦ$8$1.m("rt:p", [])(IΦdefault$3.prototype, "dispose");
	__RΦ$8$1.m("rt:f", "M")(IΦdefault$3.prototype, "dispose");
	__RΦ$8$1.m("rt:t", () => __RΦ$8$1.a(23))(IΦdefault$3.prototype, "dispose");
	__RΦ$8$1.m("rt:p", [])(IΦdefault$3.prototype, "dispose");
	__RΦ$8$1.m("rt:f", "M")(IΦdefault$3.prototype, "dispose");
	__RΦ$8$1.m("rt:t", () => __RΦ$8$1.a(23))(IΦdefault$3.prototype, "dispose");

	const __RΦ$7$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$7$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$7$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$7$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1899]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$7$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) } } };
	var IΦdefault$2 = { name: "IKeyboardListeners", prototype: {}, identity: Symbol("IKeyboardListeners (interface)") };
	(t => __RΦ$7$1.t[1900] = t)(IΦdefault$2);
	__RΦ$7$1.m("rt:P", ["down", "up"])(IΦdefault$2);
	__RΦ$7$1.m("rt:m", [])(IΦdefault$2);
	__RΦ$7$1.m("rt:f", "Ie")(IΦdefault$2);
	__RΦ$7$1.m("rt:t", () => __RΦ$7$1.a(1899))(IΦdefault$2.prototype, "down");
	__RΦ$7$1.m("rt:f", "P")(IΦdefault$2.prototype, "down");
	__RΦ$7$1.m("rt:t", () => __RΦ$7$1.a(1899))(IΦdefault$2.prototype, "up");
	__RΦ$7$1.m("rt:f", "P")(IΦdefault$2.prototype, "up");
	__RΦ$7$1.m("rt:t", () => __RΦ$7$1.a(1899))(IΦdefault$2.prototype, "down");
	__RΦ$7$1.m("rt:f", "P")(IΦdefault$2.prototype, "down");
	__RΦ$7$1.m("rt:t", () => __RΦ$7$1.a(1899))(IΦdefault$2.prototype, "up");
	__RΦ$7$1.m("rt:f", "P")(IΦdefault$2.prototype, "up");

	const __RΦ$6$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$6$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$6$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$6$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [709]: { LΦ: t => Object }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1901]: { TΦ: "5", name: "default" }, [2154]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$1.a(156), p: [__RΦ$6$1.a(14), __RΦ$6$1.a(1900)] }) }, [156]: { LΦ: t => Map }, [1900]: { LΦ: t => IΦdefault$2 }, [1899]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$6$1.a(4) }] }) }, [1880]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6$1.a(156), p: [__RΦ$6$1.a(14), __RΦ$6$1.a(21)] }) }, [21]: { LΦ: t => Boolean }, [147]: { LΦ: t => IΦdefault$3 }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [1883]: { LΦ: t => KeyboardEvent } } };
	const codeOf = __RΦ$6$1.f((key) => 'Key' + key.toUpperCase(), [__RΦ$6$1.m("rt:p", [{ n: "key", t: () => __RΦ$6$1.a(14), v: null }]), __RΦ$6$1.m("rt:f", "F>"), __RΦ$6$1.m("rt:t", () => __RΦ$6$1.a(14))], "codeOf");
	class ShortcutDispatcher {
	    static instanceHolder = new Lazy(() => new ShortcutDispatcher);
	    static get instance() {
	        return this.instanceHolder.value;
	    }
	    host;
	    listeners = new Map;
	    keyDownListenerBinded;
	    keyUpListenerBinded;
	    theKeyWasDown = new Map;
	    constructor(host = document) {
	        this.host = host;
	        this.keyDownListenerBinded = this.keyDownListener.bind(this);
	        this.keyUpListenerBinded = this.keyUpListener.bind(this);
	        this.host.addEventListener('keydown', this.keyDownListenerBinded);
	        this.host.addEventListener('keyup', this.keyUpListenerBinded);
	    }
	    register(key, listeners) {
	        this.listeners.set(key, listeners);
	        return {
	            dispose: __RΦ$6$1.f(() => {
	                this.listeners.delete(key);
	                this.theKeyWasDown.delete(codeOf(key));
	            }, [__RΦ$6$1.m("rt:p", []), __RΦ$6$1.m("rt:f", "F>"), __RΦ$6$1.m("rt:t", () => __RΦ$6$1.a(23))], "dispose")
	        };
	    }
	    keyDownListener(event) {
	        const code = event.code;
	        // Если такой клавиши нет в словаре,
	        if (!this.theKeyWasDown.has(code)) {
	            // то добавляем ее с информацией, что ранее она еще не была нажата.
	            this.theKeyWasDown.set(code, false);
	        }
	        // Если клавиша ранее не была нажата, то:
	        if (!this.theKeyWasDown.get(code)) {
	            // Помечаем что она нажата.
	            this.theKeyWasDown.set(code, true);
	            // И выполняем действие при нажатии на эту клавишу.
	            for (const [key, listeners] of this.listeners.entries()) {
	                if (code === codeOf(key)) {
	                    listeners.down(event);
	                }
	            }
	        }
	    }
	    keyUpListener(event) {
	        // Из события извлекаем номер нажатой клавиши.
	        const code = event.code;
	        // Помечаем что она уже не нажата.
	        this.theKeyWasDown.set(code, false);
	        // Выполняем действие при отжатии клавиши.
	        for (const [key, listeners] of this.listeners.entries()) {
	            if (code === codeOf(key)) {
	                listeners.up(event);
	            }
	        }
	    }
	    dispose() {
	        this.host.removeEventListener('keydown', this.keyDownListenerBinded);
	        this.host.removeEventListener('keyup', this.keyUpListenerBinded);
	    }
	}
	(t => __RΦ$6$1.t[1901] = t)(ShortcutDispatcher);
	__RΦ$6$1.m("rt:SP", ["instanceHolder", "instance"])(ShortcutDispatcher);
	__RΦ$6$1.m("rt:P", ["host", "listeners", "keyDownListenerBinded", "keyUpListenerBinded", "theKeyWasDown"])(ShortcutDispatcher);
	__RΦ$6$1.m("rt:Sm", [])(ShortcutDispatcher);
	__RΦ$6$1.m("rt:m", ["register", "keyDownListener", "keyUpListener", "dispose"])(ShortcutDispatcher);
	__RΦ$6$1.m("rt:p", [{ n: "host", t: () => __RΦ$6$1.a(709), v: function () { return document; } }])(ShortcutDispatcher);
	__RΦ$6$1.m("rt:i", [() => undefined])(ShortcutDispatcher);
	__RΦ$6$1.m("rt:f", "Ce")(ShortcutDispatcher);
	__RΦ$6$1.m("rt:t", () => __RΦ$6$1.a(4))(ShortcutDispatcher, "instanceHolder");
	__RΦ$6$1.m("rt:f", "P#R")(ShortcutDispatcher, "instanceHolder");
	__RΦ$6$1.m("rt:t", () => __RΦ$6$1.a(1901))(ShortcutDispatcher, "instance");
	__RΦ$6$1.m("rt:f", "P$")(ShortcutDispatcher, "instance");
	__RΦ$6$1.m("rt:t", () => __RΦ$6$1.a(709))(ShortcutDispatcher.prototype, "host");
	__RΦ$6$1.m("rt:f", "P#R")(ShortcutDispatcher.prototype, "host");
	__RΦ$6$1.m("rt:t", () => __RΦ$6$1.a(2154))(ShortcutDispatcher.prototype, "listeners");
	__RΦ$6$1.m("rt:f", "P#R")(ShortcutDispatcher.prototype, "listeners");
	__RΦ$6$1.m("rt:t", () => __RΦ$6$1.a(1899))(ShortcutDispatcher.prototype, "keyDownListenerBinded");
	__RΦ$6$1.m("rt:f", "P#R")(ShortcutDispatcher.prototype, "keyDownListenerBinded");
	__RΦ$6$1.m("rt:t", () => __RΦ$6$1.a(1899))(ShortcutDispatcher.prototype, "keyUpListenerBinded");
	__RΦ$6$1.m("rt:f", "P#R")(ShortcutDispatcher.prototype, "keyUpListenerBinded");
	__RΦ$6$1.m("rt:t", () => __RΦ$6$1.a(1880))(ShortcutDispatcher.prototype, "theKeyWasDown");
	__RΦ$6$1.m("rt:f", "P#R")(ShortcutDispatcher.prototype, "theKeyWasDown");
	__RΦ$6$1.m("rt:f", "M$")(ShortcutDispatcher.prototype["register"]);
	((t, p) => __RΦ$6$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher.prototype, "register");
	__RΦ$6$1.m("rt:p", [{ n: "key", t: () => __RΦ$6$1.a(14), v: null }, { n: "listeners", t: () => __RΦ$6$1.a(1900), v: null }])(ShortcutDispatcher.prototype, "register");
	__RΦ$6$1.m("rt:f", "M$")(ShortcutDispatcher.prototype, "register");
	__RΦ$6$1.m("rt:t", () => __RΦ$6$1.a(147))(ShortcutDispatcher.prototype, "register");
	__RΦ$6$1.m("rt:f", "M#.")(ShortcutDispatcher.prototype["keyDownListener"]);
	((t, p) => __RΦ$6$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher.prototype, "keyDownListener");
	__RΦ$6$1.m("rt:p", [{ n: "event", t: () => __RΦ$6$1.a(1883), v: null }])(ShortcutDispatcher.prototype, "keyDownListener");
	__RΦ$6$1.m("rt:f", "M#.")(ShortcutDispatcher.prototype, "keyDownListener");
	__RΦ$6$1.m("rt:t", () => __RΦ$6$1.a(23))(ShortcutDispatcher.prototype, "keyDownListener");
	__RΦ$6$1.m("rt:f", "M#.")(ShortcutDispatcher.prototype["keyUpListener"]);
	((t, p) => __RΦ$6$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher.prototype, "keyUpListener");
	__RΦ$6$1.m("rt:p", [{ n: "event", t: () => __RΦ$6$1.a(1883), v: null }])(ShortcutDispatcher.prototype, "keyUpListener");
	__RΦ$6$1.m("rt:f", "M#.")(ShortcutDispatcher.prototype, "keyUpListener");
	__RΦ$6$1.m("rt:t", () => __RΦ$6$1.a(23))(ShortcutDispatcher.prototype, "keyUpListener");
	__RΦ$6$1.m("rt:f", "M$.")(ShortcutDispatcher.prototype["dispose"]);
	((t, p) => __RΦ$6$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(ShortcutDispatcher.prototype, "dispose");
	__RΦ$6$1.m("rt:p", [])(ShortcutDispatcher.prototype, "dispose");
	__RΦ$6$1.m("rt:f", "M$.")(ShortcutDispatcher.prototype, "dispose");
	__RΦ$6$1.m("rt:t", () => __RΦ$6$1.a(23))(ShortcutDispatcher.prototype, "dispose");

	const __RΦ$5$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$5$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$5$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$5$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [1900]: { LΦ: t => IΦdefault$2 }, [147]: { LΦ: t => IΦdefault$3 } } };
	class Shortcut {
	    static register(key, listeners) {
	        return ShortcutDispatcher.instance.register(key, listeners);
	    }
	}
	(t => __RΦ$5$1.t[2183] = t)(Shortcut);
	__RΦ$5$1.m("rt:SP", [])(Shortcut);
	__RΦ$5$1.m("rt:P", [])(Shortcut);
	__RΦ$5$1.m("rt:Sm", ["register"])(Shortcut);
	__RΦ$5$1.m("rt:m", [])(Shortcut);
	__RΦ$5$1.m("rt:f", "Ce")(Shortcut);
	__RΦ$5$1.m("rt:f", "M$S")(Shortcut["register"]);
	((t, p) => __RΦ$5$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Shortcut, "register");
	__RΦ$5$1.m("rt:p", [{ n: "key", t: () => __RΦ$5$1.a(14), v: null }, { n: "listeners", t: () => __RΦ$5$1.a(1900), v: null }])(Shortcut, "register");
	__RΦ$5$1.m("rt:f", "M$S")(Shortcut, "register");
	__RΦ$5$1.m("rt:t", () => __RΦ$5$1.a(147))(Shortcut, "register");

	const __RΦ$4$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$4$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$4$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$4$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [166]: { RΦ: t => ({ TΦ: "[", e: __RΦ$4$1.a(165) }) }, [165]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [168]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$4$1.a(10), __RΦ$4$1.a(167)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [167]: { LΦ: t => Object }, [177]: { RΦ: t => ({ TΦ: "g", t: __RΦ$4$1.a(77), p: [__RΦ$4$1.a(167)] }) }, [77]: { LΦ: t => Object } } };
	var IΦdefault$1 = { name: "IQueue", prototype: {}, identity: Symbol("IQueue (interface)") };
	(t => __RΦ$4$1.t[178] = t)(IΦdefault$1);
	__RΦ$4$1.m("rt:P", ["items"])(IΦdefault$1);
	__RΦ$4$1.m("rt:m", ["enqueue", "dequeue"])(IΦdefault$1);
	__RΦ$4$1.m("rt:f", "Ie")(IΦdefault$1);
	__RΦ$4$1.m("rt:p", [{ n: "items", t: () => __RΦ$4$1.a(166), v: null }])(IΦdefault$1.prototype, "enqueue");
	__RΦ$4$1.m("rt:f", "M")(IΦdefault$1.prototype, "enqueue");
	__RΦ$4$1.m("rt:t", () => __RΦ$4$1.a(23))(IΦdefault$1.prototype, "enqueue");
	__RΦ$4$1.m("rt:p", [])(IΦdefault$1.prototype, "dequeue");
	__RΦ$4$1.m("rt:f", "M")(IΦdefault$1.prototype, "dequeue");
	__RΦ$4$1.m("rt:t", () => __RΦ$4$1.a(168))(IΦdefault$1.prototype, "dequeue");
	__RΦ$4$1.m("rt:t", () => __RΦ$4$1.a(177))(IΦdefault$1.prototype, "items");
	__RΦ$4$1.m("rt:f", "PR")(IΦdefault$1.prototype, "items");
	__RΦ$4$1.m("rt:p", [{ n: "items", t: () => __RΦ$4$1.a(166), v: null }])(IΦdefault$1.prototype, "enqueue");
	__RΦ$4$1.m("rt:f", "M")(IΦdefault$1.prototype, "enqueue");
	__RΦ$4$1.m("rt:t", () => __RΦ$4$1.a(23))(IΦdefault$1.prototype, "enqueue");
	__RΦ$4$1.m("rt:p", [])(IΦdefault$1.prototype, "dequeue");
	__RΦ$4$1.m("rt:f", "M")(IΦdefault$1.prototype, "dequeue");
	__RΦ$4$1.m("rt:t", () => __RΦ$4$1.a(168))(IΦdefault$1.prototype, "dequeue");
	__RΦ$4$1.m("rt:t", () => __RΦ$4$1.a(177))(IΦdefault$1.prototype, "items");
	__RΦ$4$1.m("rt:f", "PR")(IΦdefault$1.prototype, "items");

	const __RΦ$3$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$3$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$3$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$3$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [185]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$1.a(182) }) }, [182]: { LΦ: t => Object }, [190]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3$1.a(180) }) }, [180]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [227]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$3$1.a(10), __RΦ$3$1.a(182)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [228]: { RΦ: t => ({ TΦ: "g", t: __RΦ$3$1.a(77), p: [__RΦ$3$1.a(182)] }) }, [77]: { LΦ: t => Object } } };
	/**
	 * О́чередь — абстрактный тип данных с дисциплиной доступа к элементам «первый пришёл — первый вышел»
	 * (FIFO, англ. first in, first out).
	 *
	 * Добавление элемента (принято обозначать словом enqueue — поставить в очередь) возможно лишь
	 * в конец очереди, выборка — только из начала очереди (что принято называть словом dequeue — убрать из очереди),
	 * при этом выбранный элемент из очереди удаляется.
	 *
	 * @link https://bit.ly/3tPM13G
	 */
	class Queue {
	    storage = [];
	    enqueue(...items) {
	        this.storage.push(...items);
	    }
	    dequeue() {
	        return this.storage.shift();
	    }
	    get items() {
	        return this.storage;
	    }
	}
	(t => __RΦ$3$1.t[181] = t)(Queue);
	__RΦ$3$1.m("rt:SP", [])(Queue);
	__RΦ$3$1.m("rt:P", ["storage", "items"])(Queue);
	__RΦ$3$1.m("rt:Sm", [])(Queue);
	__RΦ$3$1.m("rt:m", ["enqueue", "dequeue"])(Queue);
	__RΦ$3$1.m("rt:i", [() => undefined])(Queue);
	__RΦ$3$1.m("rt:f", "Ce")(Queue);
	__RΦ$3$1.m("rt:t", () => __RΦ$3$1.a(185))(Queue.prototype, "storage");
	__RΦ$3$1.m("rt:f", "P#")(Queue.prototype, "storage");
	__RΦ$3$1.m("rt:f", "M$")(Queue.prototype["enqueue"]);
	((t, p) => __RΦ$3$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue.prototype, "enqueue");
	__RΦ$3$1.m("rt:p", [{ n: "items", t: () => __RΦ$3$1.a(190), v: null }])(Queue.prototype, "enqueue");
	__RΦ$3$1.m("rt:f", "M$")(Queue.prototype, "enqueue");
	__RΦ$3$1.m("rt:t", () => __RΦ$3$1.a(23))(Queue.prototype, "enqueue");
	__RΦ$3$1.m("rt:f", "M$")(Queue.prototype["dequeue"]);
	((t, p) => __RΦ$3$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(Queue.prototype, "dequeue");
	__RΦ$3$1.m("rt:p", [])(Queue.prototype, "dequeue");
	__RΦ$3$1.m("rt:f", "M$")(Queue.prototype, "dequeue");
	__RΦ$3$1.m("rt:t", () => __RΦ$3$1.a(227))(Queue.prototype, "dequeue");
	__RΦ$3$1.m("rt:t", () => __RΦ$3$1.a(228))(Queue.prototype, "items");
	__RΦ$3$1.m("rt:f", "P$")(Queue.prototype, "items");

	const __RΦ$2$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$2$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$2$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$2$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [407]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$1.a(404) }) }, [404]: { LΦ: t => Object }, [273]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1.a(178), p: [__RΦ$2$1.a(230)] }) }, [178]: { LΦ: t => IΦdefault$1 }, [230]: { LΦ: t => Object }, [406]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1.a(403), p: [__RΦ$2$1.a(230)] }) }, [403]: { TΦ: "5", name: "ILog" }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [622]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1.a(178), p: [__RΦ$2$1.a(621)] }) }, [621]: { LΦ: t => Object }, [628]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$2$1.a(622) }, { t: __RΦ$2$1.a(627) }] }) }, [627]: { RΦ: t => ({ TΦ: "g", t: __RΦ$2$1.a(229), p: [__RΦ$2$1.a(621)] }) }, [229]: { TΦ: "5", name: "default" }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$1.a(14), __RΦ$2$1.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [397]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [629]: { LΦ: t => Function }, [408]: { RΦ: t => ({ TΦ: "[", e: __RΦ$2$1.a(230) }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [402]: { RΦ: t => ({ TΦ: "O", m: [] }) }, [630]: { LΦ: t => Function }, [428]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2$1.a(10), __RΦ$2$1.a(230)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) } } };
	var IΦILog = { name: "ILog", prototype: {}, identity: Symbol("ILog (interface)") };
	(t => __RΦ$2$1.t[403] = t)(IΦILog);
	__RΦ$2$1.m("rt:P", ["enqueue", "dequeue"])(IΦILog);
	__RΦ$2$1.m("rt:m", [])(IΦILog);
	__RΦ$2$1.m("rt:f", "I")(IΦILog);
	__RΦ$2$1.m("rt:t", () => __RΦ$2$1.a(407))(IΦILog.prototype, "enqueue");
	__RΦ$2$1.m("rt:f", "P")(IΦILog.prototype, "enqueue");
	__RΦ$2$1.m("rt:t", () => __RΦ$2$1.a(407))(IΦILog.prototype, "dequeue");
	__RΦ$2$1.m("rt:f", "P")(IΦILog.prototype, "dequeue");
	__RΦ$2$1.m("rt:t", () => __RΦ$2$1.a(407))(IΦILog.prototype, "enqueue");
	__RΦ$2$1.m("rt:f", "P")(IΦILog.prototype, "enqueue");
	__RΦ$2$1.m("rt:t", () => __RΦ$2$1.a(407))(IΦILog.prototype, "dequeue");
	__RΦ$2$1.m("rt:f", "P")(IΦILog.prototype, "dequeue");
	class QueueLog {
	    queue;
	    queueProxy;
	    log = {
	        enqueue: [],
	        dequeue: []
	    };
	    get sourceQueue() {
	        return this.queue;
	    }
	    get loggedQueue() {
	        return this.queueProxy;
	    }
	    static create(queue) {
	        const queueLog = new QueueLog(queue);
	        return [queueLog.loggedQueue, queueLog];
	    }
	    constructor(queue) {
	        this.queue = queue;
	        this.queueProxy = (new Proxy(queue, {
	            get: this.proxyHandlerGet.bind(this)
	        }));
	    }
	    proxyHandlerGet(target, property, receiver) {
	        const origin = Reflect.get(target, property, receiver);
	        switch (property) {
	            case 'enqueue': return this.createEnqueue(target, origin);
	            case 'dequeue': return this.createDequeue(target, origin);
	            default: return origin;
	        }
	    }
	    createEnqueue(target, origin) {
	        return (__RΦ$2$1.f((...items) => {
	            this.log.enqueue.push(...items);
	            origin.call(target, ...items);
	        }, [__RΦ$2$1.m("rt:p", [{ n: "items", t: () => __RΦ$2$1.a(408), v: null }]), __RΦ$2$1.m("rt:f", "F>"), __RΦ$2$1.m("rt:t", () => __RΦ$2$1.a(23))], ""));
	    }
	    createDequeue(target, origin) {
	        return (__RΦ$2$1.f(() => {
	            const item = origin.call(target);
	            if (item) {
	                this.log.dequeue.push(item);
	            }
	            return item;
	        }, [__RΦ$2$1.m("rt:p", []), __RΦ$2$1.m("rt:f", "F>"), __RΦ$2$1.m("rt:t", () => __RΦ$2$1.a(428))], ""));
	    }
	}
	(t => __RΦ$2$1.t[229] = t)(QueueLog);
	__RΦ$2$1.m("rt:SP", [])(QueueLog);
	__RΦ$2$1.m("rt:P", ["queueProxy", "log", "sourceQueue", "loggedQueue", "queue"])(QueueLog);
	__RΦ$2$1.m("rt:Sm", ["create"])(QueueLog);
	__RΦ$2$1.m("rt:m", ["proxyHandlerGet", "createEnqueue", "createDequeue"])(QueueLog);
	__RΦ$2$1.m("rt:p", [{ n: "queue", t: () => __RΦ$2$1.a(273), v: null, f: "#" }])(QueueLog);
	__RΦ$2$1.m("rt:f", "Ce")(QueueLog);
	__RΦ$2$1.m("rt:t", () => __RΦ$2$1.a(273))(QueueLog.prototype, "queueProxy");
	__RΦ$2$1.m("rt:f", "P#R")(QueueLog.prototype, "queueProxy");
	__RΦ$2$1.m("rt:t", () => __RΦ$2$1.a(406))(QueueLog.prototype, "log");
	__RΦ$2$1.m("rt:f", "P#")(QueueLog.prototype, "log");
	__RΦ$2$1.m("rt:t", () => __RΦ$2$1.a(4))(QueueLog.prototype, "sourceQueue");
	__RΦ$2$1.m("rt:f", "P$")(QueueLog.prototype, "sourceQueue");
	__RΦ$2$1.m("rt:t", () => __RΦ$2$1.a(4))(QueueLog.prototype, "loggedQueue");
	__RΦ$2$1.m("rt:f", "P$")(QueueLog.prototype, "loggedQueue");
	__RΦ$2$1.m("rt:f", "M$S")(QueueLog["create"]);
	((t, p) => __RΦ$2$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog, "create");
	__RΦ$2$1.m("rt:p", [{ n: "queue", t: () => __RΦ$2$1.a(622), v: null }])(QueueLog, "create");
	__RΦ$2$1.m("rt:f", "M$S")(QueueLog, "create");
	__RΦ$2$1.m("rt:t", () => __RΦ$2$1.a(628))(QueueLog, "create");
	__RΦ$2$1.m("rt:f", "M#")(QueueLog.prototype["proxyHandlerGet"]);
	((t, p) => __RΦ$2$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog.prototype, "proxyHandlerGet");
	__RΦ$2$1.m("rt:p", [{ n: "target", t: () => __RΦ$2$1.a(273), v: null }, { n: "property", t: () => __RΦ$2$1.a(143), v: null }, { n: "receiver", t: () => __RΦ$2$1.a(1), v: null }])(QueueLog.prototype, "proxyHandlerGet");
	__RΦ$2$1.m("rt:f", "M#")(QueueLog.prototype, "proxyHandlerGet");
	__RΦ$2$1.m("rt:t", () => __RΦ$2$1.a(1))(QueueLog.prototype, "proxyHandlerGet");
	__RΦ$2$1.m("rt:f", "M#.")(QueueLog.prototype["createEnqueue"]);
	((t, p) => __RΦ$2$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog.prototype, "createEnqueue");
	__RΦ$2$1.m("rt:p", [{ n: "target", t: () => __RΦ$2$1.a(273), v: null }, { n: "origin", t: () => __RΦ$2$1.a(397), v: null }])(QueueLog.prototype, "createEnqueue");
	__RΦ$2$1.m("rt:f", "M#.")(QueueLog.prototype, "createEnqueue");
	__RΦ$2$1.m("rt:t", () => __RΦ$2$1.a(629))(QueueLog.prototype, "createEnqueue");
	__RΦ$2$1.m("rt:f", "M#.")(QueueLog.prototype["createDequeue"]);
	((t, p) => __RΦ$2$1.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueLog.prototype, "createDequeue");
	__RΦ$2$1.m("rt:p", [{ n: "target", t: () => __RΦ$2$1.a(273), v: null }, { n: "origin", t: () => __RΦ$2$1.a(402), v: null }])(QueueLog.prototype, "createDequeue");
	__RΦ$2$1.m("rt:f", "M#.")(QueueLog.prototype, "createDequeue");
	__RΦ$2$1.m("rt:t", () => __RΦ$2$1.a(630))(QueueLog.prototype, "createDequeue");

	const __RΦ$1$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$1$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$1$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$1$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$1$1.a(14), __RΦ$1$1.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [144]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$1$1.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [146]: { RΦ: t => ({ TΦ: "t" }) } } };
	var IΦdefault$a = { name: "IEventEmitter", prototype: {}, identity: Symbol("IEventEmitter (interface)") };
	(t => __RΦ$1$1.t[145] = t)(IΦdefault$a);
	__RΦ$1$1.m("rt:P", [])(IΦdefault$a);
	__RΦ$1$1.m("rt:m", ["on"])(IΦdefault$a);
	__RΦ$1$1.m("rt:f", "Ie")(IΦdefault$a);
	__RΦ$1$1.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$1.a(143), v: null }, { n: "listener", t: () => __RΦ$1$1.a(144), v: null }])(IΦdefault$a.prototype, "on");
	__RΦ$1$1.m("rt:f", "M")(IΦdefault$a.prototype, "on");
	__RΦ$1$1.m("rt:t", () => __RΦ$1$1.a(146))(IΦdefault$a.prototype, "on");
	__RΦ$1$1.m("rt:p", [{ n: "eventName", t: () => __RΦ$1$1.a(143), v: null }, { n: "listener", t: () => __RΦ$1$1.a(144), v: null }])(IΦdefault$a.prototype, "on");
	__RΦ$1$1.m("rt:f", "M")(IΦdefault$a.prototype, "on");
	__RΦ$1$1.m("rt:t", () => __RΦ$1$1.a(146))(IΦdefault$a.prototype, "on");

	const __RΦ$s = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$s.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$s.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$s.t[id] = t = l;
	        }
	        return t;
	    }, t: { [4]: { RΦ: t => ({ TΦ: "~" }) }, [641]: { RΦ: t => ({ TΦ: "[", e: __RΦ$s.a(631) }) }, [631]: { LΦ: t => Object }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [658]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$s.a(10), __RΦ$s.a(633)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [633]: { LΦ: t => Object }, [143]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$s.a(14), __RΦ$s.a(22)] }) }, [14]: { LΦ: t => String }, [22]: { LΦ: t => Object }, [662]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$s.a(4) }] }) }, [634]: { RΦ: t => ({ TΦ: "t" }) } } };
	class QueueWithEventEmitter extends Queue {
	    eventEmitter = new EventEmitter__default["default"];
	    enqueue(...items) {
	        this.eventEmitter.emit('before-enqueue', this, ...items);
	        super.enqueue(...items);
	        this.eventEmitter.emit('enqueue', this, ...items);
	    }
	    dequeue() {
	        const removed = super.dequeue();
	        this.eventEmitter.emit('dequeue', this, removed);
	        return removed;
	    }
	    on(eventName, listener) {
	        this.eventEmitter.on(eventName, listener);
	        return this;
	    }
	}
	(t => __RΦ$s.t[632] = t)(QueueWithEventEmitter);
	__RΦ$s.m("rt:SP", [])(QueueWithEventEmitter);
	__RΦ$s.m("rt:P", ["eventEmitter"])(QueueWithEventEmitter);
	__RΦ$s.m("rt:Sm", [])(QueueWithEventEmitter);
	__RΦ$s.m("rt:m", ["enqueue", "dequeue", "on"])(QueueWithEventEmitter);
	__RΦ$s.m("rt:i", [() => undefined])(QueueWithEventEmitter);
	__RΦ$s.m("rt:f", "Ce")(QueueWithEventEmitter);
	__RΦ$s.m("rt:t", () => __RΦ$s.a(4))(QueueWithEventEmitter.prototype, "eventEmitter");
	__RΦ$s.m("rt:f", "P#")(QueueWithEventEmitter.prototype, "eventEmitter");
	__RΦ$s.m("rt:f", "M$")(QueueWithEventEmitter.prototype["enqueue"]);
	((t, p) => __RΦ$s.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter.prototype, "enqueue");
	__RΦ$s.m("rt:p", [{ n: "items", t: () => __RΦ$s.a(641), v: null }])(QueueWithEventEmitter.prototype, "enqueue");
	__RΦ$s.m("rt:f", "M$")(QueueWithEventEmitter.prototype, "enqueue");
	__RΦ$s.m("rt:t", () => __RΦ$s.a(23))(QueueWithEventEmitter.prototype, "enqueue");
	__RΦ$s.m("rt:f", "M$")(QueueWithEventEmitter.prototype["dequeue"]);
	((t, p) => __RΦ$s.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter.prototype, "dequeue");
	__RΦ$s.m("rt:p", [])(QueueWithEventEmitter.prototype, "dequeue");
	__RΦ$s.m("rt:f", "M$")(QueueWithEventEmitter.prototype, "dequeue");
	__RΦ$s.m("rt:t", () => __RΦ$s.a(658))(QueueWithEventEmitter.prototype, "dequeue");
	__RΦ$s.m("rt:f", "M$")(QueueWithEventEmitter.prototype["on"]);
	((t, p) => __RΦ$s.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(QueueWithEventEmitter.prototype, "on");
	__RΦ$s.m("rt:p", [{ n: "eventName", t: () => __RΦ$s.a(143), v: null }, { n: "listener", t: () => __RΦ$s.a(662), v: null }])(QueueWithEventEmitter.prototype, "on");
	__RΦ$s.m("rt:f", "M$")(QueueWithEventEmitter.prototype, "on");
	__RΦ$s.m("rt:t", () => __RΦ$s.a(634))(QueueWithEventEmitter.prototype, "on");

	dist.Angle = Angle;
	dist.Convert = Convert;
	dist.GameLoop = GameLoop;
	dist.KeyUpDownProcessor = KeyUpDownProcessor;
	dist.Lazy = Lazy;
	dist.Queue = Queue;
	dist.QueueLog = QueueLog;
	dist.QueueWithEventEmitter = QueueWithEventEmitter;
	dist.Shortcut = Shortcut;
	dist.ShortcutDispatcher = ShortcutDispatcher;
	dist.Timer = Timer;
	dist.Vector = Vector;
	dist.execActionScript = execActionScript;
	dist.execFunctionScript = execFunctionScript;
	dist.isBrowser = isBrowser;
	dist.isStoppable = isStoppable;
	dist.onKeyDown = onKeyDown;
	dist.onKeyUp = onKeyUp;
	dist.toOneLine = toOneLine;

	const __RΦ$9 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$9.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$9.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$9.t[id] = t = l;
	        }
	        return t;
	    }, t: { [1]: { RΦ: t => ({ TΦ: "~" }) }, [22]: { LΦ: t => Boolean }, [15]: { LΦ: t => String }, [97]: { LΦ: t => Object }, [98]: { LΦ: t => Object }, [99]: { LΦ: t => Object }, [24]: { RΦ: t => ({ TΦ: "V" }) }, [105]: { RΦ: t => ({ TΦ: "[", e: __RΦ$9.a(104) }) }, [104]: { RΦ: t => ({ TΦ: "g", t: __RΦ$9.a(100), p: [__RΦ$9.a(15), __RΦ$9.a(1)] }) }, [100]: { LΦ: t => dist["IΦdefault"] } } };
	function isUniversalObject(object) {
	    return ('getValue' in object &&
	        'setValue' in object &&
	        'items' in object &&
	        typeof object.getValue === 'function' &&
	        typeof object.setValue === 'function' &&
	        Array.isArray(object.items));
	}
	__RΦ$9.m("rt:p", [{ n: "object", t: () => __RΦ$9.a(1), v: null }])(isUniversalObject);
	__RΦ$9.m("rt:f", "F")(isUniversalObject);
	__RΦ$9.m("rt:t", () => __RΦ$9.a(22))(isUniversalObject);
	var IΦdefault$b = { name: "IUniversalObject", prototype: {}, identity: Symbol("IUniversalObject (interface)") };
	(t => __RΦ$9.t[294] = t)(IΦdefault$b);
	__RΦ$9.m("rt:P", ["items"])(IΦdefault$b);
	__RΦ$9.m("rt:m", ["getValue", "getValue", "setValue"])(IΦdefault$b);
	__RΦ$9.m("rt:f", "Ie")(IΦdefault$b);
	__RΦ$9.m("rt:p", [{ n: "name", t: () => __RΦ$9.a(15), v: null }])(IΦdefault$b.prototype, "getValue");
	__RΦ$9.m("rt:f", "M")(IΦdefault$b.prototype, "getValue");
	__RΦ$9.m("rt:t", () => __RΦ$9.a(97))(IΦdefault$b.prototype, "getValue");
	__RΦ$9.m("rt:p", [{ n: "name", t: () => __RΦ$9.a(15), v: null }, { n: "defaultValue", t: () => __RΦ$9.a(98), v: null }])(IΦdefault$b.prototype, "getValue");
	__RΦ$9.m("rt:f", "M")(IΦdefault$b.prototype, "getValue");
	__RΦ$9.m("rt:t", () => __RΦ$9.a(98))(IΦdefault$b.prototype, "getValue");
	__RΦ$9.m("rt:p", [{ n: "name", t: () => __RΦ$9.a(15), v: null }, { n: "value", t: () => __RΦ$9.a(99), v: null }])(IΦdefault$b.prototype, "setValue");
	__RΦ$9.m("rt:f", "M")(IΦdefault$b.prototype, "setValue");
	__RΦ$9.m("rt:t", () => __RΦ$9.a(24))(IΦdefault$b.prototype, "setValue");
	__RΦ$9.m("rt:t", () => __RΦ$9.a(105))(IΦdefault$b.prototype, "items");
	__RΦ$9.m("rt:f", "PR")(IΦdefault$b.prototype, "items");
	__RΦ$9.m("rt:p", [{ n: "name", t: () => __RΦ$9.a(15), v: null }])(IΦdefault$b.prototype, "getValue");
	__RΦ$9.m("rt:f", "M")(IΦdefault$b.prototype, "getValue");
	__RΦ$9.m("rt:t", () => __RΦ$9.a(97))(IΦdefault$b.prototype, "getValue");
	__RΦ$9.m("rt:p", [{ n: "name", t: () => __RΦ$9.a(15), v: null }, { n: "defaultValue", t: () => __RΦ$9.a(98), v: null }])(IΦdefault$b.prototype, "getValue");
	__RΦ$9.m("rt:f", "M")(IΦdefault$b.prototype, "getValue");
	__RΦ$9.m("rt:t", () => __RΦ$9.a(98))(IΦdefault$b.prototype, "getValue");
	__RΦ$9.m("rt:p", [{ n: "name", t: () => __RΦ$9.a(15), v: null }, { n: "value", t: () => __RΦ$9.a(99), v: null }])(IΦdefault$b.prototype, "setValue");
	__RΦ$9.m("rt:f", "M")(IΦdefault$b.prototype, "setValue");
	__RΦ$9.m("rt:t", () => __RΦ$9.a(24))(IΦdefault$b.prototype, "setValue");
	__RΦ$9.m("rt:t", () => __RΦ$9.a(105))(IΦdefault$b.prototype, "items");
	__RΦ$9.m("rt:f", "PR")(IΦdefault$b.prototype, "items");

	const __RΦ$8 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$8.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$8.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$8.t[id] = t = l;
	        }
	        return t;
	    }, t: { [294]: { LΦ: t => IΦdefault$b } } };
	class Adapter {
	    universalObject;
	    constructor(universalObject) {
	        this.universalObject = universalObject;
	    }
	}
	(t => __RΦ$8.t[295] = t)(Adapter);
	__RΦ$8.m("rt:SP", [])(Adapter);
	__RΦ$8.m("rt:P", ["universalObject"])(Adapter);
	__RΦ$8.m("rt:Sm", [])(Adapter);
	__RΦ$8.m("rt:m", [])(Adapter);
	__RΦ$8.m("rt:p", [{ n: "universalObject", t: () => __RΦ$8.a(294), v: null, f: "@" }])(Adapter);
	__RΦ$8.m("rt:f", "Ce")(Adapter);

	const __RΦ$7 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$7.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$7.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$7.t[id] = t = l;
	        }
	        return t;
	    }, t: { [305]: { RΦ: t => ({ TΦ: "g", t: __RΦ$7.a(301), p: [__RΦ$7.a(15), __RΦ$7.a(1)] }) }, [301]: { LΦ: t => Map }, [15]: { LΦ: t => String }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [322]: { LΦ: t => Object }, [323]: { LΦ: t => Object }, [297]: { LΦ: t => Object }, [310]: { LΦ: t => Object }, [24]: { RΦ: t => ({ TΦ: "V" }) }, [4]: { RΦ: t => ({ TΦ: "~" }) } } };
	/**
	 * Объект, который хранит в себе набор разнотипных свойств.
	 * Простая реализация интерфейса IUniversalObject.
	 */
	class UniversalObject {
	    map = new Map;
	    getValue(name, defaultValue) {
	        const value = this.map.get(name);
	        return value === undefined ? defaultValue : value;
	    }
	    /**
	     * Установить значение элемента.
	     * @param name
	     * @param value
	     */
	    setValue(name, value) {
	        this.map.set(name, value);
	    }
	    /**
	     * Получить список элементов в виде массива,
	     * где каждый элемент представлен двумя ключами: key и value.
	     */
	    get items() {
	        return khusamovBaseTypes.Convert.toArray(this.map);
	    }
	}
	(t => __RΦ$7.t[298] = t)(UniversalObject);
	__RΦ$7.m("rt:SP", [])(UniversalObject);
	__RΦ$7.m("rt:P", ["map", "items"])(UniversalObject);
	__RΦ$7.m("rt:Sm", [])(UniversalObject);
	__RΦ$7.m("rt:m", ["getValue", "getValue", "getValue", "setValue"])(UniversalObject);
	__RΦ$7.m("rt:i", [() => IΦIUniversalObject])(UniversalObject);
	__RΦ$7.m("rt:f", "Ce")(UniversalObject);
	__RΦ$7.m("rt:t", () => __RΦ$7.a(305))(UniversalObject.prototype, "map");
	__RΦ$7.m("rt:f", "P#")(UniversalObject.prototype, "map");
	__RΦ$7.m("rt:f", "M")(UniversalObject.prototype["getValue"]);
	((t, p) => __RΦ$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(UniversalObject.prototype, "getValue");
	__RΦ$7.m("rt:p", [{ n: "name", t: () => __RΦ$7.a(15), v: null }])(UniversalObject.prototype, "getValue");
	__RΦ$7.m("rt:f", "M")(UniversalObject.prototype, "getValue");
	__RΦ$7.m("rt:t", () => __RΦ$7.a(322))(UniversalObject.prototype, "getValue");
	__RΦ$7.m("rt:f", "M")(UniversalObject.prototype["getValue"]);
	((t, p) => __RΦ$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(UniversalObject.prototype, "getValue");
	__RΦ$7.m("rt:p", [{ n: "name", t: () => __RΦ$7.a(15), v: null }, { n: "defaultValue", t: () => __RΦ$7.a(323), v: null }])(UniversalObject.prototype, "getValue");
	__RΦ$7.m("rt:f", "M")(UniversalObject.prototype, "getValue");
	__RΦ$7.m("rt:t", () => __RΦ$7.a(323))(UniversalObject.prototype, "getValue");
	__RΦ$7.m("rt:f", "M")(UniversalObject.prototype["getValue"]);
	((t, p) => __RΦ$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(UniversalObject.prototype, "getValue");
	__RΦ$7.m("rt:p", [{ n: "name", t: () => __RΦ$7.a(15), v: null }, { n: "defaultValue", t: () => __RΦ$7.a(297), v: null, f: "?" }])(UniversalObject.prototype, "getValue");
	__RΦ$7.m("rt:f", "M")(UniversalObject.prototype, "getValue");
	__RΦ$7.m("rt:t", () => __RΦ$7.a(297))(UniversalObject.prototype, "getValue");
	__RΦ$7.m("rt:f", "M$.")(UniversalObject.prototype["setValue"]);
	((t, p) => __RΦ$7.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(UniversalObject.prototype, "setValue");
	__RΦ$7.m("rt:p", [{ n: "name", t: () => __RΦ$7.a(15), v: null }, { n: "value", t: () => __RΦ$7.a(310), v: null }])(UniversalObject.prototype, "setValue");
	__RΦ$7.m("rt:f", "M$.")(UniversalObject.prototype, "setValue");
	__RΦ$7.m("rt:t", () => __RΦ$7.a(24))(UniversalObject.prototype, "setValue");
	__RΦ$7.m("rt:t", () => __RΦ$7.a(4))(UniversalObject.prototype, "items");
	__RΦ$7.m("rt:f", "P$")(UniversalObject.prototype, "items");

	const __RΦ$6 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$6.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$6.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$6.t[id] = t = l;
	        }
	        return t;
	    }, t: { [30]: { LΦ: t => Object }, [105]: { RΦ: t => ({ TΦ: "[", e: __RΦ$6.a(104) }) }, [104]: { RΦ: t => ({ TΦ: "g", t: __RΦ$6.a(100), p: [__RΦ$6.a(15), __RΦ$6.a(1)] }) }, [100]: { LΦ: t => dist["IΦdefault"] }, [15]: { LΦ: t => String }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [327]: { LΦ: t => Object }, [332]: { LΦ: t => Object }, [24]: { RΦ: t => ({ TΦ: "V" }) } } };
	// TODO Удалить UniversalObjectAdapter
	/**
	 * @deprecated
	 */
	class UniversalObjectAdapter {
	    plainObject;
	    get items() {
	        // TODO Реализовать свойство items.
	        throw new Error('Свойство UniversalObjectAdapter.items не реализовано');
	    }
	    constructor(plainObject) {
	        this.plainObject = plainObject;
	    }
	    getValue(name, defaultValue) {
	        const value = Reflect.get(this.plainObject, name);
	        return value === undefined ? defaultValue : value;
	    }
	    setValue(name, value) {
	        Reflect.set(this.plainObject, name, value);
	    }
	}
	(t => __RΦ$6.t[328] = t)(UniversalObjectAdapter);
	__RΦ$6.m("rt:SP", [])(UniversalObjectAdapter);
	__RΦ$6.m("rt:P", ["items", "plainObject"])(UniversalObjectAdapter);
	__RΦ$6.m("rt:Sm", [])(UniversalObjectAdapter);
	__RΦ$6.m("rt:m", ["getValue", "setValue"])(UniversalObjectAdapter);
	__RΦ$6.m("rt:p", [{ n: "plainObject", t: () => __RΦ$6.a(30), v: null, f: "#" }])(UniversalObjectAdapter);
	__RΦ$6.m("rt:i", [() => IΦIUniversalObject])(UniversalObjectAdapter);
	__RΦ$6.m("rt:f", "Ce")(UniversalObjectAdapter);
	__RΦ$6.m("rt:t", () => __RΦ$6.a(105))(UniversalObjectAdapter.prototype, "items");
	__RΦ$6.m("rt:f", "P$")(UniversalObjectAdapter.prototype, "items");
	__RΦ$6.m("rt:f", "M$")(UniversalObjectAdapter.prototype["getValue"]);
	((t, p) => __RΦ$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(UniversalObjectAdapter.prototype, "getValue");
	__RΦ$6.m("rt:p", [{ n: "name", t: () => __RΦ$6.a(15), v: null }, { n: "defaultValue", t: () => __RΦ$6.a(327), v: null, f: "?" }])(UniversalObjectAdapter.prototype, "getValue");
	__RΦ$6.m("rt:f", "M$")(UniversalObjectAdapter.prototype, "getValue");
	__RΦ$6.m("rt:t", () => __RΦ$6.a(327))(UniversalObjectAdapter.prototype, "getValue");
	__RΦ$6.m("rt:f", "M$")(UniversalObjectAdapter.prototype["setValue"]);
	((t, p) => __RΦ$6.m("rt:h", () => typeof t === "object" ? t.constructor : t)(t[p]))(UniversalObjectAdapter.prototype, "setValue");
	__RΦ$6.m("rt:p", [{ n: "name", t: () => __RΦ$6.a(15), v: null }, { n: "value", t: () => __RΦ$6.a(332), v: null }])(UniversalObjectAdapter.prototype, "setValue");
	__RΦ$6.m("rt:f", "M$")(UniversalObjectAdapter.prototype, "setValue");
	__RΦ$6.m("rt:t", () => __RΦ$6.a(24))(UniversalObjectAdapter.prototype, "setValue");

	const __RΦ$5 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$5.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$5.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$5.t[id] = t = l;
	        }
	        return t;
	    }, t: { [477]: { LΦ: t => Object }, [333]: { LΦ: t => Object } } };
	/**
	 * Заполнить универсальный объект значениями свойств plane-объекта.
	 * Внимание, объект universalObject будет изменен.
	 * @param universalObject
	 * @param object
	 */
	function fillUniversalObject(universalObject, object) {
	    const result = universalObject;
	    for (const key in object) {
	        if (object.hasOwnProperty(key)) {
	            result.setValue(key, object[key]);
	        }
	    }
	    return result;
	}
	__RΦ$5.m("rt:p", [{ n: "universalObject", t: () => __RΦ$5.a(477), v: null }, { n: "object", t: () => __RΦ$5.a(333), v: null }])(fillUniversalObject);
	__RΦ$5.m("rt:f", "F")(fillUniversalObject);
	__RΦ$5.m("rt:t", () => __RΦ$5.a(477))(fillUniversalObject);

	const __RΦ$4 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$4.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$4.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$4.t[id] = t = l;
	        }
	        return t;
	    }, t: { [487]: { RΦ: t => ({ TΦ: "m", t: __RΦ$4.a(488), p: [__RΦ$4.a(486)] }) }, [488]: { LΦ: t => Object }, [486]: { LΦ: t => Object }, [298]: { LΦ: t => UniversalObject } } };
	/**
	 * Создать IUniversalObject на основе plane-объекта.
	 * @param object
	 */
	function createUniversalObject(object) {
	    return fillUniversalObject(new UniversalObject, object);
	}
	__RΦ$4.m("rt:p", [{ n: "object", t: () => __RΦ$4.a(487), v: null }])(createUniversalObject);
	__RΦ$4.m("rt:f", "F")(createUniversalObject);
	__RΦ$4.m("rt:t", () => __RΦ$4.a(298))(createUniversalObject);

	const __RΦ$3 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$3.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$3.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$3.t[id] = t = l;
	        }
	        return t;
	    }, t: { [582]: { RΦ: t => ({ TΦ: "[", e: __RΦ$3.a(581) }) }, [581]: { LΦ: t => Object }, [520]: { LΦ: t => Object }, [22]: { LΦ: t => Boolean }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [294]: { LΦ: t => IΦdefault$b } } };
	/**
	 * Поиск объекта.
	 * Ищется первый объект для которого совпадает хотя бы один из параметров.
	 * @param list Массив объектов, в котором производится поиск.
	 * @param params Параметры искомого объекта.
	 */
	function findUniversalObject(list, params) {
	    const predicate = __RΦ$3.f((object) => (Object.entries(params).reduce(__RΦ$3.f((result, [key, value]) => result && object.getValue(key) === value, [__RΦ$3.m("rt:p", [{ n: "result", t: () => __RΦ$3.a(22), v: null }, { n: "[key, value]", t: () => __RΦ$3.a(4), v: null }]), __RΦ$3.m("rt:f", "F>"), __RΦ$3.m("rt:t", () => __RΦ$3.a(22))], ""), true)), [__RΦ$3.m("rt:p", [{ n: "object", t: () => __RΦ$3.a(294), v: null }]), __RΦ$3.m("rt:f", "F>"), __RΦ$3.m("rt:t", () => __RΦ$3.a(22))], "");
	    return list.find(predicate);
	}
	__RΦ$3.m("rt:p", [{ n: "list", t: () => __RΦ$3.a(582), v: null }, { n: "params", t: () => __RΦ$3.a(520), v: null }])(findUniversalObject);
	__RΦ$3.m("rt:f", "F")(findUniversalObject);
	__RΦ$3.m("rt:t", () => __RΦ$3.a(581))(findUniversalObject);

	const __RΦ$2$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$2$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$2$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$2$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [605]: { LΦ: t => Object }, [615]: { RΦ: t => ({ TΦ: "m", t: __RΦ$2$2.a(616), p: [__RΦ$2$2.a(605), __RΦ$2$2.a(611)] }) }, [616]: { LΦ: t => Object }, [611]: { LΦ: t => "type" } } };
	/**
	 * Клонирует объект и удаляет из него свойство type.
	 * @param object
	 */
	function withoutType(object) {
	    object = Object.assign({}, object);
	    delete object.type;
	    return object;
	}
	__RΦ$2$2.m("rt:p", [{ n: "object", t: () => __RΦ$2$2.a(605), v: null }])(withoutType);
	__RΦ$2$2.m("rt:f", "F")(withoutType);
	__RΦ$2$2.m("rt:t", () => __RΦ$2$2.a(615))(withoutType);

	const __RΦ$1$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$1$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$1$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$1$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [621]: { LΦ: t => Object }, [294]: { LΦ: t => IΦdefault$b } } };
	/**
	 * Разрешение зависимости вида <Тип объекта>.
	 *
	 * Позволяет найти объект этого типа по набору признаков params.
	 * Поиск объекта будет будет производится в массиве, который будет найден как зависимость <Тип объекта + List>.
	 *
	 * Пример регистрации такой зависимости:
	 * - register('GameObject', universalObjectResolver).
	 * - register('GameObjectList', (): IUniversalObject => [])
	 *
	 * @param params Параметры искомого объекта. Поле type не участвует в поиске.
	 */
	function universalObjectResolver(params) {
	    const universalObjectList = khusamovInversionOfControl.resolve(params.type + 'List');
	    return findUniversalObject(universalObjectList, withoutType(params));
	}
	__RΦ$1$2.m("rt:p", [{ n: "params", t: () => __RΦ$1$2.a(621), v: null }])(universalObjectResolver);
	__RΦ$1$2.m("rt:f", "F")(universalObjectResolver);
	__RΦ$1$2.m("rt:t", () => __RΦ$1$2.a(294))(universalObjectResolver);

	const __RΦ$t = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$t.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$t.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$t.t[id] = t = l;
	        }
	        return t;
	    }, t: { [294]: { LΦ: t => IΦdefault$b }, [641]: { RΦ: t => ({ TΦ: "[", e: __RΦ$t.a(640) }) }, [640]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__constructor", f: "", t: __RΦ$t.a(4) }, { n: "universalObject", f: "", t: __RΦ$t.a(294) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [1]: { RΦ: t => ({ TΦ: "~" }) }, [295]: { LΦ: t => Adapter }, [74]: { RΦ: t => ({ TΦ: "[", e: __RΦ$t.a(1) }) }, [673]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$t.a(15), __RΦ$t.a(23)] }) }, [15]: { LΦ: t => String }, [23]: { LΦ: t => Object }, [22]: { LΦ: t => Boolean } } };
	function createAdapter(universalObject, ...adapterClasses) {
	    if (adapterClasses.length === 1) {
	        const AdapterClass = adapterClasses[0];
	        return new AdapterClass(universalObject);
	    }
	    else {
	        return new Proxy(adapterClasses.map(__RΦ$t.f(AdapterClass => new AdapterClass(universalObject), [__RΦ$t.m("rt:p", [{ n: "AdapterClass", t: () => __RΦ$t.a(4), v: null }]), __RΦ$t.m("rt:f", "F>"), __RΦ$t.m("rt:t", () => __RΦ$t.a(295))], "")), {
	            get: proxyHandlerGet,
	            set: proxyHandlerSet
	        });
	    }
	}
	__RΦ$t.m("rt:p", [{ n: "universalObject", t: () => __RΦ$t.a(294), v: null }, { n: "adapterClasses", t: () => __RΦ$t.a(641), v: null }])(createAdapter);
	__RΦ$t.m("rt:f", "F")(createAdapter);
	__RΦ$t.m("rt:t", () => __RΦ$t.a(1))(createAdapter);
	function proxyHandlerGet(adapters, property) {
	    for (const adapter of adapters) {
	        if (property in adapter) {
	            const value = Reflect.get(adapter, property);
	            return (typeof value === 'function'
	                ? value.bind(adapter)
	                : value);
	        }
	    }
	}
	__RΦ$t.m("rt:p", [{ n: "adapters", t: () => __RΦ$t.a(74), v: null }, { n: "property", t: () => __RΦ$t.a(673), v: null }])(proxyHandlerGet);
	__RΦ$t.m("rt:f", "F")(proxyHandlerGet);
	__RΦ$t.m("rt:t", () => __RΦ$t.a(1))(proxyHandlerGet);
	function proxyHandlerSet(adapters, property, value) {
	    for (const adapter of adapters) {
	        if (property in adapter) {
	            return Reflect.set(adapter, property, value);
	        }
	    }
	    return false;
	}
	__RΦ$t.m("rt:p", [{ n: "adapters", t: () => __RΦ$t.a(74), v: null }, { n: "property", t: () => __RΦ$t.a(673), v: null }, { n: "value", t: () => __RΦ$t.a(1), v: null }])(proxyHandlerSet);
	__RΦ$t.m("rt:f", "F")(proxyHandlerSet);
	__RΦ$t.m("rt:t", () => __RΦ$t.a(22))(proxyHandlerSet);

	dist$1.Adapter = Adapter;
	var UniversalObject_1 = dist$1.UniversalObject = UniversalObject;
	dist$1.UniversalObjectAdapter = UniversalObjectAdapter;
	dist$1.createAdapter = createAdapter;
	dist$1.createUniversalObject = createUniversalObject;
	dist$1.fillUniversalObject = fillUniversalObject;
	dist$1.findUniversalObject = findUniversalObject;
	dist$1.isUniversalObject = isUniversalObject;
	dist$1.universalObjectResolver = universalObjectResolver;
	dist$1.withoutType = withoutType;

	const __RΦ$2 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$2.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$2.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$2.t[id] = t = l;
	        }
	        return t;
	    }, t: { [14]: { LΦ: t => String }, [838]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$2.a(777), __RΦ$2.a(790), __RΦ$2.a(804), __RΦ$2.a(818), __RΦ$2.a(834), __RΦ$2.a(837)] }) }, [777]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$2.a(754) }, { t: __RΦ$2.a(15) }] }) }, [754]: { LΦ: t => "IncreaseForce" }, [15]: { LΦ: t => Number }, [790]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$2.a(778) }, { t: __RΦ$2.a(15) }] }) }, [778]: { LΦ: t => "DecreaseForce" }, [804]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$2.a(791) }, { t: __RΦ$2.a(15) }] }) }, [791]: { LΦ: t => "ClockwiseRotateForce" }, [818]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$2.a(805) }, { t: __RΦ$2.a(15) }] }) }, [805]: { LΦ: t => "CounterclockwiseRotateForce" }, [834]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$2.a(819) }, { t: __RΦ$2.a(821) }] }) }, [819]: { LΦ: t => "ToroidalPositionTransformation" }, [821]: { RΦ: t => ({ TΦ: "O", m: [{ n: "__call", f: "", t: __RΦ$2.a(4) }] }) }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [837]: { RΦ: t => ({ TΦ: "T", e: [{ t: __RΦ$2.a(835) }] }) }, [835]: { LΦ: t => "UnknownTransformAction" }, [561]: { LΦ: t => UniversalObject_1 }, [1076]: { LΦ: t => undefined } } };
	const keyboardShortcutMoveTransformMap = {
	    w: ['IncreaseForce', 200],
	    s: ['DecreaseForce', 200],
	    a: ['ClockwiseRotateForce', Angle$5.toRadian(1)],
	    d: ['CounterclockwiseRotateForce', Angle$5.toRadian(1)]
	};
	function getSelectedGameObjectName() {
	    const selectedGameObject = resolve('SelectedGameObject');
	    return new GameObjectAdapter(selectedGameObject).name;
	}
	__RΦ$2.m("rt:p", [])(getSelectedGameObjectName);
	__RΦ$2.m("rt:f", "F")(getSelectedGameObjectName);
	__RΦ$2.m("rt:t", () => __RΦ$2.a(14))(getSelectedGameObjectName);
	function createMoveTransformOrder(transformAction, targetObjectName) {
	    return (createUniversalObject$1({
	        type: 'StartMoveTransform',
	        transformAction,
	        targetObject: {
	            type: 'GameObject',
	            name: targetObjectName
	        }
	    }));
	}
	__RΦ$2.m("rt:p", [{ n: "transformAction", t: () => __RΦ$2.a(838), v: null }, { n: "targetObjectName", t: () => __RΦ$2.a(14), v: null }])(createMoveTransformOrder);
	__RΦ$2.m("rt:f", "F")(createMoveTransformOrder);
	__RΦ$2.m("rt:t", () => __RΦ$2.a(561))(createMoveTransformOrder);
	function createStopOrder(transformActionName, targetObjectName) {
	    return (createUniversalObject$1({
	        type: 'Stop',
	        command: 'MoveTransform.' + transformActionName,
	        targetObject: {
	            type: 'GameObject',
	            name: targetObjectName
	        }
	    }));
	}
	__RΦ$2.m("rt:p", [{ n: "transformActionName", t: () => __RΦ$2.a(14), v: null }, { n: "targetObjectName", t: () => __RΦ$2.a(14), v: null }])(createStopOrder);
	__RΦ$2.m("rt:f", "F")(createStopOrder);
	__RΦ$2.m("rt:t", () => __RΦ$2.a(561))(createStopOrder);
	/**
	 * Создает обработчики нажатия клавишь управления выбранным игровым объектом.
	 * Обработчики создают приказы и отправляют их в очередь приказов OrderQueue.
	 */
	function createObjectKeyboardControl() {
	    const disposerList = [];
	    for (const key in keyboardShortcutMoveTransformMap) {
	        if (!keyboardShortcutMoveTransformMap.hasOwnProperty(key))
	            continue;
	        const transformActionParams = keyboardShortcutMoveTransformMap[key];
	        if (!transformActionParams) {
	            throw new Error('Не найдены параметры действия');
	        }
	        disposerList.push(Shortcut$5.register(key, {
	            down() {
	                resolve('OrderQueue').enqueue(createMoveTransformOrder(transformActionParams, getSelectedGameObjectName()));
	            },
	            up() {
	                resolve('OrderQueue').enqueue(createStopOrder(transformActionParams[0], getSelectedGameObjectName()));
	            }
	        }));
	    }
	    return {
	        dispose() {
	            for (const disposer of disposerList) {
	                disposer.dispose();
	            }
	        }
	    };
	}
	__RΦ$2.m("rt:p", [])(createObjectKeyboardControl);
	__RΦ$2.m("rt:f", "F")(createObjectKeyboardControl);
	__RΦ$2.m("rt:t", () => __RΦ$2.a(1076))(createObjectKeyboardControl);

	const __RΦ$1 = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ$1.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ$1.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ$1.t[id] = t = l;
	        }
	        return t;
	    }, t: { [318]: { LΦ: t => "Stop" }, [88]: { RΦ: t => ({ TΦ: "O", m: [{ n: "type", f: "", t: __RΦ$1.a(14) }, { n: "name", f: "", t: __RΦ$1.a(14) }] }) }, [14]: { LΦ: t => String }, [1066]: { RΦ: t => ({ TΦ: "|", t: [__RΦ$1.a(10), __RΦ$1.a(14)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [87]: { LΦ: t => undefined }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [632]: { LΦ: t => undefined } } };
	var IΦdefault = { name: "IStopOrder", prototype: {}, identity: Symbol("IStopOrder (interface)") };
	(t => __RΦ$1.t[1058] = t)(IΦdefault);
	__RΦ$1.m("rt:P", ["type", "targetObject", "command"])(IΦdefault);
	__RΦ$1.m("rt:m", [])(IΦdefault);
	__RΦ$1.m("rt:f", "Ie")(IΦdefault);
	__RΦ$1.m("rt:t", () => __RΦ$1.a(318))(IΦdefault.prototype, "type");
	__RΦ$1.m("rt:f", "P")(IΦdefault.prototype, "type");
	__RΦ$1.m("rt:t", () => __RΦ$1.a(88))(IΦdefault.prototype, "targetObject");
	__RΦ$1.m("rt:f", "P")(IΦdefault.prototype, "targetObject");
	__RΦ$1.m("rt:t", () => __RΦ$1.a(1066))(IΦdefault.prototype, "command");
	__RΦ$1.m("rt:f", "P?")(IΦdefault.prototype, "command");
	__RΦ$1.m("rt:t", () => __RΦ$1.a(318))(IΦdefault.prototype, "type");
	__RΦ$1.m("rt:f", "P")(IΦdefault.prototype, "type");
	__RΦ$1.m("rt:t", () => __RΦ$1.a(88))(IΦdefault.prototype, "targetObject");
	__RΦ$1.m("rt:f", "P")(IΦdefault.prototype, "targetObject");
	__RΦ$1.m("rt:t", () => __RΦ$1.a(1066))(IΦdefault.prototype, "command");
	__RΦ$1.m("rt:f", "P?")(IΦdefault.prototype, "command");
	class StopOrderAdapter {
	    universalObject;
	    type = 'Stop';
	    constructor(universalObject) {
	        this.universalObject = universalObject;
	    }
	    get targetObject() {
	        return this.universalObject.getValue('targetObject', {
	            type: '',
	            name: ''
	        });
	    }
	    set targetObject(value) {
	        this.universalObject.setValue('targetObject', value);
	    }
	    get command() {
	        return this.universalObject.getValue('command');
	    }
	    set command(value) {
	        this.universalObject.setValue('command', value);
	    }
	}
	(t => __RΦ$1.t[1101] = t)(StopOrderAdapter);
	__RΦ$1.m("rt:SP", [])(StopOrderAdapter);
	__RΦ$1.m("rt:P", ["type", "universalObject", "targetObject", "targetObject", "command", "command"])(StopOrderAdapter);
	__RΦ$1.m("rt:Sm", [])(StopOrderAdapter);
	__RΦ$1.m("rt:m", [])(StopOrderAdapter);
	__RΦ$1.m("rt:p", [{ n: "universalObject", t: () => __RΦ$1.a(87), v: null, f: "#" }])(StopOrderAdapter);
	__RΦ$1.m("rt:i", [() => IΦIStopOrder])(StopOrderAdapter);
	__RΦ$1.m("rt:f", "Ce")(StopOrderAdapter);
	__RΦ$1.m("rt:t", () => __RΦ$1.a(4))(StopOrderAdapter.prototype, "type");
	__RΦ$1.m("rt:f", "P$R")(StopOrderAdapter.prototype, "type");
	__RΦ$1.m("rt:t", () => __RΦ$1.a(88))(StopOrderAdapter.prototype, "targetObject");
	__RΦ$1.m("rt:f", "P$")(StopOrderAdapter.prototype, "targetObject");
	__RΦ$1.m("rt:t", () => __RΦ$1.a(88))(StopOrderAdapter.prototype, "targetObject");
	__RΦ$1.m("rt:f", "P$")(StopOrderAdapter.prototype, "targetObject");
	__RΦ$1.m("rt:t", () => __RΦ$1.a(1066))(StopOrderAdapter.prototype, "command");
	__RΦ$1.m("rt:f", "P$")(StopOrderAdapter.prototype, "command");
	__RΦ$1.m("rt:t", () => __RΦ$1.a(1066))(StopOrderAdapter.prototype, "command");
	__RΦ$1.m("rt:f", "P$")(StopOrderAdapter.prototype, "command");
	function stopCommandResolver(stopOrderObject) {
	    const stopOrder = new StopOrderAdapter(stopOrderObject);
	    const targetObject = (resolve(stopOrder.targetObject.type, stopOrder.targetObject));
	    if (!targetObject) {
	        throw new Error(`Целевой объект не найден '${JSON.stringify(stopOrder.targetObject)}'`);
	    }
	    return (stopOrder.command
	        ? new StopCommand(stopOrder.command, targetObject)
	        : new StopCommand(targetObject));
	}
	__RΦ$1.m("rt:p", [{ n: "stopOrderObject", t: () => __RΦ$1.a(87), v: null }])(stopCommandResolver);
	__RΦ$1.m("rt:f", "F")(stopCommandResolver);
	__RΦ$1.m("rt:t", () => __RΦ$1.a(632))(stopCommandResolver);

	const __RΦ = { m: (k, v) => (t, ...a) => t && Reflect.metadata ? Reflect.metadata(k, v)(t, ...a) : void 0, f: (f, d, n) => (d.forEach(d => d(f)), Object.defineProperty(f, "name", { value: n, writable: false }), f), c: (c, d, dp, dsp, n) => (d.forEach(d => d(c)), dp.forEach(([p, d]) => d(c.prototype, p)), dsp.forEach(([p, d]) => d(c, p)), n ? Object.defineProperty(c, "name", { value: n, writable: false }) : undefined, c), r: (o, a) => (Object.assign(o, a)), a: id => {
	        let t = __RΦ.t[id];
	        if (t === void 0)
	            return void 0;
	        if (t.RΦ) {
	            let r = t.RΦ;
	            delete t.RΦ;
	            __RΦ.r(t, r(t));
	        }
	        else if (t.LΦ) {
	            let l = t.LΦ();
	            delete t.LΦ;
	            __RΦ.t[id] = t = l;
	        }
	        return t;
	    }, t: { [537]: { RΦ: t => ({ TΦ: "g", t: __RΦ.a(122), p: [__RΦ.a(121)] }) }, [122]: { LΦ: t => dist$3["IΦdefault"] }, [121]: { LΦ: t => dist$1["IΦdefault"] }, [270]: { RΦ: t => ({ TΦ: "[", e: __RΦ.a(121) }) }, [421]: { RΦ: t => ({ TΦ: "g", t: __RΦ.a(122), p: [__RΦ.a(423)] }) }, [423]: { LΦ: t => dist$3["IΦdefault"] }, [527]: { LΦ: t => LΦ_2__namespace.EventEmitter }, [300]: { RΦ: t => ({ TΦ: "O", m: [{ n: "type", f: "", t: __RΦ.a(14) }, { n: "name", f: "", t: __RΦ.a(14) }] }) }, [14]: { LΦ: t => String }, [144]: { RΦ: t => ({ TΦ: "|", t: [__RΦ.a(10), __RΦ.a(121)] }) }, [10]: { RΦ: t => ({ TΦ: "u" }) }, [15]: { LΦ: t => Number }, [493]: { RΦ: t => ({ TΦ: "O", m: [{ n: "position", f: "", t: __RΦ.a(395) }, { n: "scale", f: "", t: __RΦ.a(395) }] }) }, [395]: { LΦ: t => Vector_1 }, [4]: { RΦ: t => ({ TΦ: "~" }) }, [23]: { RΦ: t => ({ TΦ: "V" }) }, [520]: { LΦ: t => Timer$5 }, [384]: { LΦ: t => undefined } } };
	register('Stop', stopCommandResolver);
	register('Destroy', destroyCommandResolver);
	register('StartMove', startMoveCommandResolver);
	register('StartMoveTransform', startMoveTransformCommandResolver);
	register('MoveTransformAction.ToroidalPositionTransformation', toroidalTransformActionResolver);
	register('MoveTransformAction.ClockwiseRotateForce', clockwiseRotateForceActionResolver);
	register('MoveTransformAction.CounterclockwiseRotateForce', counterclockwiseRotateForceActionResolver);
	register('MoveTransformAction.DecreaseForce', decreaseForceActionResolver);
	register('MoveTransformAction.IncreaseForce', increaseForceActionResolver);
	const commandQueue = createCommandQueue(); // Очередь команд создается по особому!
	const commandQueueEventEmitter = new events$4.exports.EventEmitter();
	const gameObjectList = [];
	function createOrderQueue() {
	    {
	        return new Queue$5;
	    }
	}
	__RΦ.m("rt:p", [])(createOrderQueue);
	__RΦ.m("rt:f", "F")(createOrderQueue);
	__RΦ.m("rt:t", () => __RΦ.a(537))(createOrderQueue);
	const orderQueue = createOrderQueue();
	register('GameObjectList', __RΦ.f(() => gameObjectList, [__RΦ.m("rt:p", []), __RΦ.m("rt:f", "F>"), __RΦ.m("rt:t", () => __RΦ.a(270))], ""));
	register('OrderQueue', __RΦ.f(() => orderQueue, [__RΦ.m("rt:p", []), __RΦ.m("rt:f", "F>"), __RΦ.m("rt:t", () => __RΦ.a(537))], ""));
	register('CommandQueue', __RΦ.f(() => commandQueue, [__RΦ.m("rt:p", []), __RΦ.m("rt:f", "F>"), __RΦ.m("rt:t", () => __RΦ.a(421))], ""));
	register('CommandQueue.EventEmitter', __RΦ.f(() => commandQueueEventEmitter, [__RΦ.m("rt:p", []), __RΦ.m("rt:f", "F>"), __RΦ.m("rt:t", () => __RΦ.a(527))], ""));
	function gameObjectResolver(params) {
	    return findUniversalObject$1(resolve('GameObjectList'), withoutType$1(params));
	}
	__RΦ.m("rt:p", [{ n: "params", t: () => __RΦ.a(300), v: null }])(gameObjectResolver);
	__RΦ.m("rt:f", "F")(gameObjectResolver);
	__RΦ.m("rt:t", () => __RΦ.a(144))(gameObjectResolver);
	register('GameObject', gameObjectResolver);
	/**
	 * Генерация основных игровых объектов.
	 */
	{
	    gameObjectList.push(createUniversalObject$1({
	        name: 'theCamera',
	        kind: ['IGameObject', 'ITransformable']
	    }));
	    gameObjectList.push(createUniversalObject$1({
	        name: 'theGameWorld',
	        kind: ['IGameObject', 'IToroidalSurface'],
	        size: { width: 3000, height: 3000 }
	    }));
	    gameObjectList.push(createUniversalObject$1({
	        name: 'theSpaceship',
	        kind: ['IGameObject', 'ITransformable', 'IMovable', 'IRenderable'],
	        renderComponent: 'Spaceship',
	        mass: 1000
	    }));
	}
	commandQueue.enqueue(new RepeatableCommand(new InterpretOrderCommand));
	/**
	 * Генерация статических звезд.
	 */
	{
	    function getRandomInt(min, max) {
	        min = Math.ceil(min);
	        max = Math.floor(max);
	        return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive
	    }
	    __RΦ.m("rt:p", [{ n: "min", t: () => __RΦ.a(15), v: null }, { n: "max", t: () => __RΦ.a(15), v: null }])(getRandomInt);
	    __RΦ.m("rt:f", "F")(getRandomInt);
	    __RΦ.m("rt:t", () => __RΦ.a(15))(getRandomInt);
	    const theGameWorld = (new ToroidalSurfaceAdapter(resolve('GameObject', {
	        type: 'GameObject',
	        name: 'theGameWorld'
	    })));
	    Array(100)
	        .fill(1)
	        .map(__RΦ.f(() => {
	        const scale = getRandomInt(1, 10);
	        return {
	            position: new Vector$5(getRandomInt(0, theGameWorld.size.width), getRandomInt(0, theGameWorld.size.height)),
	            scale: new Vector$5(scale, scale)
	        };
	    }, [__RΦ.m("rt:p", []), __RΦ.m("rt:f", "F>"), __RΦ.m("rt:t", () => __RΦ.a(493))], ""))
	        .forEach(__RΦ.f(({ scale, position }, index) => {
	        gameObjectList.push(createUniversalObject$1({
	            name: 'theStar' + index,
	            kind: ['IGameObject', 'ITransformable', 'IRenderable'],
	            renderComponent: 'Star',
	            position,
	            scale
	        }));
	    }, [__RΦ.m("rt:p", [{ n: "{scale, position}", t: () => __RΦ.a(4), v: null }, { n: "index", t: () => __RΦ.a(4), v: null }]), __RΦ.m("rt:f", "F>"), __RΦ.m("rt:t", () => __RΦ.a(23))], ""));
	}
	{
	    register('GameTimer', __RΦ.f(() => (new Timer$5(1, __RΦ.f(() => {
	        const commandQueue = resolve('CommandQueue');
	        const command = commandQueue.dequeue();
	        if (command) {
	            command.execute();
	            commandQueueEventEmitter.emit('execute', command);
	        }
	    }, [__RΦ.m("rt:p", []), __RΦ.m("rt:f", "F>"), __RΦ.m("rt:t", () => __RΦ.a(23))], ""))), [__RΦ.m("rt:p", []), __RΦ.m("rt:f", "F>"), __RΦ.m("rt:t", () => __RΦ.a(520))], ""));
	}
	orderQueue.enqueue(createUniversalObject$1({
	    type: 'StartMove',
	    targetObject: {
	        type: 'GameObject',
	        name: 'theSpaceship'
	    }
	}));
	function getToroidalSurfaceSize() {
	    const theGameWorld = (new ToroidalSurfaceAdapter(resolve('GameObject', {
	        type: 'GameObject',
	        name: 'theGameWorld'
	    })));
	    return theGameWorld.size;
	}
	__RΦ.m("rt:p", [])(getToroidalSurfaceSize);
	__RΦ.m("rt:f", "F")(getToroidalSurfaceSize);
	__RΦ.m("rt:t", () => __RΦ.a(384))(getToroidalSurfaceSize);
	orderQueue.enqueue(createUniversalObject$1({
	    type: 'StartMoveTransform',
	    targetObject: {
	        type: 'GameObject',
	        name: 'theSpaceship'
	    },
	    transformAction: [
	        'ToroidalPositionTransformation',
	        getToroidalSurfaceSize
	    ]
	}));
	register('SelectedGameObject', __RΦ.f(() => (resolve('GameObject', {
	    type: 'GameObject',
	    name: 'theSpaceship'
	})), [__RΦ.m("rt:p", []), __RΦ.m("rt:f", "F>"), __RΦ.m("rt:t", () => __RΦ.a(121))], ""));
	createObjectKeyboardControl();

	resolve('GameTimer').start();
	ReactDOM.render(jsxRuntime.exports.jsx(Application, {}), document.getElementById('application'));

}));
//# sourceMappingURL=index.js.map
